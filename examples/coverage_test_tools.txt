/home/emily/repos/Empirical_Tests/source/base/Ptr.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file Ptr.h
    7|       | *  @brief A wrapper for pointers that does careful memory tracking (but only in debug mode).
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  Ptr objects behave as normal pointers under most conditions.  However, if a program is
   11|       | *  compiled with EMP_TRACK_MEM set, then these pointers perform extra tests to ensure that
   12|       | *  they point to valid memory and that memory is freed before pointers are released.
   13|       | *
   14|       | *  If you trip an assert, you can re-do the run a track a specific pointer by defining
   15|       | *  EMP_ABORT_PTR_NEW or EMP_ABORT_PTR_DELETE to the ID of the pointer in question.  This will
   16|       | *  allow you to track the pointer more easily in a debugger.
   17|       | *
   18|       | *  @todo Track information about emp::vector and emp::array objects to make sure we don't
   19|       | *    point directly into them? (A resize() could make such pointers invalid!) Or better, warn
   20|       | *    it vector memory could have moved.
   21|       | *  @todo Get working with threads
   22|       | */
   23|       |
   24|       |#ifndef EMP_PTR_H
   25|       |#define EMP_PTR_H
   26|       |
   27|       |#include <unordered_map>
   28|       |
   29|       |#include "assert.h"
   30|       |#include "vector.h"
   31|       |
   32|       |namespace emp {
   33|       |
   34|       |  namespace internal {
   35|       |    /// An anonymous log2 calculator for hashing below.
   36|      0|    static constexpr size_t Log2(size_t x) { return x <= 1 ? 0 : (Log2(x/2) + 1); }
   37|       |
   38|       |    static bool ptr_debug = false;
   39|       |  }
   40|      0|  void SetPtrDebug(bool _d = true) { internal::ptr_debug = _d; }
   41|      0|  bool GetPtrDebug() { return internal::ptr_debug; }
   42|       |
   43|       |  enum class PtrStatus { DELETED=0, ACTIVE, ARRAY };
   44|       |
   45|       |  class PtrInfo {
   46|       |  private:
   47|       |    const void * ptr;   ///< Which pointer are we keeping data on?
   48|       |    int count;          ///< How many of this pointer do we have?
   49|       |    PtrStatus status;   ///< Has this pointer been deleted? (i.e., we should no longer access it!)
   50|       |    size_t array_bytes; ///< How big is the array pointed to (in bytes)?
   51|       |
   52|       |  public:
   53|      0|    PtrInfo(const void * _ptr) : ptr(_ptr), count(1), status(PtrStatus::ACTIVE), array_bytes(0) {
   54|      0|      if (internal::ptr_debug) std::cout << "Created info for pointer: " << ptr << std::endl;
   55|      0|    }
   56|       |    PtrInfo(const void * _ptr, size_t _array_bytes)
   57|       |      : ptr(_ptr), count(1), status(PtrStatus::ARRAY), array_bytes(_array_bytes)
   58|      0|    {
   59|      0|      emp_assert(_array_bytes >= 1);
   60|      0|      if (internal::ptr_debug) {
   61|      0|        std::cout << "Created info for array pointer (bytes=" << array_bytes << "): "
   62|      0|                  << ptr << std::endl;
   63|      0|      }
   64|      0|    }
   65|       |    PtrInfo(const PtrInfo &) = default;
   66|       |    PtrInfo(PtrInfo &&) = default;
   67|       |    PtrInfo & operator=(const PtrInfo &) = default;
   68|       |    PtrInfo & operator=(PtrInfo &&) = default;
   69|       |
   70|      0|    ~PtrInfo() {
   71|      0|      if (internal::ptr_debug) std::cout << "Deleted info for pointer " << ptr << std::endl;
   72|      0|    }
   73|       |
   74|       |    /// What pointer does this one hold information about?
   75|      0|    const void * GetPtr() const noexcept { return ptr; }
   76|       |
   77|       |    /// How many Ptr objects point to the associated position?
   78|      0|    int GetCount() const noexcept { return count; }
   79|       |
   80|       |    /// If this ptr is to an array, how many bytes large is the array (may be different from size!)
   81|      0|    size_t GetArrayBytes() const noexcept { return array_bytes; }
   82|       |
   83|       |    /// Is this pointer currently valid to access?
   84|      0|    bool IsActive() const noexcept { return (bool) status; }
   85|       |
   86|       |    /// Is this pointer pointing to an array?
   87|      0|    bool IsArray() const noexcept { return status == PtrStatus::ARRAY; }
   88|       |
   89|       |    /// Denote that this pointer is an array.
   90|      0|    void SetArray(size_t bytes) noexcept { array_bytes = bytes; status = PtrStatus::ARRAY; }
   91|       |
   92|       |    /// Add one more pointer.
   93|      0|    void Inc(size_t id) {
   94|      0|      if (internal::ptr_debug) std::cout << "Inc info for pointer " << ptr << std::endl;
   95|      0|      emp_assert(status != PtrStatus::DELETED, "Incrementing deleted pointer!", id);
   96|      0|      count++;
   97|      0|    }
   98|       |
   99|       |    /// Remove a pointer.
  100|      0|    void Dec(size_t id) {
  101|      0|      if (internal::ptr_debug) std::cout << "Dec info for pointer " << ptr << std::endl;
  102|      0|
  103|      0|      // Make sure that we have more than one copy, -or- we've already deleted this pointer
  104|      0|      emp_assert(count > 1 || status == PtrStatus::DELETED, "Removing last reference to owned Ptr!", id);
  105|      0|      count--;
  106|      0|    }
  107|       |
  108|       |    /// Indicate that the associated position has been deleted.
  109|      0|    void MarkDeleted() {
  110|      0|      if (internal::ptr_debug) std::cout << "Marked deleted for pointer " << ptr << std::endl;
  111|      0|      status = PtrStatus::DELETED;
  112|      0|    }
  113|       |
  114|       |    /// Debug utility to determine if everything looks okay with this pointer's information.
  115|      0|    bool OK() const noexcept {
  116|      0|      if (ptr == nullptr) return false;     // Should not have info for a null pointer.
  117|      0|      if (status == PtrStatus::ARRAY) {
  118|      0|        if (array_bytes == 0) return false; // Arrays cannot be size 0.
  119|      0|        if (count == 0) return false;       // Active arrays must have pointers to them.
  120|      0|      }
  121|      0|      if (status == PtrStatus::ACTIVE) {
  122|      0|        if (array_bytes > 0) return false;  // non-arrays must be array size 0.
  123|      0|        if (count == 0) return false;       // Active pointers must have references to them.
  124|      0|      }
  125|      0|      return true;
  126|      0|    }
  127|       |  };
  128|       |
  129|       |
  130|       |  /// Facilitate tracking of all Ptr objects in this run.
  131|       |  class PtrTracker {
  132|       |  private:
  133|       |    std::unordered_map<const void *, size_t> ptr_id;  ///< Associate raw pointers with unique IDs
  134|       |    emp::vector<PtrInfo> id_info;                     ///< Associate IDs with pointer information.
  135|       |    static constexpr size_t UNTRACKED_ID = (size_t) -1;
  136|       |
  137|       |    // Make PtrTracker a singleton.
  138|      0|    PtrTracker() : ptr_id(), id_info() {
  139|      0|      std::cout << "EMP_TRACK_MEM: Pointer tracking is active!\n";
  140|      0|    }
  141|       |    PtrTracker(const PtrTracker &) = delete;
  142|       |    PtrTracker(PtrTracker &&) = delete;
  143|       |    PtrTracker & operator=(const PtrTracker &) = delete;
  144|       |    PtrTracker & operator=(PtrTracker &&) = delete;
  145|       |
  146|       |  public:
  147|      0|    ~PtrTracker() {
  148|      0|      // Track stats about pointer record.
  149|      0|      size_t total = 0;
  150|      0|      size_t remain = 0;
  151|      0|
  152|      0|      // Scan through live pointers and make sure all have been deleted.
  153|      0|      for (const auto & info : id_info) {
  154|      0|        total++;
  155|      0|        if (info.GetCount()) remain++;
  156|      0|
  157|      0|        emp_assert(info.IsActive() == false, info.GetPtr(), info.GetCount(), info.IsActive());
  158|      0|      }
  159|      0|
  160|      0|      std::cout << "EMP_TRACK_MEM: No memory leaks found!\n "
  161|      0|                << total << " pointers found; "
  162|      0|                << remain << " still exist with a non-null value (but have been properly deleted)"
  163|      0|                << std::endl;
  164|      0|    }
  165|       |
  166|       |    /// Treat this class as a singleton with a single Get() method to retrieve it.
  167|      0|    static PtrTracker & Get() { static PtrTracker tracker; return tracker; }
  168|       |
  169|       |    /// Get the info associated with an existing pointer.
  170|      0|    PtrInfo & GetInfo(const void * ptr) { return id_info[ptr_id[ptr]]; }
  171|      0|    PtrInfo & GetInfo(size_t id) { return id_info[id]; }
  172|       |
  173|       |    /// Determine if a pointer is being tracked.
  174|      0|    bool HasPtr(const void * ptr) const {
  175|      0|      if (internal::ptr_debug) std::cout << "HasPtr: " << ptr << std::endl;
  176|      0|      return ptr_id.find(ptr) != ptr_id.end();
  177|      0|    }
  178|       |
  179|       |    /// Retrive the ID associated with a pointer.
  180|      0|    size_t GetCurID(const void * ptr) { emp_assert(HasPtr(ptr)); return ptr_id[ptr]; }
  181|       |
  182|       |    /// Lookup how many pointers are being tracked.
  183|      0|    size_t GetNumIDs() const { return id_info.size(); }
  184|       |
  185|       |    /// How big is an array associated with an ID?
  186|      0|    size_t GetArrayBytes(size_t id) const { return id_info[id].GetArrayBytes(); }
  187|       |
  188|       |    /// Check if an ID is for a pointer that has been deleted.
  189|      0|    bool IsDeleted(size_t id) const {
  190|      0|      if (id == UNTRACKED_ID) return false;   // Not tracked!
  191|      0|      if (internal::ptr_debug) std::cout << "IsDeleted: " << id << std::endl;
  192|      0|      return !id_info[id].IsActive();
  193|      0|    }
  194|       |
  195|       |    /// Is a pointer active and ready to be used?
  196|      0|    bool IsActive(const void * ptr) {
  197|      0|      if (internal::ptr_debug) std::cout << "IsActive: " << ptr << std::endl;
  198|      0|      if (ptr_id.find(ptr) == ptr_id.end()) return false; // Not in database.
  199|      0|      return GetInfo(ptr).IsActive();
  200|      0|    }
  201|       |
  202|       |    /// Is a pointer id associated with a pointer that's active and ready to be used?
  203|      0|    bool IsActiveID(size_t id) {
  204|      0|      if (id == UNTRACKED_ID) return false;
  205|      0|      if (id >= id_info.size()) return false;
  206|      0|      return id_info[id].IsActive();
  207|      0|    }
  208|       |
  209|       |    /// Is an ID associated with an array?
  210|      0|    bool IsArrayID(size_t id) {
  211|      0|      if (internal::ptr_debug) std::cout << "IsArrayID: " << id << std::endl;
  212|      0|      return id_info[id].IsArray();
  213|      0|    }
  214|       |
  215|       |    /// How many Ptr objects are associated with an ID?
  216|      0|    int GetIDCount(size_t id) const {
  217|      0|      if (internal::ptr_debug) std::cout << "Count:  " << id << std::endl;
  218|      0|      return id_info[id].GetCount();
  219|      0|    }
  220|       |
  221|       |    /// This pointer was just created as a Ptr!
  222|      0|    size_t New(const void * ptr) {
  223|      0|      emp_assert(ptr);     // Cannot track a null pointer.
  224|      0|      size_t id = id_info.size();
  225|      0|#ifdef EMP_ABORT_PTR_NEW
  226|      0|      if (id == EMP_ABORT_PTR_NEW) {
  227|      0|        std::cerr << "Aborting at creation of Ptr id " << id << std::endl;
  228|      0|        abort();
  229|      0|      }
  230|      0|#endif
  231|      0|      if (internal::ptr_debug) std::cout << "New:    " << id << " (" << ptr << ")" << std::endl;
  232|      0|      // Make sure pointer is not already stored -OR- hase been deleted (since re-use is possible).
  233|      0|      emp_assert(!HasPtr(ptr) || IsDeleted(GetCurID(ptr)), id);
  234|      0|      id_info.emplace_back(ptr);
  235|      0|      ptr_id[ptr] = id;
  236|      0|      return id;
  237|      0|    }
  238|       |
  239|       |    /// This pointer was just created as a Ptr ARRAY!
  240|      0|    size_t NewArray(const void * ptr, size_t array_bytes) {
  241|      0|      size_t id = New(ptr);  // Build the new pointer.
  242|      0|      if (internal::ptr_debug) std::cout << "  ...Array of size " << array_bytes << std::endl;
  243|      0|      id_info[id].SetArray(array_bytes);
  244|      0|      return id;
  245|      0|    }
  246|       |
  247|       |    /// Increment the nuber of Pointers associated with an ID
  248|      0|    void IncID(size_t id) {
  249|      0|      if (id == UNTRACKED_ID) return;   // Not tracked!
  250|      0|      if (internal::ptr_debug) std::cout << "Inc:    " << id << std::endl;
  251|      0|      id_info[id].Inc(id);
  252|      0|    }
  253|       |
  254|       |    /// Decrement the nuber of Pointers associated with an ID
  255|      0|    void DecID(size_t id) {
  256|      0|      if (id == UNTRACKED_ID) return;   // Not tracked!
  257|      0|      auto & info = id_info[id];
  258|      0|      if (internal::ptr_debug) std::cout << "Dec:    " << id << "(" << info.GetPtr() << ")" << std::endl;
  259|      0|      emp_assert(info.GetCount() > 0, "Decrementing Ptr, but already zero!",
  260|      0|                 id, info.GetPtr(), info.IsActive());
  261|      0|      info.Dec(id);
  262|      0|    }
  263|       |
  264|       |    /// Mark the pointers associated with this ID as deleted.
  265|      0|    void MarkDeleted(size_t id) {
  266|      0|#ifdef EMP_ABORT_PTR_DELETE
  267|      0|      if (id == EMP_ABORT_PTR_DELETE) {
  268|      0|        std::cerr << "Aborting at deletion of Ptr id " << id << std::endl;
  269|      0|        abort();
  270|      0|      }
  271|      0|#endif
  272|      0|      if (internal::ptr_debug) std::cout << "Delete: " << id << std::endl;
  273|      0|      emp_assert(id_info[id].IsActive(), "Deleting same emp::Ptr a second time!", id);
  274|      0|      id_info[id].MarkDeleted();
  275|      0|    }
  276|       |  };
  277|       |
  278|       |
  279|       |//////////////////////////////////
  280|       |//
  281|       |//  --- Ptr implementation ---
  282|       |//
  283|       |//////////////////////////////////
  284|       |
  285|       |#ifdef EMP_TRACK_MEM
  286|       |
  287|       |  namespace {
  288|       |    // @CAO: Build this for real!
  289|       |    /*_FORCE_COVER_START_*/template <typename FROM, typename TO>
  290|       |    bool PtrIsConvertable(FROM * ptr) { return true; }/*_FORCE_COVER_END_*/
  291|       |    // emp_assert( (std::is_same<TYPE,T2>() || dynamic_cast<TYPE*>(in_ptr)) );
  292|       |
  293|       |    // Debug information provided for each pointer type.
  294|       |    struct PtrDebug {
  295|       |      size_t current;
  296|       |      size_t total;
  297|       |      PtrDebug() : current(0), total(0) { ; }
  298|       |      void AddPtr() { current++; total++; }
  299|       |      void RemovePtr() { current--; }
  300|       |    };
  301|       |  }
  302|       |
  303|       |  template <typename TYPE>
  304|       |  class Ptr {
  305|       |  public:
  306|       |    TYPE * ptr;                 ///< The raw pointer associated with this Ptr object.
  307|       |    size_t id;                  ///< A unique ID for this pointer type.
  308|       |    using element_type = TYPE;  ///< Type being pointed at.
  309|       |
  310|       |    static constexpr size_t UNTRACKED_ID = (size_t) -1;
  311|       |
  312|       |    /*_FORCE_COVER_START_*/static PtrDebug & DebugInfo() { static PtrDebug info; return info; }/*_FORCE_COVER_END_*/ // Debug info for each type
  313|       |    /*_FORCE_COVER_START_*/static PtrTracker & Tracker() { return PtrTracker::Get(); }/*_FORCE_COVER_END_*/  // Single tracker for al Ptr types
  314|       |
  315|       |    /// Construct a null Ptr by default.
  316|       |    /*_FORCE_COVER_START_*/Ptr() : ptr(nullptr), id(UNTRACKED_ID) {
  317|       |      if (internal::ptr_debug) std::cout << "null construct: " << ptr << std::endl;
  318|       |    }/*_FORCE_COVER_END_*/
  319|       |
  320|       |    /// Construct using copy constructor
  321|       |    /*_FORCE_COVER_START_*/Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr), id(_in.id) {
  322|       |      if (internal::ptr_debug) std::cout << "copy construct: " << ptr << std::endl;
  323|       |      Tracker().IncID(id);
  324|       |    }/*_FORCE_COVER_END_*/
  325|       |
  326|       |    /// Construct using move constructor
  327|       |    /*_FORCE_COVER_START_*/Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr), id(_in.id) {
  328|       |      if (internal::ptr_debug) std::cout << "move construct: " << ptr << std::endl;
  329|       |      _in.ptr = nullptr;
  330|       |      _in.id = UNTRACKED_ID;
  331|       |      // No IncID or DecID in Tracker since we just move the id.
  332|       |    }/*_FORCE_COVER_END_*/
  333|       |
  334|       |    /// Construct from a raw pointer of campatable type.
  335|       |    /*_FORCE_COVER_START_*/template <typename T2>
  336|       |    /*_FORCE_COVER_START_*/Ptr(T2 * in_ptr, bool track=false) : ptr(in_ptr), id(UNTRACKED_ID)
  337|       |    {
  338|       |      if (internal::ptr_debug) std::cout << "raw construct: " << ptr << ". track=" << track << std::endl;
  339|       |      emp_assert( (PtrIsConvertable<T2, TYPE>(in_ptr)) );
  340|       |
  341|       |      // If this pointer is already active, link to it.
  342|       |      if (Tracker().IsActive(ptr)) {
  343|       |        id = Tracker().GetCurID(ptr);
  344|       |        Tracker().IncID(id);
  345|       |      }
  346|       |      // If we are not already tracking this pointer, but should be, add it.
  347|       |      else if (track) {
  348|       |        id = Tracker().New(ptr);
  349|       |        DebugInfo().AddPtr();
  350|       |      }
  351|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  352|       |
  353|       |    /// Construct from a raw pointer of campatable ARRAY type.
  354|       |    /*_FORCE_COVER_START_*/template <typename T2>
  355|       |    /*_FORCE_COVER_START_*/Ptr(T2 * _ptr, size_t array_size, bool track) : ptr(_ptr), id(UNTRACKED_ID)
  356|       |    {
  357|       |      const size_t array_bytes = array_size * sizeof(T2);
  358|       |      if (internal::ptr_debug) std::cout << "raw ARRAY construct: " << ptr
  359|       |                               << ". size=" << array_size << "(" << array_bytes
  360|       |                               << " bytes); track=" << track << std::endl;
  361|       |      emp_assert( (PtrIsConvertable<T2, TYPE>(_ptr)) );
  362|       |
  363|       |      // If this pointer is already active, link to it.
  364|       |      if (Tracker().IsActive(ptr)) {
  365|       |        id = Tracker().GetCurID(ptr);
  366|       |        Tracker().IncID(id);
  367|       |        emp_assert(Tracker().GetArrayBytes(id) == array_bytes); // Make sure pointer is consistent.
  368|       |      }
  369|       |      // If we are not already tracking this pointer, but should be, add it.
  370|       |      else if (track) {
  371|       |        id = Tracker().NewArray(ptr, array_bytes);
  372|       |        DebugInfo().AddPtr();
  373|       |      }
  374|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  375|       |
  376|       |    /// Construct from another Ptr<> object of compatable type.
  377|       |    /*_FORCE_COVER_START_*/template <typename T2>
  378|       |    /*_FORCE_COVER_START_*/Ptr(Ptr<T2> _in) : ptr(_in.Raw()), id(_in.GetID()) {
  379|       |      if (internal::ptr_debug) std::cout << "inexact copy construct: " << ptr << std::endl;
  380|       |      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), id );
  381|       |      Tracker().IncID(id);
  382|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  383|       |
  384|       |    /// Construct from nullptr.
  385|       |    /*_FORCE_COVER_START_*/Ptr(std::nullptr_t) : Ptr() {
  386|       |      if (internal::ptr_debug) std::cout << "null construct 2." << std::endl;
  387|       |    }/*_FORCE_COVER_END_*/
  388|       |
  389|       |    /// Destructor.
  390|       |    /*_FORCE_COVER_START_*/~Ptr() {
  391|       |      if (internal::ptr_debug) {
  392|       |        std::cout << "destructing Ptr instance ";
  393|       |        if (ptr) std::cout << id << " (" << ptr << ")\n";
  394|       |        else std::cout << "(nullptr)\n";
  395|       |      }
  396|       |      Tracker().DecID(id);
  397|       |    }/*_FORCE_COVER_END_*/
  398|       |
  399|       |    /// Is this Ptr currently nullptr?
  400|       |    /*_FORCE_COVER_START_*/bool IsNull() const { return ptr == nullptr; }/*_FORCE_COVER_END_*/
  401|       |
  402|       |    /// Convert this Ptr to a raw pointer that isn't going to be tracked.
  403|       |    /*_FORCE_COVER_START_*/TYPE * Raw() {
  404|       |      emp_assert(Tracker().IsDeleted(id) == false, "Do not convert deleted Ptr to raw.", id);
  405|       |      return ptr;
  406|       |    }/*_FORCE_COVER_END_*/
  407|       |
  408|       |    /// Convert this Ptr to a const raw pointer that isn't going to be tracked.
  409|       |    /*_FORCE_COVER_START_*/const TYPE * const Raw() const {
  410|       |      emp_assert(Tracker().IsDeleted(id) == false, "Do not convert deleted Ptr to raw.", id);
  411|       |      return ptr;
  412|       |    }/*_FORCE_COVER_END_*/
  413|       |
  414|       |    /// Cast this Ptr to a different type.
  415|       |    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/Ptr<T2> Cast() {
  416|       |      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  417|       |      return (T2*) ptr;
  418|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  419|       |
  420|       |    /// Cast this Ptr to a const Ptr of a different type.
  421|       |    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/const Ptr<const T2> Cast() const {
  422|       |      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  423|       |      return (T2*) ptr;
  424|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  425|       |
  426|       |    /// Dynamically cast this Ptr to another type; throw an assert of the cast fails.
  427|       |    /*_FORCE_COVER_START_*/template <typename T2> /*_FORCE_COVER_START_*/Ptr<T2> DynamicCast() {
  428|       |      emp_assert(dynamic_cast<T2*>(ptr) != nullptr);
  429|       |      emp_assert(Tracker().IsDeleted(id) == false, "Do not cast deleted pointers.", id);
  430|       |      return (T2*) ptr;
  431|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  432|       |
  433|       |    /// Get the unique ID associated with this pointer.
  434|       |    /*_FORCE_COVER_START_*/size_t GetID() const { return id; }/*_FORCE_COVER_END_*/
  435|       |
  436|       |    /// Reallocate this Ptr to a newly allocated value using arguments passed in.
  437|       |    /*_FORCE_COVER_START_*/template <typename... T>
  438|       |    /*_FORCE_COVER_START_*/void New(T &&... args) {
  439|       |      Tracker().DecID(id);                            // Remove a pointer to any old memory...
  440|       |
  441|       |      ptr = new TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  442|       |      // ptr = (TYPE*) malloc (sizeof(TYPE));            // Build a new raw pointer.
  443|       |      // emp_emscripten_assert(ptr);                     // No exceptions in emscripten; assert alloc!
  444|       |      // ptr = new (ptr) TYPE(std::forward<T>(args)...); // Special new that uses allocated space.
  445|       |
  446|       |      if (internal::ptr_debug) std::cout << "Ptr::New() : " << ptr << std::endl;
  447|       |      id = Tracker().New(ptr);                        // And track it!
  448|       |      DebugInfo().AddPtr();
  449|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  450|       |
  451|       |    /// Reallocate this Ptr to a newly allocated array using the size passed in.
  452|       |    /*_FORCE_COVER_START_*/template <typename... T>
  453|       |    /*_FORCE_COVER_START_*/void NewArray(size_t array_size, T &&... args) {
  454|       |      Tracker().DecID(id);                              // Remove a pointer to any old memory...
  455|       |
  456|       |      // @CAO: This next portion of code is allocating an array of the appropriate type.
  457|       |      //       We are currently using "new", but should shift over to malloc since new throws an
  458|       |      //       exception when there's a problem, which will trigger an abort in Emscripten mode.
  459|       |      //       We'd rather be able to identify a more specific problem.
  460|       |      ptr = new TYPE[array_size];                     // Build a new raw pointer to an array.
  461|       |      // ptr = (TYPE*) malloc (array_size * sizeof(TYPE)); // Build a new raw pointer.
  462|       |      // emp_emscripten_assert(ptr, array_size);           // No exceptions in emscripten; assert alloc!
  463|       |      // for (size_t i = 0; i < array_size; i++) {
  464|       |      //   new (ptr + i*sizeof(TYPE)) TYPE(args...);
  465|       |      // }
  466|       |
  467|       |      if (internal::ptr_debug) std::cout << "Ptr::NewArray() : " << ptr << std::endl;
  468|       |      id = Tracker().NewArray(ptr, array_size * sizeof(TYPE));   // And track it!
  469|       |      DebugInfo().AddPtr();
  470|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  471|       |
  472|       |    /// Delete this pointer (must NOT be an array).
  473|       |    /*_FORCE_COVER_START_*/void Delete() {
  474|       |      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  475|       |      emp_assert(ptr, "Deleting null Ptr.");
  476|       |      emp_assert(Tracker().IsArrayID(id) == false, id, "Trying to delete array pointer as non-array.");
  477|       |      if (internal::ptr_debug) std::cout << "Ptr::Delete() : " << ptr << std::endl;
  478|       |      delete ptr;
  479|       |      Tracker().MarkDeleted(id);
  480|       |      DebugInfo().RemovePtr();
  481|       |    }/*_FORCE_COVER_END_*/
  482|       |
  483|       |    /// Delete this pointer to an array (must be an array).
  484|       |    /*_FORCE_COVER_START_*/void DeleteArray() {
  485|       |      emp_assert(id < Tracker().GetNumIDs(), id, "Deleting Ptr that we are not resposible for.");
  486|       |      emp_assert(ptr, "Deleting null Ptr.");
  487|       |      emp_assert(Tracker().IsArrayID(id), id, "Trying to delete non-array pointer as array.");
  488|       |      if (internal::ptr_debug) std::cout << "Ptr::DeleteArray() : " << ptr << std::endl;
  489|       |      delete [] ptr;
  490|       |      Tracker().MarkDeleted(id);
  491|       |      DebugInfo().RemovePtr();
  492|       |    }/*_FORCE_COVER_END_*/
  493|       |
  494|       |    /// Convert this pointer to a hash value.
  495|       |    /*_FORCE_COVER_START_*/size_t Hash() const {
  496|       |      // Chop off useless bits of pointer...
  497|       |      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));
  498|       |      return (size_t)(ptr) >> shift;
  499|       |    }/*_FORCE_COVER_END_*/
  500|       |    struct hash_t { /*_FORCE_COVER_START_*/size_t operator()(const Ptr<TYPE> & t) const { return t.Hash(); }/*_FORCE_COVER_END_*/ };
  501|       |
  502|       |    /// Copy assignment
  503|       |    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) {
  504|       |      if (internal::ptr_debug) std::cout << "copy assignment" << std::endl;
  505|       |      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not copy deleted pointers.");
  506|       |      if (id != _in.id) {        // Assignments only need to happen if ptrs are different.
  507|       |        Tracker().DecID(id);
  508|       |        ptr = _in.ptr;
  509|       |        id = _in.id;
  510|       |        Tracker().IncID(id);
  511|       |      }
  512|       |      return *this;
  513|       |    }/*_FORCE_COVER_END_*/
  514|       |
  515|       |    /// Move assignment
  516|       |    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(Ptr<TYPE> && _in) {
  517|       |      if (internal::ptr_debug) std::cout << "move assignment: " << _in.ptr << std::endl;
  518|       |      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not move deleted pointers.");
  519|       |      if (ptr != _in.ptr) {
  520|       |        Tracker().DecID(id);   // Decrement references to former pointer at this position.
  521|       |        ptr = _in.ptr;
  522|       |        id = _in.id;
  523|       |        _in.ptr = nullptr;
  524|       |        _in.id = UNTRACKED_ID;
  525|       |      }
  526|       |      return *this;
  527|       |    }/*_FORCE_COVER_END_*/
  528|       |
  529|       |    /// Assign to a raw pointer of the correct type; if this is already tracked, hooked in
  530|       |    /// correctly, otherwise don't track.
  531|       |    /*_FORCE_COVER_START_*/template <typename T2>
  532|       |    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(T2 * _in) {
  533|       |      if (internal::ptr_debug) std::cout << "raw assignment" << std::endl;
  534|       |      emp_assert( (PtrIsConvertable<T2, TYPE>(_in)) );
  535|       |
  536|       |      Tracker().DecID(id);    // Decrement references to former pointer at this position.
  537|       |      ptr = _in;              // Update to new pointer.
  538|       |
  539|       |      // If this pointer is already active, link to it.
  540|       |      if (Tracker().IsActive(ptr)) {
  541|       |        id = Tracker().GetCurID(ptr);
  542|       |        Tracker().IncID(id);
  543|       |      }
  544|       |      // Otherwise, since this ptr was passed in as a raw pointer, we do not manage it.
  545|       |      else {
  546|       |        id = UNTRACKED_ID;
  547|       |      }
  548|       |
  549|       |      return *this;
  550|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  551|       |
  552|       |    /// Assign to a convertable Ptr
  553|       |    /*_FORCE_COVER_START_*/template <typename T2>
  554|       |    /*_FORCE_COVER_START_*/Ptr<TYPE> & operator=(Ptr<T2> _in) {
  555|       |      if (internal::ptr_debug) std::cout << "convert-copy assignment" << std::endl;
  556|       |      emp_assert( (PtrIsConvertable<T2, TYPE>(_in.Raw())), _in.id );
  557|       |      emp_assert(Tracker().IsDeleted(_in.id) == false, _in.id, "Do not copy deleted pointers.");
  558|       |      Tracker().DecID(id);
  559|       |      ptr = _in.Raw();
  560|       |      id = _in.GetID();
  561|       |      Tracker().IncID(id);
  562|       |      return *this;
  563|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  564|       |
  565|       |    /// Dereference a pointer.
  566|       |    /*_FORCE_COVER_START_*/TYPE & operator*() {
  567|       |      // Make sure a pointer is active and non-null before we dereference it.
  568|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  569|       |      emp_assert(ptr != nullptr, "Do not dereference a null pointer!");
  570|       |      return *ptr;
  571|       |    }/*_FORCE_COVER_END_*/
  572|       |
  573|       |    /// Dereference a pointer to a const type.
  574|       |    /*_FORCE_COVER_START_*/const TYPE & operator*() const {
  575|       |      // Make sure a pointer is active before we dereference it.
  576|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  577|       |      emp_assert(ptr != nullptr, "Do not dereference a null pointer!");
  578|       |      return *ptr;
  579|       |    }/*_FORCE_COVER_END_*/
  580|       |
  581|       |    /// Follow a pointer.
  582|       |    /*_FORCE_COVER_START_*/TYPE * operator->() {
  583|       |      // Make sure a pointer is active before we follow it.
  584|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  585|       |      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  586|       |      return ptr;
  587|       |    }/*_FORCE_COVER_END_*/
  588|       |
  589|       |    /// Follow a pointer to a const target.
  590|       |    /*_FORCE_COVER_START_*/TYPE * const operator->() const {
  591|       |      // Make sure a pointer is active before we follow it.
  592|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  593|       |      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  594|       |      return ptr;
  595|       |    }/*_FORCE_COVER_END_*/
  596|       |
  597|       |    /// Indexing into array
  598|       |    /*_FORCE_COVER_START_*/TYPE & operator[](size_t pos) {
  599|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  600|       |      emp_assert(Tracker().IsArrayID(id), "Only arrays can be indexed into.", id);
  601|       |      emp_assert(Tracker().GetArrayBytes(id) > (pos*sizeof(TYPE)),
  602|       |        "Indexing out of range.", id, ptr, pos, sizeof(TYPE), Tracker().GetArrayBytes(id));
  603|       |      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  604|       |      return ptr[pos];
  605|       |    }/*_FORCE_COVER_END_*/
  606|       |
  607|       |    /// Indexing into const array
  608|       |    /*_FORCE_COVER_START_*/const TYPE & operator[](size_t pos) const {
  609|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  610|       |      emp_assert(Tracker().IsArrayID(id), "Only arrays can be indexed into.", id);
  611|       |      emp_assert(Tracker().GetArrayBytes(id) > (pos*sizeof(TYPE)),
  612|       |        "Indexing out of range.", id, ptr, pos, sizeof(TYPE), Tracker().GetArrayBytes(id));
  613|       |      emp_assert(ptr != nullptr, "Do not follow a null pointer!");
  614|       |      return ptr[pos];
  615|       |    }/*_FORCE_COVER_END_*/
  616|       |
  617|       |    /// Auto-case to raw pointer type.
  618|       |    /*_FORCE_COVER_START_*/operator TYPE *() {
  619|       |      // Make sure a pointer is active before we convert it.
  620|       |      emp_assert(Tracker().IsDeleted(id) == false /*, typeid(TYPE).name() */, id);
  621|       |
  622|       |      // We should not automatically convert managed pointers to raw pointers; use .Raw()
  623|       |      emp_assert(id == UNTRACKED_ID /*, typeid(TYPE).name() */, id);
  624|       |      return ptr;
  625|       |    }/*_FORCE_COVER_END_*/
  626|       |
  627|       |    /// Does this pointer exist?
  628|       |    /*_FORCE_COVER_START_*/operator bool() { return ptr != nullptr; }/*_FORCE_COVER_END_*/
  629|       |
  630|       |    /// Does this const pointer exist?
  631|       |    /*_FORCE_COVER_START_*/operator bool() const { return ptr != nullptr; }/*_FORCE_COVER_END_*/
  632|       |
  633|       |    /// Does this Ptr point to the same memory position?
  634|       |    /*_FORCE_COVER_START_*/bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }/*_FORCE_COVER_END_*/
  635|       |
  636|       |    /// Does this Ptr point to different memory positions?
  637|       |    /*_FORCE_COVER_START_*/bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }/*_FORCE_COVER_END_*/
  638|       |
  639|       |    /// Does this Ptr point to a memory position before another?
  640|       |    /*_FORCE_COVER_START_*/bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }/*_FORCE_COVER_END_*/
  641|       |
  642|       |    /// Does this Ptr point to a memory position before or equal to another?
  643|       |    /*_FORCE_COVER_START_*/bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }/*_FORCE_COVER_END_*/
  644|       |
  645|       |    /// Does this Ptr point to a memory position after another?
  646|       |    /*_FORCE_COVER_START_*/bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }/*_FORCE_COVER_END_*/
  647|       |
  648|       |    /// Does this Ptr point to a memory position after or equal to another?
  649|       |    /*_FORCE_COVER_START_*/bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }/*_FORCE_COVER_END_*/
  650|       |
  651|       |
  652|       |    /// Does this Ptr point to the same memory position as a raw pointer?
  653|       |    /*_FORCE_COVER_START_*/bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }/*_FORCE_COVER_END_*/
  654|       |
  655|       |    /// Does this Ptr point to different memory positions as a raw pointer?
  656|       |    /*_FORCE_COVER_START_*/bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }/*_FORCE_COVER_END_*/
  657|       |
  658|       |    /// Does this Ptr point to a memory position before a raw pointer?
  659|       |    /*_FORCE_COVER_START_*/bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }/*_FORCE_COVER_END_*/
  660|       |
  661|       |    /// Does this Ptr point to a memory position before or equal to a raw pointer?
  662|       |    /*_FORCE_COVER_START_*/bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }/*_FORCE_COVER_END_*/
  663|       |
  664|       |    /// Does this Ptr point to a memory position after a raw pointer?
  665|       |    /*_FORCE_COVER_START_*/bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }/*_FORCE_COVER_END_*/
  666|       |
  667|       |    /// Does this Ptr point to a memory position after or equal to a raw pointer?
  668|       |    /*_FORCE_COVER_START_*/bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }/*_FORCE_COVER_END_*/
  669|       |
  670|       |
  671|       |    /// Some debug testing functions
  672|       |    /*_FORCE_COVER_START_*/int DebugGetCount() const { return Tracker().GetIDCount(id); }/*_FORCE_COVER_END_*/
  673|       |    /*_FORCE_COVER_START_*/bool DebugIsArray() const { return Tracker().IsArrayID(id); }/*_FORCE_COVER_END_*/
  674|       |    /*_FORCE_COVER_START_*/size_t DebugGetArrayBytes() const { return Tracker().GetArrayBytes(id); }/*_FORCE_COVER_END_*/
  675|       |    /*_FORCE_COVER_START_*/bool DebugIsActive() const { return Tracker().IsActiveID(id); }/*_FORCE_COVER_END_*/
  676|       |
  677|       |    /*_FORCE_COVER_START_*/bool OK() const {
  678|       |      // Untracked ID's should not have pointers in the Tracker.
  679|       |      if (id == UNTRACKED_ID) return !Tracker().HasPtr(ptr);
  680|       |
  681|       |      // Make sure this pointer is linked to the correct info.
  682|       |      if (Tracker().GetInfo(id).GetPtr() != ptr) return false;
  683|       |
  684|       |      // And make sure that info itself is okay.
  685|       |      return Tracker().GetInfo(id).OK();
  686|       |    }/*_FORCE_COVER_END_*/
  687|       |
  688|       |    // Prevent use of new and delete on Ptr
  689|       |    // static void* operator new(std::size_t) noexcept {
  690|       |    //   emp_assert(false, "No Ptr::operator new; use emp::NewPtr for clarity.");
  691|       |    //   return nullptr;
  692|       |    // }
  693|       |    // static void* operator new[](std::size_t sz) noexcept {
  694|       |    //   emp_assert(false, "No Ptr::operator new[]; use emp::NewPtrArray for clarity.");
  695|       |    //   return nullptr;
  696|       |    // }
  697|       |    //
  698|       |    // static void operator delete(void* ptr, std::size_t sz) {
  699|       |    //   emp_assert(false, "No Ptr::operator delete; use Delete() member function for clarity.");
  700|       |    // }
  701|       |    // static void operator delete[](void* ptr, std::size_t sz) {
  702|       |    //   emp_assert(false, "No Ptr::operator delete[]; use DeleteArray() member function for clarity.");
  703|       |    // }
  704|       |
  705|       |  };
  706|       |
  707|       |#else
  708|       |
  709|       |
  710|       |  template <typename TYPE>
  711|       |  class Ptr {
  712|       |  private:
  713|       |    TYPE * ptr;
  714|       |
  715|       |  public:
  716|       |    using element_type = TYPE;
  717|       |
  718|    566|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  | _ZN3emp3PtrImEC2Ev:
  |  718|    164|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  | Unexecuted instantiation: _ZN3emp3PtrINS_5RegEx9re_parentEEC2Ev
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEC2Ev:
  |  718|    215|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2Ev:
  |  718|     70|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEC2Ev:
  |  718|     80|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEC2Ev:
  |  718|     37|    Ptr() : ptr(nullptr) {}                                              ///< Default constructor
  ------------------
  719|    495|    Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr) {}                         ///< Copy constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2ERKS3_:
  |  719|    413|    Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr) {}                         ///< Copy constructor
  ------------------
  | _ZN3emp3PtrImEC2ERKS1_:
  |  719|     80|    Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr) {}                         ///< Copy constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEC2ERKS3_:
  |  719|      2|    Ptr(const Ptr<TYPE> & _in) : ptr(_in.ptr) {}                         ///< Copy constructor
  ------------------
  720|  1.22k|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrImEC2EOS1_:
  |  720|     82|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_parentEEC2EOS3_:
  |  720|     24|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEC2EOS3_:
  |  720|    246|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEC2EOS3_:
  |  720|    189|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2EOS3_:
  |  720|    253|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_orEEC2EOS3_:
  |  720|      8|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_starEEC2EOS3_:
  |  720|     20|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_plusEEC2EOS3_:
  |  720|     42|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_qmEEC2EOS3_:
  |  720|      2|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEC2EOS3_:
  |  720|    359|    Ptr(Ptr<TYPE> && _in) : ptr(_in.ptr) {}                              ///< Move constructor
  ------------------
  721|    225|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_parentEEC2IS2_EEPT_b:
  |  721|     12|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEC2IS2_EEPT_b:
  |  721|     52|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEC2IS2_EEPT_b:
  |  721|     49|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEC2IS2_EEPT_b:
  |  721|     76|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_orEEC2IS2_EEPT_b:
  |  721|      4|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_starEEC2IS2_EEPT_b:
  |  721|     10|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_plusEEC2IS2_EEPT_b:
  |  721|     21|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_qmEEC2IS2_EEPT_b:
  |  721|      1|    template <typename T2> Ptr(T2 * in_ptr, bool=false) : ptr(in_ptr) {} ///< Construct from raw ptr
  ------------------
  722|     82|    template <typename T2> Ptr(T2 * _ptr, size_t, bool) : ptr(_ptr) {}   ///< Construct from array
  723|     40|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2INS1_8re_blockEEENS0_IT_EE:
  |  723|      4|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2INS1_5re_orEEENS0_IT_EE:
  |  723|      4|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2INS1_7re_starEEENS0_IT_EE:
  |  723|     10|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2INS1_7re_plusEEENS0_IT_EE:
  |  723|     21|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEC2INS1_5re_qmEEENS0_IT_EE:
  |  723|      1|    template <typename T2> Ptr(Ptr<T2> _in) : ptr(_in.Raw()) {}          ///< From compatible Ptr
  ------------------
  724|    496|    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  ------------------
  | _ZN3emp3PtrImEC2EDn:
  |  724|    164|    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  ------------------
  | Unexecuted instantiation: _ZN3emp3PtrINS_5RegEx9re_parentEEC2EDn
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEC2EDn:
  |  724|    215|    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEC2EDn:
  |  724|     80|    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEC2EDn:
  |  724|     37|    Ptr(std::nullptr_t) : Ptr() {}                                       ///< From nullptr
  ------------------
  725|  2.63k|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEED2Ev:
  |  725|    776|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrImED2Ev:
  |  725|    408|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_parentEED2Ev:
  |  725|     36|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEED2Ev:
  |  725|    375|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEED2Ev:
  |  725|    304|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_orEED2Ev:
  |  725|     12|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_starEED2Ev:
  |  725|     30|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_plusEED2Ev:
  |  725|     63|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_qmEED2Ev:
  |  725|      3|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEED2Ev:
  |  725|    626|    ~Ptr() { ; }                                                         ///< Destructor
  ------------------
  726|       |
  727|       |    bool IsNull() const { return ptr == nullptr; }
  728|    112|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEE3RawEv:
  |  728|     37|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEE3RawEv:
  |  728|     10|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEE3RawEv:
  |  728|     29|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_orEE3RawEv:
  |  728|      4|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_starEE3RawEv:
  |  728|     10|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_plusEE3RawEv:
  |  728|     21|    TYPE * Raw() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx5re_qmEE3RawEv:
  |  728|      1|    TYPE * Raw() { return ptr; }
  ------------------
  729|       |    const TYPE * const Raw() const { return ptr; }
  730|      0|    template <typename T2> Ptr<T2> Cast() { return (T2*) ptr; }
  731|      0|    template <typename T2> const Ptr<const T2> Cast() const { return (T2*) ptr; }
  ------------------
  | Unexecuted instantiation: _ZNK3emp3PtrImE4CastImEEKNS0_IKT_EEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp3PtrImE4CastIjEEKNS0_IKT_EEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp3PtrImE4CastIKjEEKNS0_IKT_EEv
  ------------------
  732|       |    template <typename T2> Ptr<T2> DynamicCast() { return dynamic_cast<T2*>(ptr); }
  733|       |
  734|       |    template <typename... T>
  735|       |    void New(T &&... args) { ptr = new TYPE(std::forward<T>(args)...); }  // New raw pointer.
  736|       |    void NewArray(size_t array_size) { ptr = new TYPE[array_size]; }
  737|    112|    void Delete() { delete ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEE6DeleteEv:
  |  737|    110|    void Delete() { delete ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEE6DeleteEv:
  |  737|      2|    void Delete() { delete ptr; }
  ------------------
  738|     82|    void DeleteArray() { delete [] ptr; }
  739|       |
  740|       |    size_t Hash() const {
  741|       |      static constexpr size_t shift = internal::Log2(1 + sizeof(TYPE));  // Chop off useless bits...
  742|       |      return (size_t)(ptr) >> shift;
  743|       |    }
  744|       |    struct hash_t { size_t operator()(const Ptr<TYPE> & t) const { return t.Hash(); } };
  745|       |
  746|       |    // Copy/Move assignments
  747|      7|    Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) { ptr = _in.ptr; return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEaSERKS3_:
  |  747|      7|    Ptr<TYPE> & operator=(const Ptr<TYPE> & _in) { ptr = _in.ptr; return *this; }
  ------------------
  | Unexecuted instantiation: _ZN3emp3PtrImEaSERKS1_
  ------------------
  748|    185|    Ptr<TYPE> & operator=(Ptr<TYPE> && _in) { ptr = _in.ptr; _in.ptr = nullptr; return *this; }
  ------------------
  | _ZN3emp3PtrImEaSEOS1_:
  |  748|    164|    Ptr<TYPE> & operator=(Ptr<TYPE> && _in) { ptr = _in.ptr; _in.ptr = nullptr; return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEaSEOS3_:
  |  748|     10|    Ptr<TYPE> & operator=(Ptr<TYPE> && _in) { ptr = _in.ptr; _in.ptr = nullptr; return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEaSEOS3_:
  |  748|     11|    Ptr<TYPE> & operator=(Ptr<TYPE> && _in) { ptr = _in.ptr; _in.ptr = nullptr; return *this; }
  ------------------
  749|       |
  750|       |    // Assign to compatible Ptr or raw (non-managed) pointer.
  751|       |    template <typename T2> Ptr<TYPE> & operator=(T2 * _in) { ptr = _in; return *this; }
  752|     72|    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEaSINS1_10re_charsetEEERS3_NS0_IT_EE:
  |  752|     37|    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEaSINS1_8re_blockEEERS3_NS0_IT_EE:
  |  752|      6|    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEaSINS1_9re_stringEEERS3_NS0_IT_EE:
  |  752|     29|    template <typename T2> Ptr<TYPE> & operator=(Ptr<T2> _in) { ptr = _in.Raw(); return *this; }
  ------------------
  753|       |
  754|       |    // Dereference a pointer.
  755|       |    TYPE & operator*() { return *ptr; }
  756|       |    const TYPE & operator*() const { return *ptr; }
  757|       |
  758|       |    // Follow a pointer.
  759|  1.29k|    TYPE * operator->() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx7re_baseEEptEv:
  |  759|    597|    TYPE * operator->() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_parentEEptEv:
  |  759|     12|    TYPE * operator->() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEptEv:
  |  759|    148|    TYPE * operator->() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEptEv:
  |  759|    519|    TYPE * operator->() { return ptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEptEv:
  |  759|     16|    TYPE * operator->() { return ptr; }
  ------------------
  760|     28|    TYPE * const operator->() const { return ptr; }
  761|       |
  762|       |    // Indexing into array
  763|    150|    TYPE & operator[](size_t pos) { return ptr[pos]; }
  ------------------
  | _ZN3emp3PtrImEixEm:
  |  763|    150|    TYPE & operator[](size_t pos) { return ptr[pos]; }
  ------------------
  | Unexecuted instantiation: _ZN3emp3PtrIjEixEm
  ------------------
  | Unexecuted instantiation: _ZN3emp3PtrIKjEixEm
  ------------------
  764|     80|    const TYPE & operator[](size_t pos) const { return ptr[pos]; }
  ------------------
  | _ZNK3emp3PtrImEixEm:
  |  764|     80|    const TYPE & operator[](size_t pos) const { return ptr[pos]; }
  ------------------
  | Unexecuted instantiation: _ZNK3emp3PtrIKmEixEm
  ------------------
  | Unexecuted instantiation: _ZNK3emp3PtrIKjEixEm
  ------------------
  765|       |
  766|       |    // Auto-case to raw pointer type.
  767|       |    operator TYPE *() { return ptr; }
  768|       |
  769|    457|    operator bool() { return ptr != nullptr; }
  ------------------
  | _ZN3emp3PtrImEcvbEv:
  |  769|     82|    operator bool() { return ptr != nullptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx8re_blockEEcvbEv:
  |  769|    217|    operator bool() { return ptr != nullptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx10re_charsetEEcvbEv:
  |  769|     90|    operator bool() { return ptr != nullptr; }
  ------------------
  | _ZN3emp3PtrINS_5RegEx9re_stringEEcvbEv:
  |  769|     68|    operator bool() { return ptr != nullptr; }
  ------------------
  770|       |    operator bool() const { return ptr != nullptr; }
  771|       |
  772|       |    // Comparisons to other Ptr objects
  773|       |    bool operator==(const Ptr<TYPE> & in_ptr) const { return ptr == in_ptr.ptr; }
  774|       |    bool operator!=(const Ptr<TYPE> & in_ptr) const { return ptr != in_ptr.ptr; }
  775|       |    bool operator<(const Ptr<TYPE> & in_ptr)  const { return ptr < in_ptr.ptr; }
  776|       |    bool operator<=(const Ptr<TYPE> & in_ptr) const { return ptr <= in_ptr.ptr; }
  777|       |    bool operator>(const Ptr<TYPE> & in_ptr)  const { return ptr > in_ptr.ptr; }
  778|       |    bool operator>=(const Ptr<TYPE> & in_ptr) const { return ptr >= in_ptr.ptr; }
  779|       |
  780|       |    // Comparisons to raw pointers.
  781|     38|    bool operator==(const TYPE * in_ptr) const { return ptr == in_ptr; }
  782|    216|    bool operator!=(const TYPE * in_ptr) const { return ptr != in_ptr; }
  783|       |    bool operator<(const TYPE * in_ptr)  const { return ptr < in_ptr; }
  784|       |    bool operator<=(const TYPE * in_ptr) const { return ptr <= in_ptr; }
  785|       |    bool operator>(const TYPE * in_ptr)  const { return ptr > in_ptr; }
  786|       |    bool operator>=(const TYPE * in_ptr) const { return ptr >= in_ptr; }
  787|       |
  788|       |    // Stubs for debug-related functions when outside debug mode.
  789|       |    int DebugGetCount() const { return -1; }
  790|       |    bool DebugIsArray() const { emp_assert(false); return false; }
  791|       |    size_t DebugGetArrayBytes() const { return 0; }
  792|       |    bool DebugIsActive() const { return true; }
  793|       |    bool OK() const { return true; }
  794|       |  };
  795|       |
  796|       |#endif
  797|       |
  798|       |  // IO
  799|       |  /*_FORCE_COVER_START_*/template <typename T>
  800|       |  std::ostream & operator<<(std::ostream & out, const emp::Ptr<T> & ptr) {
  801|       |    out << ptr.Raw();
  802|       |    return out;
  803|       |  }/*_FORCE_COVER_END_*/
  804|       |
  805|       |  // @CAO: Reading a pointer from a stream seems like a terrible idea in most situations, but I
  806|       |  // can imagine limited circumstances where it would be needed.
  807|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  808|       |  std::istream & operator>>(std::istream & is, emp::Ptr<T> & ptr) {
  809|       |    T * val;
  810|       |    is >> val;
  811|       |    ptr = val;
  812|       |    return is;
  813|       |  }/*_FORCE_COVER_END_*/
  814|       |
  815|       |  /// Convert a T* to a Ptr<T>.  By default, don't track.
  816|    113|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5ToPtrINS_5RegEx9re_parentEEENS_3PtrIT_EEPS4_b:
  |  816|     12|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5ToPtrINS_5RegEx10re_charsetEEENS_3PtrIT_EEPS4_b:
  |  816|     12|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5ToPtrINS_5RegEx9re_stringEEENS_3PtrIT_EEPS4_b:
  |  816|     47|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5ToPtrINS_5RegEx8re_blockEEENS_3PtrIT_EEPS4_b:
  |  816|     42|  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> ToPtr(T * _in, bool own=false) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  ------------------
  817|       |
  818|       |  /// Convert a T* to a Ptr<T> that we DO track.
  819|       |  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> TrackPtr(T * _in, bool own=true) { return Ptr<T>(_in, own); }/*_FORCE_COVER_END_*/
  820|       |
  821|       |  /// Create a new Ptr of the target type; use the args in the constructor.
  822|    112|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  823|    112|    auto ptr = new T(std::forward<ARGS>(args)...);
  824|    112|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  825|    112|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  826|    112|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  827|    112|    return Ptr<T>(ptr, true);
  828|    112|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx8re_blockEJEEENS_3PtrIT_EEDpOT0_:
  |  822|     10|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|     10|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|     10|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|     10|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|     10|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|     10|    return Ptr<T>(ptr, true);
  |  828|     10|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx10re_charsetEJcbEEENS_3PtrIT_EEDpOT0_:
  |  822|      3|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|      3|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|      3|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|      3|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|      3|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|      3|    return Ptr<T>(ptr, true);
  |  828|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx10re_charsetEJEEENS_3PtrIT_EEDpOT0_:
  |  822|     34|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|     34|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|     34|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|     34|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|     34|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|     34|    return Ptr<T>(ptr, true);
  |  828|     34|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6NewPtrINS_5RegEx9re_stringEJEEENS_3PtrIT_EEDpOT0_
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx9re_stringEJRcEEENS_3PtrIT_EEDpOT0_:
  |  822|     27|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|     27|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|     27|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|     27|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|     27|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|     27|    return Ptr<T>(ptr, true);
  |  828|     27|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx5re_orEJNS_3PtrINS1_7re_baseEEENS3_INS1_8re_blockEEEEEENS3_IT_EEDpOT0_:
  |  822|      4|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|      4|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|      4|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|      4|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|      4|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|      4|    return Ptr<T>(ptr, true);
  |  828|      4|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx7re_starEJNS_3PtrINS1_7re_baseEEEEEENS3_IT_EEDpOT0_:
  |  822|     10|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|     10|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|     10|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|     10|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|     10|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|     10|    return Ptr<T>(ptr, true);
  |  828|     10|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx7re_plusEJNS_3PtrINS1_7re_baseEEEEEENS3_IT_EEDpOT0_:
  |  822|     21|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|     21|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|     21|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|     21|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|     21|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|     21|    return Ptr<T>(ptr, true);
  |  828|     21|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx5re_qmEJNS_3PtrINS1_7re_baseEEEEEENS3_IT_EEDpOT0_:
  |  822|      1|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|      1|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|      1|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|      1|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|      1|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|      1|    return Ptr<T>(ptr, true);
  |  828|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6NewPtrINS_5RegEx9re_stringEJcEEENS_3PtrIT_EEDpOT0_:
  |  822|      2|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewPtr(ARGS &&... args) {
  |  823|      2|    auto ptr = new T(std::forward<ARGS>(args)...);
  |  824|      2|    // auto ptr = (T*) malloc (sizeof(T));         // Build a new raw pointer.
  |  825|      2|    // emp_assert(ptr);                            // No exceptions in emscripten; assert alloc!
  |  826|      2|    // new (ptr) T(std::forward<ARGS>(args)...);   // Special new that uses allocated space.
  |  827|      2|    return Ptr<T>(ptr, true);
  |  828|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  829|       |
  830|       |  /// Copy an object pointed to and return a Ptr to the copy.
  831|       |  /*_FORCE_COVER_START_*/template <typename T> Ptr<T> CopyPtr(Ptr<T> in) { return NewPtr<T>(*in); }/*_FORCE_COVER_END_*/
  832|       |
  833|       |  /// Copy a vector of objects pointed to; return a vector of Ptrs to the new copies.
  834|       |  /*_FORCE_COVER_START_*/template <typename T> emp::vector<Ptr<T>> CopyPtrs(const emp::vector<Ptr<T>> & in) {
  835|       |    emp::vector<Ptr<T>> out_ptrs(in.size());
  836|       |    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = CopyPtr(in[i]);
  837|       |    return out_ptrs;
  838|       |  }/*_FORCE_COVER_END_*/
  839|       |
  840|       |  /// Copy a vector of objects pointed to by using their Clone() member function; return vector.
  841|       |  /*_FORCE_COVER_START_*/template <typename T> emp::vector<Ptr<T>> ClonePtrs(const emp::vector<Ptr<T>> & in) {
  842|       |    emp::vector<Ptr<T>> out_ptrs(in.size());
  843|       |    for (size_t i = 0; i < in.size(); i++) out_ptrs[i] = in[i]->Clone();
  844|       |    return out_ptrs;
  845|       |  }/*_FORCE_COVER_END_*/
  846|       |
  847|       |  /// Create a pointer to an array of objects.
  848|     82|  /*_FORCE_COVER_START_*/template <typename T, typename... ARGS> Ptr<T> NewArrayPtr(size_t array_size, ARGS &&... args) {
  849|     82|    auto ptr = new T[array_size];                     // Build a new raw pointer.
  850|     82|    // const size_t alloc_size = array_size * sizeof(T);
  851|     82|    // auto ptr = (T*) malloc (alloc_size);
  852|     82|    emp_assert(ptr, array_size);                      // No exceptions in emscripten; assert alloc!
  853|     82|    // for (size_t i = 0; i < array_size; i++) {         // Loop through all array elements.
  854|     82|    //   new (ptr + i*sizeof(T)) T(args...);             //    ...and initialize them.
  855|     82|    // }
  856|     82|    return Ptr<T>(ptr, array_size, true);
  857|     82|  }/*_FORCE_COVER_END_*/
  858|       |
  859|       |
  860|       |}
  861|       |
  862|       |#endif // EMP_PTR_H
  863|       |

/home/emily/repos/Empirical_Tests/source/base/array.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file array.h
    7|       | *  @brief A drop-in wrapper for std::array; adds on bounds checking in debug mode.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  If EMP_NDEBUG is set, emp::array is just an alias for std::array.
   11|       | *  Otherwise, every time an array is accessed, tests are done to make sure that the
   12|       | *  access is legal.
   13|       | *
   14|       | *  @todo Add tests in array::front and array::back to ensure not empty.
   15|       | *  @todo Add tests for get.
   16|       | */
   17|       |
   18|       |
   19|       |#ifndef EMP_ARRAY_H
   20|       |#define EMP_ARRAY_H
   21|       |
   22|       |#include <initializer_list>
   23|       |#include <array>
   24|       |
   25|       |#include "assert.h"
   26|       |#include "../meta/TypeID.h"
   27|       |
   28|       |#ifdef EMP_NDEBUG
   29|       |
   30|       |namespace emp {
   31|       |  /// In release mode, emp::array is simply an alias for std::array.
   32|       |  template <typename T, size_t N> using array = std::array<T,N>;
   33|       |}
   34|       |
   35|       |#else
   36|       |
   37|       |namespace emp {
   38|       |
   39|       |  /// We are in debug mode, so emp::array has the same interface as std::array, but with extra
   40|       |  /// bounds checking.  Using vector as our base since it has the right pieces and is dyanmic.
   41|       |  template <typename T, size_t N>
   42|       |  class array : public std::vector<T> {
   43|       |  private:
   44|       |    using this_t = emp::array<T,N>;
   45|       |    using base_t = std::vector<T>;
   46|       |
   47|       |  public:
   48|       |    bool valid;
   49|       |
   50|       |    /// Setup an iterator wrapper to make sure that they're valid.
   51|       |    template<typename ITERATOR_T>
   52|       |    struct iterator_wrapper : public ITERATOR_T {
   53|       |      using this_t = iterator_wrapper<ITERATOR_T>;
   54|       |      using wrapped_t = ITERATOR_T;
   55|       |      using vec_t = emp::array<T,N>;
   56|       |
   57|       |      /// What vector was this iterator created from?
   58|       |      const vec_t * v_ptr;
   59|       |
   60|      0|      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v) : ITERATOR_T(_in), v_ptr(_v) { ; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEC2ERKS9_PKS1_
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEEC2ERKSA_PKS1_
  ------------------
   61|       |      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/iterator_wrapper(const this_t &) = default/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
   62|       |      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/iterator_wrapper(this_t &&) = default/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
   63|      0|      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEED2Ev
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEED2Ev
  ------------------
   64|       |
   65|       |      // Debug tools to make sure this iterator is okay.
   66|       |      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
   67|       |        if (v_ptr == nullptr) return false;                // Invalid vector
   68|       |        if (!v_ptr->valid) return false;                   // Vector has been deleted!
   69|       |        size_t pos = (size_t) (*this - v_ptr->begin());
   70|       |        if (pos > v_ptr->size()) return false;             // Iterator out of range.
   71|       |        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
   72|       |        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
   73|       |        return true;
   74|       |      }/*_FORCE_COVER_END_*/
   75|       |
   76|       |      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
   77|       |      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/this_t & operator=(this_t &&) = default/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
   78|       |
   79|       |      /*_FORCE_COVER_START_*/operator ITERATOR_T() { return *this; }/*_FORCE_COVER_END_*/
   80|       |      /*_FORCE_COVER_START_*/operator const ITERATOR_T() const { return *this; }/*_FORCE_COVER_END_*/
   81|       |
   82|       |      /*_FORCE_COVER_START_*/auto & operator*() {
   83|       |        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   84|       |        return wrapped_t::operator*();
   85|       |      }/*_FORCE_COVER_END_*/
   86|       |      /*_FORCE_COVER_START_*/const auto & operator*() const {
   87|       |        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   88|       |        return wrapped_t::operator*();
   89|       |      }/*_FORCE_COVER_END_*/
   90|       |
   91|       |      /*_FORCE_COVER_START_*/auto operator->() {
   92|       |        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   93|       |        return wrapped_t::operator->();
   94|       |      }/*_FORCE_COVER_END_*/
   95|       |      /*_FORCE_COVER_START_*/const auto operator->() const {
   96|       |        emp_assert(OK(true, false));  // Ensure array is being pointed to properly.
   97|       |        return wrapped_t::operator->();
   98|       |      }/*_FORCE_COVER_END_*/
   99|       |
  100|       |      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  101|       |      /*_FORCE_COVER_START_*/this_t operator++(int x) { emp_assert(OK(true,false)); return this_t(wrapped_t::operator++(x), v_ptr); }/*_FORCE_COVER_END_*/
  102|       |      /*_FORCE_COVER_START_*/this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }/*_FORCE_COVER_END_*/
  103|       |      /*_FORCE_COVER_START_*/this_t operator--(int x) { emp_assert(OK(false,true)); return this_t(wrapped_t::operator--(x), v_ptr); }/*_FORCE_COVER_END_*/
  104|       |
  105|       |      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  106|       |      /*_FORCE_COVER_START_*/auto operator-(int in) { emp_assert(OK()); return this_t(wrapped_t::operator-(in), v_ptr); }/*_FORCE_COVER_END_*/
  107|       |      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  108|       |
  109|       |      /*_FORCE_COVER_START_*/this_t & operator+=(int in) { emp_assert(OK()); wrapped_t::operator+=(in); return *this; }/*_FORCE_COVER_END_*/
  110|       |      /*_FORCE_COVER_START_*/this_t & operator-=(int in) { emp_assert(OK()); wrapped_t::operator-=(in); return *this; }/*_FORCE_COVER_END_*/
  111|       |      /*_FORCE_COVER_START_*/auto & operator[](int offset) { emp_assert(OK()); return wrapped_t::operator[](offset); }/*_FORCE_COVER_END_*/
  112|       |    };
  113|       |
  114|       |    using iterator = iterator_wrapper< typename base_t::iterator >;
  115|       |    using const_iterator = iterator_wrapper< typename base_t::const_iterator >;
  116|       |    using reverse_iterator = iterator_wrapper< typename base_t::reverse_iterator >;
  117|       |    using const_reverse_iterator = iterator_wrapper< typename base_t::const_reverse_iterator >;
  118|       |    using value_type = T;
  119|       |    using size_type = typename base_t::size_type;
  120|       |    using reference = typename base_t::reference;
  121|       |    using const_reference = typename base_t::const_reference;
  122|       |
  123|     67|    /*_FORCE_COVER_START_*/array() : base_t(N), valid(true) {}/*_FORCE_COVER_END_*/;
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EEC2Ev
  ------------------
  | _ZN3emp5arrayIiLm128EEC2Ev:
  |  123|     67|    /*_FORCE_COVER_START_*/array() : base_t(N), valid(true) {}/*_FORCE_COVER_END_*/;
  ------------------
  124|    202|    /*_FORCE_COVER_START_*/array(const this_t & _in) : base_t(_in), valid(true) { emp_assert(_in.size() == N); }/*_FORCE_COVER_END_*/;
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EEC2ERKS1_
  ------------------
  | _ZN3emp5arrayIiLm128EEC2ERKS1_:
  |  124|    202|    /*_FORCE_COVER_START_*/array(const this_t & _in) : base_t(_in), valid(true) { emp_assert(_in.size() == N); }/*_FORCE_COVER_END_*/;
  ------------------
  125|      0|    /*_FORCE_COVER_START_*/array(std::initializer_list<T> in_list) : base_t(in_list), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*/
  126|      0|    /*_FORCE_COVER_START_*/array(const base_t & in) : base_t(in), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*/   // Emergency fallback
  127|       |    /*_FORCE_COVER_START_*/template <typename InputIt>
  128|       |    /*_FORCE_COVER_START_*/array(InputIt first, InputIt last) : base_t(first, last), valid(true) { emp_assert(size() == N); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  129|    269|    /*_FORCE_COVER_START_*/~array() { valid=false; }/*_FORCE_COVER_END_*/ // No longer valid when array is deleted.
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EED2Ev
  ------------------
  | _ZN3emp5arrayIiLm128EED2Ev:
  |  129|    269|    /*_FORCE_COVER_START_*/~array() { valid=false; }/*_FORCE_COVER_END_*/ // No longer valid when array is deleted.
  ------------------
  130|       |
  131|      0|    /*_FORCE_COVER_START_*/operator std::array<T,N>() { 
  132|      0|      std::array<T,N> ar;
  133|      0|      for (size_t i = 0; i < N; i++) ar[i] = base_t::operator[](i);
  134|      0|      return ar;
  135|      0|    }/*_FORCE_COVER_END_*/
  136|       |
  137|    202|    /*_FORCE_COVER_START_*/constexpr size_t size() const { return N; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp5arrayIiLm2EE4sizeEv
  ------------------
  | _ZNK3emp5arrayIiLm128EE4sizeEv:
  |  137|    202|    /*_FORCE_COVER_START_*/constexpr size_t size() const { return N; }/*_FORCE_COVER_END_*/
  ------------------
  138|       |
  139|      0|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(base_t::begin(), this); }/*_FORCE_COVER_END_*/
  140|      0|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(base_t::begin(), this); }/*_FORCE_COVER_END_*/
  141|      0|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(base_t::end(), this); }/*_FORCE_COVER_END_*/
  142|      0|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(base_t::end(), this); }/*_FORCE_COVER_END_*/
  143|       |
  144|      0|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  145|       |
  146|  1.45k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  147|  1.45k|      emp_assert(pos < N, pos, N);
  148|  1.45k|      return base_t::operator[](pos);
  149|  1.45k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EEixEm
  ------------------
  | _ZN3emp5arrayIiLm128EEixEm:
  |  146|  1.45k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  147|  1.45k|      emp_assert(pos < N, pos, N);
  |  148|  1.45k|      return base_t::operator[](pos);
  |  149|  1.45k|    }/*_FORCE_COVER_END_*/
  ------------------
  150|       |
  151|    276|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  152|    276|      emp_assert(pos < N, pos, N);
  153|    276|      return base_t::operator[](pos);
  154|    276|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp5arrayIiLm2EEixEm
  ------------------
  | _ZNK3emp5arrayIiLm128EEixEm:
  |  151|    276|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  152|    276|      emp_assert(pos < N, pos, N);
  |  153|    276|      return base_t::operator[](pos);
  |  154|    276|    }/*_FORCE_COVER_END_*/
  ------------------
  155|       |
  156|      0|    /*_FORCE_COVER_START_*/T & back() { emp_assert(N > 0); return base_t::back(); }/*_FORCE_COVER_END_*/
  157|      0|    /*_FORCE_COVER_START_*/const T & back() const { emp_assert(N > 0); return base_t::back(); }/*_FORCE_COVER_END_*/
  158|      0|    /*_FORCE_COVER_START_*/T & front() { emp_assert(N > 0); return base_t::front(); }/*_FORCE_COVER_END_*/
  159|      0|    /*_FORCE_COVER_START_*/const T & front() const { emp_assert(N > 0); return base_t::front(); }/*_FORCE_COVER_END_*/
  160|       |
  161|     67|    /*_FORCE_COVER_START_*/void fill(const T & val) { this->assign(N, val); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp5arrayIiLm2EE4fillERKi
  ------------------
  | _ZN3emp5arrayIiLm128EE4fillERKi:
  |  161|     67|    /*_FORCE_COVER_START_*/void fill(const T & val) { this->assign(N, val); }/*_FORCE_COVER_END_*/
  ------------------
  162|       |
  163|       |    // Functions to make sure to throw an error on:
  164|       |
  165|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  166|      0|    /*_FORCE_COVER_START_*/void resize(size_t new_size, const T & val) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  167|       |
  168|       |    /*_FORCE_COVER_START_*/template <typename... PB_Ts>
  169|       |    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  170|      0|    /*_FORCE_COVER_START_*/void pop_back() { emp_assert(false, "invalid operation for array!"); }/*_FORCE_COVER_END_*/
  171|       |
  172|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  173|       |    /*_FORCE_COVER_START_*/iterator insert(ARGS &&... args) {
  174|       |      emp_assert(false, "invalid operation for array!");
  175|       |      return iterator( base_t::insert(std::forward<ARGS>(args)...), this );
  176|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  177|       |
  178|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  179|       |    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  180|       |      emp_assert(false, "invalid operation for array!");
  181|       |      return iterator( base_t::erase(std::forward<ARGS>(args)...), this );
  182|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  183|       |
  184|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  185|       |    /*_FORCE_COVER_START_*/iterator emplace(ARGS &&... args) {
  186|       |      emp_assert(false, "invalid operation for array!");
  187|       |      return iterator( base_t::emplace(std::forward<ARGS>(args)...), this );
  188|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  189|       |
  190|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  191|       |    /*_FORCE_COVER_START_*/void emplace_back(ARGS &&... args) {
  192|       |      emp_assert(false, "invalid operation for array!");
  193|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  194|       |  };
  195|       |
  196|       |  template class emp::array<int, 2>;
  197|       |
  198|       |}
  199|       |
  200|       |// A crude, generic printing function for arrays.
  201|       |/*_FORCE_COVER_START_*/template <typename T, size_t N>
  202|       |std::ostream & operator<<(std::ostream & out, const emp::array<T,N> & v) {
  203|       |  for (const T & x : v) out << x << " ";
  204|       |  return out;
  205|       |}/*_FORCE_COVER_END_*/
  206|       |
  207|       |/*_FORCE_COVER_START_*/template <typename T, size_t N>
  208|       |std::istream & operator>>(std::istream & is, emp::array<T,N> & v) {
  209|       |  for (T & x : v) is >> x;
  210|       |  return is;
  211|       |}/*_FORCE_COVER_END_*/
  212|       |
  213|       |#endif
  214|       |
  215|       |namespace emp{
  216|       |  /// Ensure that emp::array works with TypeID
  217|       |  template <typename T, size_t N> struct TypeID<emp::array<T,N>> {
  218|       |    static std::string GetName() {
  219|       |      std::stringstream ss;
  220|       |      ss << "emp::array<" << TypeID<T>::GetName() << "," << N << ">";
  221|       |      return ss.str();
  222|       |    }
  223|       |  };
  224|       |}
  225|       |
  226|       |#endif
  227|       |

/home/emily/repos/Empirical_Tests/source/base/assert.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file assert.h
    7|       | *  @brief A more dynamic replacement for standard library asserts.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  A replacement for the system-level assert.h, called "emp_assert"
   11|       | *  Added functionality:
   12|       | *   - If compiled with Emscripten, will provide pop-up alerts in a web browser.
   13|       | *   - emp_assert can take additional arguments.  If the assert is triggered, those extra
   14|       | *     arguments will be evaluated and printed.
   15|       | *   - if NDEBUG -or- EMP_NDEBUG is defined, the expression in emp_assert() is not evaluated.
   16|       | *   - if EMP_TDEBUG is defined, emp_assert() goes into test mode and records failures, but
   17|       | *     does not abort.  (useful for unit tests of asserts)
   18|       | *
   19|       | *  Example:
   20|       | *
   21|       | *     int a = 6;
   22|       | *     emp_assert(a==5, a);
   23|       | *
   24|       | *  When compiled in debug mode (i.e. without the -DNDEBUG flag), this will trigger an assertion
   25|       | *  error and print the value of a.
   26|       | * 
   27|       | * 
   28|       | *  @todo: Add emp_assert_warning() for non-terminating assert.  Should be able to disable with 
   29|       | *         a command-line option (-DEMP_NO_WARNINGS)
   30|       | */
   31|       |
   32|       |#ifndef EMP_ASSERT_H
   33|       |#define EMP_ASSERT_H
   34|       |
   35|       |#include <iostream>
   36|       |#include <string>
   37|       |#include <sstream>
   38|       |
   39|       |#include "macros.h"
   40|       |
   41|       |/// @cond DEFINES
   42|       |
   43|       |/// If we are in emscripten, make sure to include the header.
   44|       |#ifdef EMSCRIPTEN
   45|       |#include <emscripten.h>
   46|       |#endif
   47|       |
   48|       |/// NDEBUG and TDEBUG should trigger their EMP equivilents.
   49|       |#ifdef NDEBUG
   50|       |#define EMP_NDEBUG
   51|       |#endif
   52|       |
   53|       |#ifdef TDEBUG
   54|       |#define EMP_TDEBUG
   55|       |#endif
   56|       |
   57|       |
   58|       |/// Helper macros used throughout...
   59|       |#define emp_assert_TO_PAIR(X) EMP_STRINGIFY(X) , X
   60|       |
   61|       |/// Turn off all asserts in EMP_NDEBUG
   62|       |#ifdef EMP_NDEBUG
   63|       |namespace emp {
   64|       |  constexpr bool assert_on = false;
   65|       |}
   66|       |
   67|       |// GROUP 1:   --- Debug OFF ---
   68|       |
   69|       |/// Ideally, this assert should use the expression (to prevent compiler error), but should not
   70|       |/// generate any assembly code.  For now, just make it blank (other options commented out)
   71|       |#define emp_assert(...)
   72|       |// #define emp_assert(EXPR) ((void) sizeof(EXPR) )
   73|       |// #define emp_assert(EXPR, ...) { constexpr bool __emp_assert_tmp = false && (EXPR); (void) __emp_assert_tmp; }
   74|       |
   75|       |// Asserts to check only when in Emscripten should also be disabled.
   76|       |#define emp_emscripten_assert(...)
   77|       |
   78|       |
   79|       |// GROUP 2:   --- Unit Testing ON ---
   80|       |#elif defined(EMP_TDEBUG)           // EMP_NDEBUG not set, but EMP_TDEBUG is!
   81|       |
   82|       |namespace emp {
   83|       |  constexpr bool assert_on = true;
   84|       |  struct AssertFailInfo {
   85|       |    std::string filename;
   86|       |    int line_num;
   87|       |    std::string error;
   88|       |  };
   89|       |  AssertFailInfo assert_fail_info;
   90|       |  bool assert_last_fail = false;
   91|       |
   92|       |  template <typename... EXTRA>
   93|       |  bool assert_trigger(std::string filename, size_t line, std::string expr) {
   94|       |    emp::assert_fail_info.filename = __FILE__;
   95|       |    emp::assert_fail_info.line_num = __LINE__;
   96|       |    emp::assert_fail_info.error = expr;
   97|       |    emp::assert_last_fail = true;
   98|       |
   99|       |    return true;
  100|       |  }
  101|       |
  102|       |  void assert_clear() { emp::assert_last_fail = false; }
  103|       |}
  104|       |
  105|       |// Unit Testing ON
  106|       |
  107|       |#define emp_assert(...)                                                                       \
  108|       |  do {                                                                                        \
  109|       |    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                       \
  110|       |    emp::assert_trigger(__FILE__, __LINE__, EMP_STRINGIFY( EMP_GET_ARG_1(__VA_ARGS__, ~) ));  \
  111|       |  } while(0)
  112|       |
  113|       |// Unit-testing asserts to check only when in Emscripten should depend on if we are in Emscripten
  114|       |#ifdef EMSCRIPTEN
  115|       |#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  116|       |#else
  117|       |#define emp_emscripten_assert(...)
  118|       |#endif
  119|       |
  120|       |
  121|       |// GROUP 3:   --- Emscripten debug ON ---
  122|       |#elif EMSCRIPTEN  // Neither EMP_NDEBUG nor EMP_TDEBUG set, but compiling with Emscripten
  123|       |
  124|       |namespace emp {
  125|       |  constexpr bool assert_on = true;
  126|       |  static int TripAssert() {
  127|       |    static int trip_count = 0;
  128|       |    return ++trip_count;
  129|       |  }
  130|       |
  131|       |  /// Base case for assert_print...
  132|       |  void assert_print(std::stringstream &) { ; }
  133|       |
  134|       |  /// Print out information about the next variable and recurse...
  135|       |  template <typename T, typename... EXTRA>
  136|       |  void assert_print(std::stringstream & ss, std::string name, T && val, EXTRA &&... extra) {
  137|       |    ss << name << ": [" << val << "]" << std::endl;
  138|       |    assert_print(ss, std::forward<EXTRA>(extra)...);
  139|       |  }
  140|       |
  141|       |  template <typename IGNORE, typename... EXTRA>
  142|       |  bool assert_trigger(std::string filename, size_t line, std::string expr, IGNORE, EXTRA &&... extra) {
  143|       |    std::stringstream ss;
  144|       |    ss << "Assert Error (In " << filename << " line " << line << "): " << expr << '\n';
  145|       |    assert_print(ss, std::forward<EXTRA>(extra)...);
  146|       |    if (emp::TripAssert() <= 3) {
  147|       |      EM_ASM_ARGS({ msg = Pointer_stringify($0); alert(msg); }, ss.str().c_str());
  148|       |    }
  149|       |
  150|       |    // Print the current state of the stack.
  151|       |    EM_ASM( console.log('Callstack:\n' + stackTrace()); );
  152|       |    return true;
  153|       |  }
  154|       |}
  155|       |
  156|       |// Debug; Emscripten ON
  157|       |
  158|       |#define emp_assert(...)                                                                       \
  159|       |  do {                                                                                        \
  160|       |    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                       \
  161|       |    emp::assert_trigger(__FILE__, __LINE__, EMP_WRAP_ARGS(emp_assert_TO_PAIR, __VA_ARGS__) ); \
  162|       |  } while(0)
  163|       |
  164|       |// Emscripten asserts should be on since we are in Emscripten
  165|       |#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  166|       |
  167|       |
  168|       |// GROUP 3:   --- Debug ON, but Emscripten OFF ---
  169|       |#else
  170|       |
  171|       |namespace emp {
  172|       |  constexpr bool assert_on = true;
  173|       |
  174|       |  /// Base case for assert_print...
  175|      0|  void assert_print() { ; }
  176|       |
  177|       |  /// Print out information about the next variable and recurse...
  178|       |  /*_FORCE_COVER_START_*/template <typename T, typename... EXTRA>
  179|      0|  void assert_print(std::string name, T && val, EXTRA &&... extra) {
  180|      0|    std::cerr << name << ": [" << val << "]" << std::endl;
  181|      0|    assert_print(std::forward<EXTRA>(extra)...);
  182|      0|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA15_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printImJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA14_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA9_KcRKmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRKmJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA9_KcS1_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRKdJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRKdJRA4_KcS2_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA13_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRKjJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRiJRA5_KcS1_EEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRiJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRiJRA11_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA2_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA29_KcJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA10_KcRKmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRdJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA30_KcJRA3_S1_RmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA38_KcJRA3_S1_RmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIPKvJRA16_KciS5_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIiJRA16_KcbEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIbJEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRA36_KcJRA3_S1_RmRA14_S1_PKvRA16_S1_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA14_KcPKvRA16_S2_bEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIPKvJRA16_KcbEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp12assert_printIRmJRA11_KcmEEEvNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEOT_DpOT0_
  ------------------
  183|       |
  184|       |  /*_FORCE_COVER_START_*/template <typename IGNORE, typename... EXTRA>
  185|      0|  bool assert_trigger(std::string filename, size_t line, std::string expr, IGNORE, EXTRA &&... extra) {
  186|      0|    std::cerr << "Assert Error (In " << filename << " line " << line
  187|      0|              <<  "): " << expr << std::endl;
  188|      0|    assert_print(std::forward<EXTRA>(extra)...);
  189|      0|    return true;
  190|      0|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRmRA15_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA5_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA9_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA5_KcRmRA14_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA3_KcRmRA14_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPmJRA11_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA6_KcRmRA9_S1_RKmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA6_KcRmRA9_S1_S4_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA2_KcRKdEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRKdS3_S5_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerISt8functionIFiiiiiEEJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS9_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRmRA13_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA15_KcmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS9_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerISt8functionIFmiEEJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS9_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRKjEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPNS_8FunctionIJFvPNS_11TrackedTypeES3_EEEEJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA6_KcRiRA5_S1_S4_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA6_KcRiRA11_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA5_KcRiRA11_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS6_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRmRA2_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA31_KcRA29_S1_EEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA4_KcRKmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSB_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA8_KcRmRA10_S1_RKmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA2_KcRdEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA32_KcRA30_S1_RA3_S1_RmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA40_KcRA38_S1_RA3_S1_RmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSE_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA14_KcPKvRA16_S1_iS7_bEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSD_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIPKvJEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmS8_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA3_KcRmEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSA_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA38_KcRA36_S1_RA3_S1_RmRA14_S1_PKvRA16_S1_bEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSK_T_DpOT0_
  ------------------
  | Unexecuted instantiation: _ZN3emp14assert_triggerIbJRA6_KcRmRA11_S1_mEEEbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEmSC_T_DpOT0_
  ------------------
  191|       |}
  192|       |
  193|       |/// @endcond
  194|       |
  195|       |// Debug; Not Emscripten
  196|       |
  197|       |/// Require a specified condition to be true.  If it is false, immediately halt execution.
  198|       |/// Note: If NDEBUG is defined, emp_assert() will not do anything.
  199|       |#define emp_assert(...)                                                                          \
  200|   869k|  do {                                                                                           \
  201|   869k|    !(EMP_GET_ARG_1(__VA_ARGS__, ~)) &&                                                          \
  202|   869k|    emp::assert_trigger(__FILE__, __LINE__, EMP_WRAP_ARGS(emp_assert_TO_PAIR, __VA_ARGS__) ) &&  \
  203|   869k|    (abort(), false);                                                                            \
  204|   869k|  } while(0)
  205|       |
  206|       |// Emscripten-only asserts should be disabled since we are not in Emscripten
  207|       |/// Require a specified condition to be true if this program was compiled to Javascript with Emscripten.
  208|       |/// Note: If NDEBUG is defined, emp_emscripten_assert() will not do anything.
  209|       |#define emp_emscripten_assert(...) emp_assert(__VA_ARGS__)
  210|       |
  211|       |/// @cond DEFINES
  212|       |
  213|       |#endif // NDEBUG
  214|       |
  215|       |
  216|       |#endif // Include guard
  217|       |
  218|       |/// @endcond
  219|       |

/home/emily/repos/Empirical_Tests/source/base/macros.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file macros.h
    7|       | *  @brief Generally useful macros that can perform cools tricks.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *
   11|       | *  Generally useful macros that can perform cools tricks.  As with all macros, use only
   12|       | *  after careful exclusion of alternative approaches.
   13|       | *
   14|       | *  The Macros to highlighted here are:
   15|       | *
   16|       | *  ===== String Handling and Printing =====
   17|       | *  EMP_PRINT_RESULT(A) will print to std::cout both the string that was passed into the
   18|       | *       macro and what that string evaluates to.
   19|       | *
   20|       | *  EMP_STRINGIFY(...) converts all arguments into a single string (including commas).
   21|       | *  EMP_STRINGIFY_EACH(...) converts each argument into a string (leaving commas).
   22|       | *
   23|       | *  ===== Managing variadic arguments =====
   24|       | *  EMP_COUNT_ARGS(...) returns the number of arguments in the __VA_ARGS__
   25|       | *  EMP_GET_ARG(N, ...) return the Nth arg that follows
   26|       | *  EMP_POP_ARGS(N, ...) remove the first N args, return the rest.
   27|       | *  EMP_PACK_ARGS(...) Group args together in parens so they are treated like one argument.
   28|       | *  EMP_DUPLICATE_ARGS(N, ...) makes N collated copies of all args to follow.
   29|       | *  EMP_CROP_ARGS_TO(N, ...) reduces N args (must have at least that many)
   30|       | *  EMP_FORCE_ARGS_TO(N, P, ...) Crops or pads (with p) args to be exactly N long.
   31|       | *  EMP_ROTATE_ARGS(...) Moves the first argument to the end of the arg list.
   32|       | *  EMP_SELECT_ARGS(PATTERN, ...) Uses the (repeating) patter to select arguments to keep.
   33|       | *    Pattern is an argument pack consisting of i (include) or x (exclude).
   34|       | *  EMP_GET_ODD_ARGS(...) will return all arguments at odd positions (1,3,5,7, etc.)
   35|       | *  EMP_GET_EVEN_ARGS(...) will return all arguments at odd positions (2,4,6,8, etc.)
   36|       | *  EMP_REVERSE_ARGS(...) Reverse the order of arguments passed in.
   37|       | *
   38|       | *  ===== Argument Manipulation and Formatting =====
   39|       | *  EMP_MERGE(...) merge all arguments (after conversion) into a single unit.
   40|       | *  EMP_WRAP_EACH(W, ...) will run macro W on each of the other args and concatinate them.
   41|       | *  EMP_LAYOUT(W, P, ...) Similar to EMP_WRAP_EACH, but puts a P between each arg pair.
   42|       | *  EMP_WRAP_ARGS(W, ...) Similar to EMP_WRAP_EACH, but puts a COMMA between each arg pair.
   43|       | *  EMP_WRAP_ARG_PAIRS(W, ...) Similar to EMP_WRAP_ARGS, but passes pairs of args into W.
   44|       | *
   45|       | *  ===== Macro Building =====
   46|       | *  EMP_ASSEMBLE_MACRO takes in a prefix and set of arguments and appends the size of the
   47|       | *  number of arguments to the prefix, and passes in all of the arguments.
   48|       | *
   49|       | *  EMP_ASSEMBLE_MACRO_1ARG assumes the first argument after the prefix should not count
   50|       | *  toward the size, but passed in anyway. (*_?ARG  works for more arguments up to 10).
   51|       | *
   52|       | *  EMP_FAKE_ARG or EMP_FAKE_2ARG behave as a single argument.  If, in manipulating them
   53|       | *  You make them become EMP_CONVERT_ARG_EMP_FAKE_ARG(A) or EMP_CONVERT_ARG_EMP_FAKE_2ARG(A)
   54|       | *  (i.e., prepend with EMP_CONVERT and provide an argument) it will trigger a conversion.
   55|       | *  If you prepend anything else similarly, it wil NOT trigger a conversion.
   56|       | *
   57|       | *  This is especially useful with _2ARG since anything unconverted will be a single
   58|       | *  argument, while anything converted will be two, allowing us to shift arguments
   59|       | *  to perform conditional behaviors.
   60|       | *
   61|       | *
   62|       | *  @todo We need to standardize how we handle macros that covert inputs to comma-separated
   63|       | *    results vs those that merge them together.  One option is to have comma-separated the
   64|       | *    default and then have an EMP_REMOVE_COMMAS (or somesuch)
   65|       | *
   66|       | *  @todo EMP_TYPES_TO_ARGS (not yet listed above) is poorly named.  Maybe EMP_DECLARE_ARGS?
   67|       | *
   68|       | *  @todo It would be useful to have EMP_WRAP_WITH_ID which passes in the position ID as the
   69|       | *    second argument.  This would allow us to, for example, streamline EMP_TYPES_TO_ARGS.
   70|       | *
   71|       | *  @todo A more generic EMP_WRAP macro that is specified on the fly.  For example:
   72|       | *      EMP_WRAP(W,2,4,A,B,a,b,c,d,e,f,g,h,i,j,k,l)
   73|       | *    would assume six args in each wrap, A, B, and the rest broken into groups of four. I.e.:
   74|       | *      W(A,B,a,b,c,d), W(A,B,e,f,g,h), W(A,B,i,j,k,l)
   75|       | */
   76|       |
   77|       |#ifndef EMP_MACROS_H
   78|       |#define EMP_MACROS_H
   79|       |
   80|       |#include "macro_math.h"
   81|       |
   82|       |/// The below values allow you to have EMP_FAKE_ARG or EMP_FAKE_2ARG as a single argument.
   83|       |/// If you prepend it with EMP_CONVERT it will trigger a conversion.  If you prepend anything
   84|       |/// else similarly, it wil NOT triggera a conversion (and stay a single argument)
   85|       |#define EMP_CONVERT_ARG_EMP_FAKE_ARG(A) A
   86|       |#define EMP_CONVERT_ARG_EMP_FAKE_2ARG(A) ~, A
   87|       |
   88|       |
   89|       |/// EMP_STRINGIFY takes any input, processes macros, and puts the result in quotes.converts all
   90|       |/// arguments into a single string (including commas).
   91|       |#define EMP_STRINGIFY(...) EMP_STRINGIFY_IMPL(__VA_ARGS__)
   92|       |/// @cond MACROS
   93|       |#define EMP_STRINGIFY_IMPL(...) #__VA_ARGS__
   94|       |/// @endcond
   95|       |
   96|       |/// @cond MACROS
   97|       |#define EMP_PRINT_RESULT_IMPL(STREAM, LHS, RHS) STREAM << "[[" << LHS << "]] = [[" << RHS << "]]" << std::endl
   98|       |#define EMP_PRINT_RESULT_TO(STREAM, A) EMP_PRINT_RESULT_IMPL(STREAM, #A, A)
   99|       |/// @endcond
  100|       |/// Print to std::cout both the string that was passed into the macro and what that string
  101|       |/// evaluates to.
  102|       |#define EMP_PRINT_RESULT(A) EMP_PRINT_RESULT_IMPL(std::cout, #A, A)
  103|       |
  104|       |/// @cond MACROS
  105|      0|#define EMP_POP_ARGS_IMPL_1(A,...) __VA_ARGS__
  106|       |#define EMP_POP_ARGS_IMPL_2(A,B,...) __VA_ARGS__
  107|       |#define EMP_POP_ARGS_IMPL_4(A,B,C,D,...) __VA_ARGS__
  108|       |#define EMP_POP_ARGS_IMPL_8(A,B,C,D,E,F,G,H,...) __VA_ARGS__
  109|       |#define EMP_POP_ARGS_IMPL_16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,...) __VA_ARGS__
  110|       |#define EMP_POP_ARGS_IMPL_32(...)  EMP_POP_ARGS_16(EMP_POP_ARGS_16(__VA_ARGS__) )
  111|       |#define EMP_POP_ARGS_IMPL_64(...)  EMP_POP_ARGS_32(EMP_POP_ARGS_32(__VA_ARGS__) )
  112|       |#define EMP_POP_ARGS_IMPL_128(...) EMP_POP_ARGS_64(EMP_POP_ARGS_64(__VA_ARGS__) )
  113|       |#define EMP_POP_ARGS_IMPL_256(...) EMP_POP_ARGS_128(EMP_POP_ARGS_128(__VA_ARGS__) )
  114|       |#define EMP_POP_ARGS_IMPL_512(...) EMP_POP_ARGS_256(EMP_POP_ARGS_256(__VA_ARGS__) )
  115|       |
  116|       |#define EMP_POP_ARGS_0(...) __VA_ARGS__
  117|      0|#define EMP_POP_ARGS_1(...) EMP_POP_ARGS_IMPL_1(__VA_ARGS__)
  118|       |#define EMP_POP_ARGS_2(...) EMP_POP_ARGS_IMPL_2(__VA_ARGS__)
  119|       |#define EMP_POP_ARGS_4(...) EMP_POP_ARGS_IMPL_4(__VA_ARGS__)
  120|       |#define EMP_POP_ARGS_8(...) EMP_POP_ARGS_IMPL_8(__VA_ARGS__)
  121|       |#define EMP_POP_ARGS_16(...) EMP_POP_ARGS_IMPL_16(__VA_ARGS__)
  122|       |#define EMP_POP_ARGS_32(...) EMP_POP_ARGS_IMPL_32(__VA_ARGS__)
  123|       |#define EMP_POP_ARGS_64(...) EMP_POP_ARGS_IMPL_64(__VA_ARGS__)
  124|       |#define EMP_POP_ARGS_128(...) EMP_POP_ARGS_IMPL_128(__VA_ARGS__)
  125|       |#define EMP_POP_ARGS_256(...) EMP_POP_ARGS_IMPL_256(__VA_ARGS__)
  126|       |#define EMP_POP_ARGS_512(...) EMP_POP_ARGS_IMPL_512(__VA_ARGS__)
  127|       |/// @endcond
  128|       |
  129|       |#define EMP_POP_ARG(...) EMP_POP_ARGS_IMPL_1(__VA_ARGS__)
  130|       |/// remove the first N args, return the rest.
  131|       |#define EMP_POP_ARGS(N, ...) EMP_EVAL( EMP_POP_ARGS_SUM EMP_EMPTY() (EMP_EVAL(EMP_DEC_TO_SUM(N)),__VA_ARGS__) )
  132|       |#define EMP_POP_ARGS_SUM(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,...) EMP_POP_ARGS_##S0( EMP_POP_ARGS_##S1( EMP_POP_ARGS_##S2( EMP_POP_ARGS_##S3( EMP_POP_ARGS_##S4( EMP_POP_ARGS_##S5( EMP_POP_ARGS_##S6( EMP_POP_ARGS_##S7( EMP_POP_ARGS_##S8( EMP_POP_ARGS_##S9( __VA_ARGS__ ))))))))))
  133|       |
  134|       |/// Return the Nth arg that follows
  135|       |#define EMP_GET_ARG(N, ...) EMP_GET_ARG_1( EMP_POP_ARGS( EMP_DEC(N), __VA_ARGS__ ) )
  136|       |/// @cond MACROS
  137|   869k|#define EMP_GET_ARG_1(...) EMP_GET_ARG_1_IMPL(__VA_ARGS__)
  138|  1.09M|#define EMP_GET_ARG_1_IMPL(A, ...) A
  139|       |#define EMP_GET_ARG_2(...) EMP_GET_ARG_2_IMPL(__VA_ARGS__)
  140|       |#define EMP_GET_ARG_2_IMPL(A, B, ...) B
  141|       |/// @endcond
  142|       |
  143|       |/// returns the number of arguments in the __VA_ARGS__
  144|       |#define EMP_COUNT_ARGS(...) EMP_GET_ARG(1023, __VA_ARGS__, 1022, 1021, 1020, 1019, 1018, 1017, 1016, 1015, 1014, 1013, 1012, 1011, 1010, 1009, 1008, 1007, 1006, 1005, 1004, 1003, 1002, 1001, 1000, 999, 998, 997, 996, 995, 994, 993, 992, 991, 990, 989, 988, 987, 986, 985, 984, 983, 982, 981, 980, 979, 978, 977, 976, 975, 974, 973, 972, 971, 970, 969, 968, 967, 966, 965, 964, 963, 962, 961, 960, 959, 958, 957, 956, 955, 954, 953, 952, 951, 950, 949, 948, 947, 946, 945, 944, 943, 942, 941, 940, 939, 938, 937, 936, 935, 934, 933, 932, 931, 930, 929, 928, 927, 926, 925, 924, 923, 922, 921, 920, 919, 918, 917, 916, 915, 914, 913, 912, 911, 910, 909, 908, 907, 906, 905, 904, 903, 902, 901, 900, 899, 898, 897, 896, 895, 894, 893, 892, 891, 890, 889, 888, 887, 886, 885, 884, 883, 882, 881, 880, 879, 878, 877, 876, 875, 874, 873, 872, 871, 870, 869, 868, 867, 866, 865, 864, 863, 862, 861, 860, 859, 858, 857, 856, 855, 854, 853, 852, 851, 850, 849, 848, 847, 846, 845, 844, 843, 842, 841, 840, 839, 838, 837, 836, 835, 834, 833, 832, 831, 830, 829, 828, 827, 826, 825, 824, 823, 822, 821, 820, 819, 818, 817, 816, 815, 814, 813, 812, 811, 810, 809, 808, 807, 806, 805, 804, 803, 802, 801, 800, 799, 798, 797, 796, 795, 794, 793, 792, 791, 790, 789, 788, 787, 786, 785, 784, 783, 782, 781, 780, 779, 778, 777, 776, 775, 774, 773, 772, 771, 770, 769, 768, 767, 766, 765, 764, 763, 762, 761, 760, 759, 758, 757, 756, 755, 754, 753, 752, 751, 750, 749, 748, 747, 746, 745, 744, 743, 742, 741, 740, 739, 738, 737, 736, 735, 734, 733, 732, 731, 730, 729, 728, 727, 726, 725, 724, 723, 722, 721, 720, 719, 718, 717, 716, 715, 714, 713, 712, 711, 710, 709, 708, 707, 706, 705, 704, 703, 702, 701, 700, 699, 698, 697, 696, 695, 694, 693, 692, 691, 690, 689, 688, 687, 686, 685, 684, 683, 682, 681, 680, 679, 678, 677, 676, 675, 674, 673, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 655, 654, 653, 652, 651, 650, 649, 648, 647, 646, 645, 644, 643, 642, 641, 640, 639, 638, 637, 636, 635, 634, 633, 632, 631, 630, 629, 628, 627, 626, 625, 624, 623, 622, 621, 620, 619, 618, 617, 616, 615, 614, 613, 612, 611, 610, 609, 608, 607, 606, 605, 604, 603, 602, 601, 600, 599, 598, 597, 596, 595, 594, 593, 592, 591, 590, 589, 588, 587, 586, 585, 584, 583, 582, 581, 580, 579, 578, 577, 576, 575, 574, 573, 572, 571, 570, 569, 568, 567, 566, 565, 564, 563, 562, 561, 560, 559, 558, 557, 556, 555, 554, 553, 552, 551, 550, 549, 548, 547, 546, 545, 544, 543, 542, 541, 540, 539, 538, 537, 536, 535, 534, 533, 532, 531, 530, 529, 528, 527, 526, 525, 524, 523, 522, 521, 520, 519, 518, 517, 516, 515, 514, 513, 512, 511, 510, 509, 508, 507, 506, 505, 504, 503, 502, 501, 500, 499, 498, 497, 496, 495, 494, 493, 492, 491, 490, 489, 488, 487, 486, 485, 484, 483, 482, 481, 480, 479, 478, 477, 476, 475, 474, 473, 472, 471, 470, 469, 468, 467, 466, 465, 464, 463, 462, 461, 460, 459, 458, 457, 456, 455, 454, 453, 452, 451, 450, 449, 448, 447, 446, 445, 444, 443, 442, 441, 440, 439, 438, 437, 436, 435, 434, 433, 432, 431, 430, 429, 428, 427, 426, 425, 424, 423, 422, 421, 420, 419, 418, 417, 416, 415, 414, 413, 412, 411, 410, 409, 408, 407, 406, 405, 404, 403, 402, 401, 400, 399, 398, 397, 396, 395, 394, 393, 392, 391, 390, 389, 388, 387, 386, 385, 384, 383, 382, 381, 380, 379, 378, 377, 376, 375, 374, 373, 372, 371, 370, 369, 368, 367, 366, 365, 364, 363, 362, 361, 360, 359, 358, 357, 356, 355, 354, 353, 352, 351, 350, 349, 348, 347, 346, 345, 344, 343, 342, 341, 340, 339, 338, 337, 336, 335, 334, 333, 332, 331, 330, 329, 328, 327, 326, 325, 324, 323, 322, 321, 320, 319, 318, 317, 316, 315, 314, 313, 312, 311, 310, 309, 308, 307, 306, 305, 304, 303, 302, 301, 300, 299, 298, 297, 296, 295, 294, 293, 292, 291, 290, 289, 288, 287, 286, 285, 284, 283, 282, 281, 280, 279, 278, 277, 276, 275, 274, 273, 272, 271, 270, 269, 268, 267, 266, 265, 264, 263, 262, 261, 260, 259, 258, 257, 256, 255, 254, 253, 252, 251, 250, 249, 248, 247, 246, 245, 244, 243, 242, 241, 240, 239, 238, 237, 236, 235, 234, 233, 232, 231, 230, 229, 228, 227, 226, 225, 224, 223, 222, 221, 220, 219, 218, 217, 216, 215, 214, 213, 212, 211, 210, 209, 208, 207, 206, 205, 204, 203, 202, 201, 200, 199, 198, 197, 196, 195, 194, 193, 192, 191, 190, 189, 188, 187, 186, 185, 184, 183, 182, 181, 180, 179, 178, 177, 176, 175, 174, 173, 172, 171, 170, 169, 168, 167, 166, 165, 164, 163, 162, 161, 160, 159, 158, 157, 156, 155, 154, 153, 152, 151, 150, 149, 148, 147, 146, 145, 144, 143, 142, 141, 140, 139, 138, 137, 136, 135, 134, 133, 132, 131, 130, 129, 128, 127, 126, 125, 124, 123, 122, 121, 120, 119, 118, 117, 116, 115, 114, 113, 112, 111, 110, 109, 108, 107, 106, 105, 104, 103, 102, 101, 100, 99, 98, 97, 96, 95, 94, 93, 92, 91, 90, 89, 88, 87, 86, 85, 84, 83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72, 71, 70, 69, 68, 67, 66, 65, 64, 63, 62, 61, 60, 59, 58, 57, 56, 55, 54, 53, 52, 51, 50, 49, 48, 47, 46, 45, 44, 43, 42, 41, 40, 39, 38, 37, 36, 35, 34, 33, 32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
  145|       |
  146|       |/// @cond MACROS
  147|       |#define EMP_dup_bin_0(...)
  148|       |#define EMP_dup_bin_1(...) , __VA_ARGS__
  149|       |#define EMP_dup_bin_2(...) , __VA_ARGS__, __VA_ARGS__
  150|       |#define EMP_dup_bin_4(...) , __VA_ARGS__, __VA_ARGS__, __VA_ARGS__, __VA_ARGS__
  151|       |#define EMP_dup_bin_8(...)   EMP_dup_bin_4(__VA_ARGS__)EMP_dup_bin_4(__VA_ARGS__)
  152|       |#define EMP_dup_bin_16(...)  EMP_dup_bin_8(__VA_ARGS__)EMP_dup_bin_8(__VA_ARGS__)
  153|       |#define EMP_dup_bin_32(...)  EMP_dup_bin_16(__VA_ARGS__)EMP_dup_bin_16(__VA_ARGS__)
  154|       |#define EMP_dup_bin_64(...)  EMP_dup_bin_32(__VA_ARGS__)EMP_dup_bin_32(__VA_ARGS__)
  155|       |#define EMP_dup_bin_128(...) EMP_dup_bin_64(__VA_ARGS__)EMP_dup_bin_64(__VA_ARGS__)
  156|       |#define EMP_dup_bin_256(...) EMP_dup_bin_128(__VA_ARGS__)EMP_dup_bin_128(__VA_ARGS__)
  157|       |#define EMP_dup_bin_512(...) EMP_dup_bin_256(__VA_ARGS__)EMP_dup_bin_256(__VA_ARGS__)
  158|       |/// @endcond
  159|       |
  160|       |/// makes N collated copies of all args to follow.
  161|       |#define EMP_DUPLICATE_ARGS(N, ...) EMP_DUPLICATE_ARGS_SUM EMP_EMPTY() (EMP_EVAL(EMP_DEC_TO_SUM(N)),__VA_ARGS__)
  162|       |#define EMP_DUPLICATE_ARGS_SUM(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,...) EMP_POP_ARG(~ EMP_dup_bin_##S0(__VA_ARGS__)EMP_dup_bin_##S1(__VA_ARGS__)EMP_dup_bin_##S2(__VA_ARGS__)EMP_dup_bin_##S3(__VA_ARGS__)EMP_dup_bin_##S4(__VA_ARGS__)EMP_dup_bin_##S5(__VA_ARGS__)EMP_dup_bin_##S6(__VA_ARGS__)EMP_dup_bin_##S7(__VA_ARGS__)EMP_dup_bin_##S8(__VA_ARGS__)EMP_dup_bin_##S9(__VA_ARGS__))
  163|       |
  164|       |
  165|       |// Some PARAMETER PACK manipulatation (for macros, sets of args in parens to they are treated
  166|       |// as if they were a single argument.
  167|       |
  168|       |#define EMP_ECHO_ARGS(...) __VA_ARGS__
  169|       |/// Group args together in parens so they are treated like one argument.
  170|       |#define EMP_PACK_ARGS(...) (__VA_ARGS__)
  171|       |#define EMP_UNPACK_ARGS(A) EMP_ECHO_ARGS A
  172|       |
  173|       |#define EMP_PACK_POP(PACK) (EMP_POP_ARG PACK)
  174|       |#define EMP_PACK_TOP(PACK) EMP_GET_ARG_1 PACK
  175|       |#define EMP_PACK_PUSH(NEW, PACK) (NEW,EMP_UNPACK_ARGS(PACK))
  176|       |#define EMP_PACK_PUSH_REAR(NEW, PACK) (EMP_UNPACK_ARGS(PACK),NEW)
  177|       |#define EMP_PACK_SIZE(PACK) EMP_COUNT_ARGS PACK
  178|       |
  179|       |// Macros to work on multiple packs at once.
  180|       |#define EMP_PACKS_POP_ALL(...) EMP_WRAP_ARGS(EMP_PACK_POP, __VA_ARGS__)
  181|       |#define EMP_PACKS_TOP_ALL(...) EMP_WRAP_ARGS(EMP_PACK_TOP, __VA_ARGS__)
  182|       |#define EMP_PACKS_PUSH_ALL(NEW, ...) EMP_WRAP_ARGS_1ARG(EMP_PACK_PUSH, NEW, __VA_ARGS__)
  183|       |#define EMP_PACKS_PUSH_REAR_ALL(NEW, ...) EMP_WRAP_ARGS_1ARG(EMP_PACK_PUSH_REAR, NEW, __VA_ARGS__)
  184|       |#define EMP_PACKS_SIZE_ALL(...) EMP_WRAP_ARGS(EMP_PACK_SIZE, __VA_ARGS__)
  185|       |
  186|       |/// Group the arguments that follow into packs of size S.
  187|       |#define EMP_ARGS_TO_PACKS(S, ...) \
  188|       |  EMP_ARGS_TO_PACKS_impl(S, EMP_DIV(EMP_COUNT_ARGS(__VA_ARGS__), S), __VA_ARGS__)
  189|       |
  190|       |/// @cond MACROS
  191|       |// S = Size of each pack
  192|       |// N = Number of packs
  193|       |// P = Pack representatio of number of packs
  194|       |#define EMP_ARGS_TO_PACKS_impl(S, N, ...) EMP_ARGS_TO_PACKS_implB(S, EMP_DEC_TO_PACK(N), __VA_ARGS)
  195|       |#define EMP_ARGS_TO_PACKS_implB(S, P, ...) @CAO
  196|       |
  197|       |#define EMP_ARGS_TO_PACKS_1(S, ...) , (EMP_CROP_ARGS_TO(S, __VA_ARGS__))
  198|       |#define EMP_ARGS_TO_PACKS_2(S, ...)                                     \
  199|       |  EMP_ARGS_TO_PACKS_1(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_1(S,EMP_POP(N, __VA_ARGS__))
  200|       |#define EMP_ARGS_TO_PACKS_4(S, ...)                                     \
  201|       |  EMP_ARGS_TO_PACKS_2(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_2(S,EMP_POP(EMP_MULT(N,2),__VA_ARGS__))
  202|       |#define EMP_ARGS_TO_PACKS_8(S, ...)                                     \
  203|       |  EMP_ARGS_TO_PACKS_4(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_4(S,EMP_POP(EMP_MULT(N,4),__VA_ARGS__))
  204|       |#define EMP_ARGS_TO_PACKS_16(S, ...)                                    \
  205|       |  EMP_ARGS_TO_PACKS_8(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_8(S,EMP_POP(EMP_MULT(N,8),__VA_ARGS__))
  206|       |#define EMP_ARGS_TO_PACKS_32(S, ...)                                    \
  207|       |  EMP_ARGS_TO_PACKS_16(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_16(S,EMP_POP(EMP_MULT(N,16),__VA_ARGS__))
  208|       |#define EMP_ARGS_TO_PACKS_64(S, ...)                                    \
  209|       |  EMP_ARGS_TO_PACKS_32(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_32(S,EMP_POP(EMP_MULT(N,32),__VA_ARGS__))
  210|       |#define EMP_ARGS_TO_PACKS_128(S, ...)                                   \
  211|       |  EMP_ARGS_TO_PACKS_64(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_64(S,EMP_POP(EMP_MULT(N,64),__VA_ARGS__))
  212|       |#define EMP_ARGS_TO_PACKS_256(S, ...)                                   \
  213|       |  EMP_ARGS_TO_PACKS_128(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_128(S,EMP_POP(EMP_MULT(N,128),__VA_ARGS__))
  214|       |#define EMP_ARGS_TO_PACKS_512(S, ...)                                   \
  215|       |  EMP_ARGS_TO_PACKS_256(S,__VA_ARGS__)EMP_ARGS_TO_PACKS_256(S,EMP_POP(EMP_MULT(N,256),__VA_ARGS__))
  216|       |/// @endcond
  217|       |
  218|       |/// EMP_CALL_BY_PACKS is used to build other macros.  It will call a series of versions of C
  219|       |/// based on binary representations so that all args are called, passing F in as the first
  220|       |/// parameter.  For example, if C = ABC_ and 13 arguments are passed in, it will call ABC_8,
  221|       |/// ABC_4 and ABC_1 on appropriate subsets (prepending F as the first argument of each call)
  222|       |///
  223|       |/// C is the CALL needed to be made on each element of the parameter pack
  224|       |/// F is a FIXED parameter (potentially a pack) sent to all calls.
  225|       |#define EMP_CALL_BY_PACKS(C, F, ...)                                     \
  226|       |  EMP_CALL_BY_PACKS_impl(C, F, EMP_DEC_TO_PACK(EMP_COUNT_ARGS(__VA_ARGS__)), __VA_ARGS__, ~)
  227|       |
  228|       |/// @cond MACROS
  229|       |
  230|       |// Internal helpers...
  231|       |// P is the pack of call counts the still need to be done
  232|       |// A is the number of arguments in P.
  233|       |// N is the NEXT call count needed to be done.
  234|       |#define EMP_CALL_BY_PACKS_impl(C, F, P, ...) \
  235|       |  EMP_CALL_BY_PACKS_implB(C, F, EMP_PACK_SIZE(P), EMP_PACK_PUSH_REAR(~, P), __VA_ARGS__)
  236|       |#define EMP_CALL_BY_PACKS_implB(C, F, A, P, ...) EMP_CALL_BY_PACKS_implC(C, F, A, P, __VA_ARGS__)
  237|       |#define EMP_CALL_BY_PACKS_implC(C, F, A, P, ...) \
  238|       |  EMP_CALL_BY_PACKS_implD(C, EMP_PACK_TOP(P), F, A, EMP_PACK_POP(P), __VA_ARGS__)
  239|       |#define EMP_CALL_BY_PACKS_implD(C, N, F, A, P, ...) EMP_CALL_BY_PACKS_impl##A(C,N,F,P,__VA_ARGS__)
  240|       |
  241|       |#define EMP_CALL_BY_PACKS_impl1(C, N, F, P, ...)        \
  242|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)
  243|       |
  244|       |#define EMP_CALL_BY_PACKS_impl2(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl2B(C, N, F, P, __VA_ARGS__)
  245|       |#define EMP_CALL_BY_PACKS_impl2B(C, N, F, P, ...)                       \
  246|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  247|       |  EMP_CALL_BY_PACKS_impl1(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  248|       |
  249|       |#define EMP_CALL_BY_PACKS_impl3(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl3B(C, N, F, P, __VA_ARGS__)
  250|       |#define EMP_CALL_BY_PACKS_impl3B(C, N, F, P, ...)                       \
  251|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  252|       |  EMP_CALL_BY_PACKS_impl2(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  253|       |
  254|       |#define EMP_CALL_BY_PACKS_impl4(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl4B(C, N, F, P, __VA_ARGS__)
  255|       |#define EMP_CALL_BY_PACKS_impl4B(C, N, F, P, ...)                       \
  256|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  257|       |  EMP_CALL_BY_PACKS_impl3(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  258|       |
  259|       |#define EMP_CALL_BY_PACKS_impl5(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl5B(C, N, F, P, __VA_ARGS__)
  260|       |#define EMP_CALL_BY_PACKS_impl5B(C, N, F, P, ...)                       \
  261|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  262|       |  EMP_CALL_BY_PACKS_impl4(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  263|       |
  264|       |#define EMP_CALL_BY_PACKS_impl6(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl6B(C, N, F, P, __VA_ARGS__)
  265|       |#define EMP_CALL_BY_PACKS_impl6B(C, N, F, P, ...)                       \
  266|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  267|       |  EMP_CALL_BY_PACKS_impl5(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  268|       |
  269|       |#define EMP_CALL_BY_PACKS_impl7(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl7B(C, N, F, P, __VA_ARGS__)
  270|       |#define EMP_CALL_BY_PACKS_impl7B(C, N, F, P, ...)                       \
  271|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  272|       |  EMP_CALL_BY_PACKS_impl6(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  273|       |
  274|       |#define EMP_CALL_BY_PACKS_impl8(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl8B(C, N, F, P, __VA_ARGS__)
  275|       |#define EMP_CALL_BY_PACKS_impl8B(C, N, F, P, ...)                       \
  276|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  277|       |  EMP_CALL_BY_PACKS_impl7(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  278|       |
  279|       |#define EMP_CALL_BY_PACKS_impl9(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl9B(C, N, F, P, __VA_ARGS__)
  280|       |#define EMP_CALL_BY_PACKS_impl9B(C, N, F, P, ...)                       \
  281|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  282|       |  EMP_CALL_BY_PACKS_impl8(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  283|       |
  284|       |#define EMP_CALL_BY_PACKS_impl10(C, N, F, P, ...) EMP_CALL_BY_PACKS_impl10B(C, N, F, P, __VA_ARGS__)
  285|       |#define EMP_CALL_BY_PACKS_impl10B(C, N, F, P, ...)                      \
  286|       |  EMP_CALL_BY_PACKS_do_call(C, N, F, __VA_ARGS__)                       \
  287|       |  EMP_CALL_BY_PACKS_impl9(C, EMP_PACK_TOP(P), F, EMP_PACK_POP(P), EMP_POP_ARGS_ ## N(__VA_ARGS__) )
  288|       |
  289|       |#define EMP_CALL_BY_PACKS_do_call(C, V, F, ...) C ## V(F, __VA_ARGS__)
  290|       |
  291|       |/// @endcond
  292|       |
  293|       |/// EMP_WRAP_EACH, wraps each argument in the specified macro wrapper.
  294|       |#define EMP_WRAP_EACH(W, ...) EMP_CALL_BY_PACKS(EMP_WRAP_EACH_, W, __VA_ARGS__)
  295|       |/// @cond MACROS
  296|       |#define EMP_WRAP_EACH_1(W, A, ...) W(A)
  297|       |#define EMP_WRAP_EACH_2(W, A,B,...) EMP_WRAP_EACH_1(W, A, ~) EMP_WRAP_EACH_1(W, B, ~)
  298|       |#define EMP_WRAP_EACH_4(W, A,B,...) EMP_WRAP_EACH_2(W, A, B, ~) EMP_WRAP_EACH_2(W, __VA_ARGS__)
  299|       |#define EMP_WRAP_EACH_8(W, ...)                                         \
  300|       |  EMP_WRAP_EACH_4(W, __VA_ARGS__)                                       \
  301|       |  EMP_EVAL1( EMP_WRAP_EACH_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  302|       |#define EMP_WRAP_EACH_16(W, ...) \
  303|       |  EMP_WRAP_EACH_8(W, __VA_ARGS__) \
  304|       |  EMP_EVAL2( EMP_WRAP_EACH_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  305|       |#define EMP_WRAP_EACH_32(W, ...) \
  306|       |  EMP_WRAP_EACH_16(W, __VA_ARGS__) \
  307|       |  EMP_EVAL3( EMP_WRAP_EACH_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  308|       |#define EMP_WRAP_EACH_64(W, ...) \
  309|       |  EMP_WRAP_EACH_32(W, __VA_ARGS__) \
  310|       |  EMP_EVAL4( EMP_WRAP_EACH_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  311|       |#define EMP_WRAP_EACH_128(W, ...) \
  312|       |  EMP_WRAP_EACH_64(W, __VA_ARGS__) \
  313|       |  EMP_EVAL5( EMP_WRAP_EACH_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  314|       |#define EMP_WRAP_EACH_256(W, ...) \
  315|       |  EMP_WRAP_EACH_128(W, __VA_ARGS__) \
  316|       |  EMP_EVAL6( EMP_WRAP_EACH_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  317|       |#define EMP_WRAP_EACH_512(W, ...) \
  318|       |  EMP_WRAP_EACH_256(W, __VA_ARGS__) \
  319|       |  EMP_EVAL7( EMP_WRAP_EACH_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  320|       |/// @endcond
  321|       |
  322|       |/// EMP_WRAP_EACH_1ARG, wraps each argument in the specified macro wrapper, with added first arg.
  323|       |#define EMP_WRAP_EACH_1ARG(W, ARG, ...) EMP_CALL_BY_PACKS(EMP_WRAP_EACH_1ARG_, (W, ARG), __VA_ARGS__)
  324|       |/// @cond MACROS
  325|       |#define EMP_WRAP_EACH_1ARG_1(P, A, ...) EMP_GET_ARG_1 P (EMP_GET_ARG_2 P, A)
  326|       |#define EMP_WRAP_EACH_1ARG_2(P, A,B,...) EMP_WRAP_EACH_1ARG_1(P, A, ~)         \
  327|       |                                              EMP_WRAP_EACH_1ARG_1(P, B, ~)
  328|       |#define EMP_WRAP_EACH_1ARG_4(P, A,B,...) EMP_WRAP_EACH_1ARG_2(P, A, B, ~)      \
  329|       |                                              EMP_WRAP_EACH_1ARG_2(P, __VA_ARGS__)
  330|       |#define EMP_WRAP_EACH_1ARG_8(P, ...)                                                \
  331|       |  EMP_WRAP_EACH_1ARG_4(P, __VA_ARGS__)                                              \
  332|       |  EMP_EVAL1( EMP_WRAP_EACH_1ARG_4 EMP_EMPTY() (P, EMP_POP_ARGS_4(__VA_ARGS__)) )
  333|       |#define EMP_WRAP_EACH_1ARG_16(P, ...)                                               \
  334|       |  EMP_WRAP_EACH_1ARG_8(P, __VA_ARGS__)                                              \
  335|       |  EMP_EVAL2( EMP_WRAP_EACH_1ARG_8 EMP_EMPTY() (P, EMP_POP_ARGS_8(__VA_ARGS__)) )
  336|       |#define EMP_WRAP_EACH_1ARG_32(P, ...)                                               \
  337|       |  EMP_WRAP_EACH_1ARG_16(P, __VA_ARGS__)                                             \
  338|       |  EMP_EVAL3( EMP_WRAP_EACH_1ARG_16 EMP_EMPTY() (P, EMP_POP_ARGS_16(__VA_ARGS__)) )
  339|       |#define EMP_WRAP_EACH_1ARG_64(P, ...)                                               \
  340|       |  EMP_WRAP_EACH_1ARG_32(P, __VA_ARGS__)                                             \
  341|       |  EMP_EVAL4( EMP_WRAP_EACH_1ARG_32 EMP_EMPTY() (P, EMP_POP_ARGS_32(__VA_ARGS__)) )
  342|       |#define EMP_WRAP_EACH_1ARG_128(P, ...)                                              \
  343|       |  EMP_WRAP_EACH_1ARG_64(P, __VA_ARGS__)                                             \
  344|       |  EMP_EVAL5( EMP_WRAP_EACH_1ARG_64 EMP_EMPTY() (P, EMP_POP_ARGS_64(__VA_ARGS__)) )
  345|       |#define EMP_WRAP_EACH_1ARG_256(P, ...)                                              \
  346|       |  EMP_WRAP_EACH_1ARG_128(P, __VA_ARGS__)                                            \
  347|       |  EMP_EVAL6( EMP_WRAP_EACH_1ARG_128 EMP_EMPTY() (P, EMP_POP_ARGS_128(__VA_ARGS__)) )
  348|       |#define EMP_WRAP_EACH_1ARG_512(P, ...)                                              \
  349|       |  EMP_WRAP_EACH_1ARG_256(P, __VA_ARGS__)                                            \
  350|       |  EMP_EVAL7( EMP_WRAP_EACH_1ARG_256 EMP_EMPTY() (P, EMP_POP_ARGS_256(__VA_ARGS__)) )
  351|       |/// @endcond
  352|       |
  353|       |/// imilar to EMP_WRAP_EACH, but puts a COMMA between each arg pair.
  354|      0|#define EMP_WRAP_ARGS(W, ...) EMP_POP_ARGS_1( ~ EMP_CALL_BY_PACKS(EMP_WRAP_ARGS_, W, __VA_ARGS__) )
  355|       |/// @cond MACROS
  356|       |#define EMP_WRAP_ARGS_1(W, A, ...) , W(A)
  357|       |#define EMP_WRAP_ARGS_2(W, A,B,...) EMP_WRAP_ARGS_1(W, A, ~) EMP_WRAP_ARGS_1(W, B, ~)
  358|       |#define EMP_WRAP_ARGS_4(W, A,B,...) EMP_WRAP_ARGS_2(W, A, B, ~) EMP_WRAP_ARGS_2(W, __VA_ARGS__)
  359|       |#define EMP_WRAP_ARGS_8(W, ...)                                         \
  360|       |  EMP_WRAP_ARGS_4(W, __VA_ARGS__)                                       \
  361|       |  EMP_EVAL1( EMP_WRAP_ARGS_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  362|       |#define EMP_WRAP_ARGS_16(W, ...) \
  363|       |  EMP_WRAP_ARGS_8(W, __VA_ARGS__) \
  364|       |  EMP_EVAL2( EMP_WRAP_ARGS_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  365|       |#define EMP_WRAP_ARGS_32(W, ...) \
  366|       |  EMP_WRAP_ARGS_16(W, __VA_ARGS__) \
  367|       |  EMP_EVAL3( EMP_WRAP_ARGS_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  368|       |#define EMP_WRAP_ARGS_64(W, ...) \
  369|       |  EMP_WRAP_ARGS_32(W, __VA_ARGS__) \
  370|       |  EMP_EVAL4( EMP_WRAP_ARGS_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  371|       |#define EMP_WRAP_ARGS_128(W, ...) \
  372|       |  EMP_WRAP_ARGS_64(W, __VA_ARGS__) \
  373|       |  EMP_EVAL5( EMP_WRAP_ARGS_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  374|       |#define EMP_WRAP_ARGS_256(W, ...) \
  375|       |  EMP_WRAP_ARGS_128(W, __VA_ARGS__) \
  376|       |  EMP_EVAL6( EMP_WRAP_ARGS_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  377|       |#define EMP_WRAP_ARGS_512(W, ...) \
  378|       |  EMP_WRAP_ARGS_256(W, __VA_ARGS__) \
  379|       |  EMP_EVAL7( EMP_WRAP_ARGS_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  380|       |/// @endcond
  381|       |
  382|       |#define EMP_WRAP_ARGS_1ARG(W, ARG, ...) \
  383|       |  EMP_POP_ARGS_1( ~ EMP_CALL_BY_PACKS(EMP_WRAP_ARGS_1ARG_, (W, ARG), __VA_ARGS__) )
  384|       |/// @cond MACROS
  385|       |#define EMP_WRAP_ARGS_1ARG_1(P, A, ...) , EMP_GET_ARG_1 P (EMP_GET_ARG_2 P, A)
  386|       |#define EMP_WRAP_ARGS_1ARG_2(P, A,B,...) EMP_WRAP_ARGS_1ARG_1(P, A, ~) EMP_WRAP_ARGS_1ARG_1(P, B, ~)
  387|       |#define EMP_WRAP_ARGS_1ARG_4(P, A,B,...) EMP_WRAP_ARGS_1ARG_2(P, A, B, ~) EMP_WRAP_ARGS_1ARG_2(P, __VA_ARGS__)
  388|       |#define EMP_WRAP_ARGS_1ARG_8(P, ...)                                         \
  389|       |  EMP_WRAP_ARGS_1ARG_4(P, __VA_ARGS__)                                       \
  390|       |  EMP_EVAL1( EMP_WRAP_ARGS_1ARG_4 EMP_EMPTY() (P, EMP_POP_ARGS_4(__VA_ARGS__)) )
  391|       |#define EMP_WRAP_ARGS_1ARG_16(P, ...) \
  392|       |  EMP_WRAP_ARGS_1ARG_8(P, __VA_ARGS__) \
  393|       |  EMP_EVAL2( EMP_WRAP_ARGS_1ARG_8 EMP_EMPTY() (P, EMP_POP_ARGS_8(__VA_ARGS__)) )
  394|       |#define EMP_WRAP_ARGS_1ARG_32(P, ...) \
  395|       |  EMP_WRAP_ARGS_1ARG_16(P, __VA_ARGS__) \
  396|       |  EMP_EVAL3( EMP_WRAP_ARGS_1ARG_16 EMP_EMPTY() (P, EMP_POP_ARGS_16(__VA_ARGS__)) )
  397|       |#define EMP_WRAP_ARGS_1ARG_64(P, ...) \
  398|       |  EMP_WRAP_ARGS_1ARG_32(P, __VA_ARGS__) \
  399|       |  EMP_EVAL4( EMP_WRAP_ARGS_1ARG_32 EMP_EMPTY() (P, EMP_POP_ARGS_32(__VA_ARGS__)) )
  400|       |#define EMP_WRAP_ARGS_1ARG_128(P, ...) \
  401|       |  EMP_WRAP_ARGS_1ARG_64(P, __VA_ARGS__) \
  402|       |  EMP_EVAL5( EMP_WRAP_ARGS_1ARG_64 EMP_EMPTY() (P, EMP_POP_ARGS_64(__VA_ARGS__)) )
  403|       |#define EMP_WRAP_ARGS_1ARG_256(P, ...) \
  404|       |  EMP_WRAP_ARGS_1ARG_128(P, __VA_ARGS__) \
  405|       |  EMP_EVAL6( EMP_WRAP_ARGS_1ARG_128 EMP_EMPTY() (P, EMP_POP_ARGS_128(__VA_ARGS__)) )
  406|       |#define EMP_WRAP_ARGS_1ARG_512(P, ...) \
  407|       |  EMP_WRAP_ARGS_1ARG_256(P, __VA_ARGS__) \
  408|       |  EMP_EVAL7( EMP_WRAP_ARGS_1ARG_256 EMP_EMPTY() (P, EMP_POP_ARGS_256(__VA_ARGS__)) )
  409|       |/// @endcond
  410|       |
  411|       |/// Replace all of the commas in an argument set with something else (including nothing)
  412|       |/// @cond MACROS
  413|       |#define EMP_REMOVE_COMMAS(...) EMP_REPLACE_COMMAS(,__VA_ARGS__)
  414|       |/// @endcond
  415|       |#define EMP_REPLACE_COMMAS(X, ...) EMP_GET_ARG_1(__VA_ARGS__) EMP_CALL_BY_PACKS(EMP_REPLACE_COMMAS_, X, EMP_POP_ARGS_1(__VA_ARGS__) )
  416|       |
  417|       |/// @cond MACROS
  418|       |#define EMP_REPLACE_COMMAS_1(X, A, ...) X A
  419|       |#define EMP_REPLACE_COMMAS_2(X, A,B, ...) X A X B
  420|       |#define EMP_REPLACE_COMMAS_4(X, A,B,C,D, ...) X A X B X C X D
  421|       |#define EMP_REPLACE_COMMAS_8(X, A,B,C,D,E,F,G,H, ...) X A X B X C X D X E X F X G X H
  422|       |#define EMP_REPLACE_COMMAS_16(X, ...) \
  423|       |  EMP_REPLACE_COMMAS_8(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_8(__VA_ARGS__) )
  424|       |#define EMP_REPLACE_COMMAS_32(X, ...) \
  425|       |  EMP_REPLACE_COMMAS_16(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_16(__VA_ARGS__) )
  426|       |#define EMP_REPLACE_COMMAS_64(X, ...) \
  427|       |  EMP_REPLACE_COMMAS_32(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_32(__VA_ARGS__) )
  428|       |#define EMP_REPLACE_COMMAS_128(X, ...) \
  429|       |  EMP_REPLACE_COMMAS_64(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_64(__VA_ARGS__) )
  430|       |#define EMP_REPLACE_COMMAS_256(X, ...) \
  431|       |  EMP_REPLACE_COMMAS_128(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_128(__VA_ARGS__) )
  432|       |#define EMP_REPLACE_COMMAS_512(X, ...) \
  433|       |  EMP_REPLACE_COMMAS_256(__VA_ARGS__) X EMP_REPLACE_COMMAS( EMP_POP_ARGS_256(__VA_ARGS__) )
  434|       |/// @endcond
  435|       |
  436|       |/// Keep only the first N args (assumes at least N args exist!)
  437|       |#define EMP_CROP_ARGS_TO(N, ...) EMP_POP_ARG(~ EMP_CALL_BY_PACKS_impl(EMP_CROP_ARGS_TO_, ~, EMP_DEC_TO_PACK(N), __VA_ARGS__, ~))
  438|       |/// @cond MACROS
  439|       |#define EMP_CROP_ARGS_TO_1(W, A, ...) , A
  440|       |#define EMP_CROP_ARGS_TO_2(W, A,B,...) , A , B
  441|       |#define EMP_CROP_ARGS_TO_4(W, A,B,...) EMP_CROP_ARGS_TO_2(W, A,B,~) EMP_CROP_ARGS_TO_2(W,__VA_ARGS__)
  442|       |#define EMP_CROP_ARGS_TO_8(W, ...) EMP_CROP_ARGS_TO_4(W, __VA_ARGS__) EMP_EVAL1( EMP_CROP_ARGS_TO_4 EMP_EMPTY() (W, EMP_POP_ARGS_4(__VA_ARGS__)) )
  443|       |#define EMP_CROP_ARGS_TO_16(W, ...) EMP_CROP_ARGS_TO_8(W, __VA_ARGS__) EMP_EVAL2( EMP_CROP_ARGS_TO_8 EMP_EMPTY() (W, EMP_POP_ARGS_8(__VA_ARGS__)) )
  444|       |#define EMP_CROP_ARGS_TO_32(W, ...) EMP_CROP_ARGS_TO_16(W, __VA_ARGS__) EMP_EVAL3( EMP_CROP_ARGS_TO_16 EMP_EMPTY() (W, EMP_POP_ARGS_16(__VA_ARGS__)) )
  445|       |#define EMP_CROP_ARGS_TO_64(W, ...) EMP_CROP_ARGS_TO_32(W, __VA_ARGS__) EMP_EVAL4( EMP_CROP_ARGS_TO_32 EMP_EMPTY() (W, EMP_POP_ARGS_32(__VA_ARGS__)) )
  446|       |#define EMP_CROP_ARGS_TO_128(W, ...) EMP_CROP_ARGS_TO_64(W, __VA_ARGS__) EMP_EVAL5( EMP_CROP_ARGS_TO_64 EMP_EMPTY() (W, EMP_POP_ARGS_64(__VA_ARGS__)) )
  447|       |#define EMP_CROP_ARGS_TO_256(W, ...) EMP_CROP_ARGS_TO_128(W, __VA_ARGS__) EMP_EVAL6( EMP_CROP_ARGS_TO_128 EMP_EMPTY() (W, EMP_POP_ARGS_128(__VA_ARGS__)) )
  448|       |#define EMP_CROP_ARGS_TO_512(W, ...) EMP_CROP_ARGS_TO_256(W, __VA_ARGS__) EMP_EVAL7( EMP_CROP_ARGS_TO_256 EMP_EMPTY() (W, EMP_POP_ARGS_256(__VA_ARGS__)) )
  449|       |/// @endcond
  450|       |
  451|       |/// Force arguments to a specific number.  If less, pad them; if more crop them.
  452|       |#define EMP_FORCE_ARGS_TO(N, PAD, ...) EMP_CROP_ARGS_TO(N, __VA_ARGS__, EMP_DUPLICATE_ARGS(N, PAD))
  453|       |
  454|       |#define EMP_ROTATE_ARGS(A, ...) __VA_ARGS__, A
  455|       |#define EMP_RUN_JOIN(A, B) A B
  456|       |
  457|       |#define EMP_PERMUTE(...) EMP_ASSEMBLE_MACRO(EMP_PERMUTE_, __VA_ARGS__)
  458|       |/// @cond MACROS
  459|       |#define EMP_PERMUTE_1(A1) (A1)
  460|       |#define EMP_PERMUTE_2(A1,A2) (A1,A2),(A2,A1)
  461|       |#define EMP_PERMUTE_3(A1,A2,A3) (A1,A2,A3),(A2,A1,A3),(A1,A3,A2),(A2,A3,A1),(A3,A1,A2),(A3,A2,A1)
  462|       |#define EMP_PERMUTE_4(A1,A2,A3,A4) EMP_PACKS_PUSH_ALL(A1, EMP_PERMUTE_3(A2,A3,A4)), \
  463|       |                                   EMP_PACKS_PUSH_ALL(A2, EMP_PERMUTE_3(A1,A3,A4)), \
  464|       |                                   EMP_PACKS_PUSH_ALL(A3, EMP_PERMUTE_3(A1,A2,A4)), \
  465|       |                                   EMP_PACKS_PUSH_ALL(A4, EMP_PERMUTE_3(A1,A2,A3))
  466|       |#define EMP_PERMUTE_5(A1,A2,A3,A4,A5) EMP_PACKS_PUSH_ALL(A1, EMP_PERMUTE_4(A2,A3,A4,A5)), \
  467|       |                                      EMP_PACKS_PUSH_ALL(A2, EMP_PERMUTE_4(A1,A3,A4,A5)), \
  468|       |                                      EMP_PACKS_PUSH_ALL(A3, EMP_PERMUTE_4(A1,A2,A4,A5)), \
  469|       |                                      EMP_PACKS_PUSH_ALL(A4, EMP_PERMUTE_4(A1,A2,A3,A5)), \
  470|       |                                      EMP_PACKS_PUSH_ALL(A5, EMP_PERMUTE_4(A1,A2,A3,A4))
  471|       |///@endcond
  472|       |
  473|       |/// A generic technique to trim the arguments we have.  In parens, list i or x for each
  474|       |/// position and whether it should be included or excluded.  For example
  475|       |///
  476|       |/// EMP_SELECT_ARGS( (i,x,x,i,i), 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 )
  477|       |///
  478|       |/// ... would return:
  479|       |///
  480|       |/// 1,4,5,6,9,10,11,14,15
  481|       |
  482|       |#define EMP_SELECT_i(A, ...) , A
  483|       |#define EMP_SELECT_x(A, ...)
  484|       |
  485|       |#define EMP_SELECT_do_arg(P, A) EMP_IMERGE_2(EMP_SELECT_, EMP_RUN_JOIN(EMP_GET_ARG_1, P))(A,~)
  486|       |
  487|       |#define EMP_SELECT_ARGS(PATTERN, ...) EMP_POP_ARG( ~ EMP_ASSEMBLE_MACRO_1ARG(EMP_SELECT_ARGS_, PATTERN, __VA_ARGS__) )
  488|       |
  489|       |/// @cond MACROS
  490|       |#define EMP_SELECT_ARGS_1(P, A) EMP_SELECT_do_arg(P, A)
  491|       |#define EMP_SELECT_ARGS_2(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_1( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  492|       |#define EMP_SELECT_ARGS_3(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_2( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  493|       |#define EMP_SELECT_ARGS_4(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_3( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  494|       |#define EMP_SELECT_ARGS_5(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_4( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  495|       |#define EMP_SELECT_ARGS_6(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_5( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  496|       |#define EMP_SELECT_ARGS_7(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_6( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  497|       |#define EMP_SELECT_ARGS_8(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_7( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  498|       |#define EMP_SELECT_ARGS_9(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_8( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  499|       |#define EMP_SELECT_ARGS_10(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_9( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  500|       |#define EMP_SELECT_ARGS_11(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_10( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  501|       |#define EMP_SELECT_ARGS_12(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_11( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  502|       |#define EMP_SELECT_ARGS_13(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_12( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  503|       |#define EMP_SELECT_ARGS_14(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_13( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  504|       |#define EMP_SELECT_ARGS_15(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_14( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  505|       |#define EMP_SELECT_ARGS_16(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_15( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  506|       |#define EMP_SELECT_ARGS_17(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_16( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  507|       |#define EMP_SELECT_ARGS_18(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_17( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  508|       |#define EMP_SELECT_ARGS_19(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_18( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  509|       |#define EMP_SELECT_ARGS_20(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_19( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  510|       |#define EMP_SELECT_ARGS_21(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_20( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  511|       |#define EMP_SELECT_ARGS_22(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_21( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  512|       |#define EMP_SELECT_ARGS_23(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_22( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  513|       |#define EMP_SELECT_ARGS_24(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_23( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  514|       |#define EMP_SELECT_ARGS_25(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_24( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  515|       |#define EMP_SELECT_ARGS_26(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_25( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  516|       |#define EMP_SELECT_ARGS_27(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_26( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  517|       |#define EMP_SELECT_ARGS_28(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_27( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  518|       |#define EMP_SELECT_ARGS_29(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_28( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  519|       |#define EMP_SELECT_ARGS_30(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_29( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  520|       |#define EMP_SELECT_ARGS_31(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_30( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  521|       |#define EMP_SELECT_ARGS_32(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_31( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  522|       |#define EMP_SELECT_ARGS_33(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_32( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  523|       |#define EMP_SELECT_ARGS_34(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_33( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  524|       |#define EMP_SELECT_ARGS_35(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_34( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  525|       |#define EMP_SELECT_ARGS_36(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_35( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  526|       |#define EMP_SELECT_ARGS_37(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_36( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  527|       |#define EMP_SELECT_ARGS_38(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_37( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  528|       |#define EMP_SELECT_ARGS_39(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_38( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  529|       |#define EMP_SELECT_ARGS_40(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_39( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  530|       |#define EMP_SELECT_ARGS_41(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_40( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  531|       |#define EMP_SELECT_ARGS_42(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_41( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  532|       |#define EMP_SELECT_ARGS_43(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_42( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  533|       |#define EMP_SELECT_ARGS_44(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_43( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  534|       |#define EMP_SELECT_ARGS_45(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_44( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  535|       |#define EMP_SELECT_ARGS_46(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_45( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  536|       |#define EMP_SELECT_ARGS_47(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_46( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  537|       |#define EMP_SELECT_ARGS_48(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_47( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  538|       |#define EMP_SELECT_ARGS_49(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_48( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  539|       |#define EMP_SELECT_ARGS_50(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_49( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  540|       |#define EMP_SELECT_ARGS_51(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_50( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  541|       |#define EMP_SELECT_ARGS_52(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_51( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  542|       |#define EMP_SELECT_ARGS_53(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_52( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  543|       |#define EMP_SELECT_ARGS_54(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_53( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  544|       |#define EMP_SELECT_ARGS_55(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_54( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  545|       |#define EMP_SELECT_ARGS_56(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_55( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  546|       |#define EMP_SELECT_ARGS_57(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_56( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  547|       |#define EMP_SELECT_ARGS_58(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_57( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  548|       |#define EMP_SELECT_ARGS_59(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_58( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  549|       |#define EMP_SELECT_ARGS_60(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_59( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  550|       |#define EMP_SELECT_ARGS_61(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_60( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  551|       |#define EMP_SELECT_ARGS_62(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_61( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  552|       |#define EMP_SELECT_ARGS_63(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_62( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  553|       |#define EMP_SELECT_ARGS_64(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_63( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  554|       |#define EMP_SELECT_ARGS_65(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_64( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  555|       |#define EMP_SELECT_ARGS_66(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_65( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  556|       |#define EMP_SELECT_ARGS_67(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_66( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  557|       |#define EMP_SELECT_ARGS_68(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_67( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  558|       |#define EMP_SELECT_ARGS_69(P, A, ...) EMP_SELECT_do_arg(P, A)EMP_SELECT_ARGS_68( (EMP_ROTATE_ARGS P), __VA_ARGS__ )
  559|       |/// @endcond
  560|       |
  561|       |/// Get all even numbered args
  562|       |#define EMP_GET_EVEN_ARGS(...) EMP_SELECT_ARGS((x,i), __VA_ARGS__)
  563|       |/// Get all odd numbered args
  564|       |#define EMP_GET_ODD_ARGS(...) EMP_SELECT_ARGS((i,x), __VA_ARGS__)
  565|       |
  566|       |
  567|       |/// Enable an arbitrary number of arguments (well, up to 10) to be merged BEFORE being processed!
  568|       |#define EMP_MERGE(...) EMP_ASSEMBLE_MACRO(EMP_MERGE_, __VA_ARGS__)
  569|       |
  570|       |/// Enable an arbitrary number of arguments (well, up to 10) to be INDIRECTLY merged, that is,
  571|       |/// AFTER being processed!
  572|       |#define EMP_IMERGE(...) EMP_ASSEMBLE_MACRO(EMP_IMERGE_, __VA_ARGS__)
  573|       |
  574|       |/// @cond MACROS
  575|       |#define EMP_MERGE_1(A1) A1
  576|       |#define EMP_MERGE_2(A1,A2) A1 ## A2
  577|       |#define EMP_MERGE_3(A1,A2,A3) A1 ## A2 ## A3
  578|       |#define EMP_MERGE_4(A1,A2,A3,A4) A1 ## A2 ## A3 ## A4
  579|       |#define EMP_MERGE_5(A1,A2,A3,A4,A5) A1 ## A2 ## A3 ## A4 ## A5
  580|       |#define EMP_MERGE_6(A1,A2,A3,A4,A5,A6) A1 ## A2 ## A3 ## A4 ## A5 ## A6
  581|       |#define EMP_MERGE_7(A1,A2,A3,A4,A5,A6,A7) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7
  582|       |#define EMP_MERGE_8(A1,A2,A3,A4,A5,A6,A7,A8) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8
  583|       |#define EMP_MERGE_9(A1,A2,A3,A4,A5,A6,A7,A8,A9) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8 ## A9
  584|       |#define EMP_MERGE_10(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) A1 ## A2 ## A3 ## A4 ## A5 ## A6 ## A7 ## A8 ## A9 ## A10
  585|       |
  586|       |// Indirect merges to give a chance for arg evaluation...
  587|       |
  588|       |#define EMP_IMERGE_1(A1) EMP_MERGE_1(A1)
  589|       |#define EMP_IMERGE_2(A1,A2) EMP_MERGE_2(A1, A2)
  590|       |#define EMP_IMERGE_3(A1,A2,A3) EMP_MERGE_3(A1, A2, A3)
  591|       |#define EMP_IMERGE_4(A1,A2,A3,A4) EMP_MERGE_4(A1, A2, A3, A4)
  592|       |#define EMP_IMERGE_5(A1,A2,A3,A4,A5) EMP_MERGE_5(A1, A2, A3, A4, A5)
  593|       |#define EMP_IMERGE_6(A1,A2,A3,A4,A5,A6) EMP_MERGE_6(A1, A2, A3, A4, A5, A6)
  594|       |#define EMP_IMERGE_7(A1,A2,A3,A4,A5,A6,A7) EMP_MERGE_7(A1, A2, A3, A4, A5, A6, A7)
  595|       |#define EMP_IMERGE_8(A1,A2,A3,A4,A5,A6,A7,A8) EMP_MERGE_8(A1, A2, A3, A4, A5, A6, A7, A8)
  596|       |#define EMP_IMERGE_9(A1,A2,A3,A4,A5,A6,A7,A8,A9) EMP_MERGE_9(A1, A2, A3, A4, A5, A6, A7, A8, A9)
  597|       |#define EMP_IMERGE_10(A1,A2,A3,A4,A5,A6,A7,A8,A9,A10) EMP_MERGE_10(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10)
  598|       |
  599|       |/// @endcond
  600|       |
  601|       |// EMP_WRAP_EACH takes a wrapper macro and a variable set of arguments,
  602|       |// then applied to wrapper macro to each argument in order.
  603|       |//#define EMP_WRAP_EACH(W, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_LAYOUT_, W, , __VA_ARGS__)
  604|       |
  605|       |/// Similar to EMP_WRAP_EACH, but puts a P between each arg pair.
  606|       |/// EMP_LAYOUT takes a wrapper macro and padding information, wraps each argument in the macro
  607|       |/// and then spaces them out with the padding.
  608|       |/// W = Wrapper macro name, P = Padding between results
  609|       |#define EMP_LAYOUT(W, P, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_LAYOUT_, W, P, __VA_ARGS__)
  610|       |/// @cond MACROS
  611|       |#define EMP_LAYOUT_0(W, P)
  612|       |#define EMP_LAYOUT_1(W, P, A) W(A)
  613|       |#define EMP_LAYOUT_2(W, P, A, ...) W(A) P EMP_LAYOUT_1(W, P, __VA_ARGS__)
  614|       |#define EMP_LAYOUT_3(W, P, A, ...) W(A) P EMP_LAYOUT_2(W, P, __VA_ARGS__)
  615|       |#define EMP_LAYOUT_4(W, P, A, ...) W(A) P EMP_LAYOUT_3(W, P, __VA_ARGS__)
  616|       |#define EMP_LAYOUT_5(W, P, A, ...) W(A) P EMP_LAYOUT_4(W, P, __VA_ARGS__)
  617|       |#define EMP_LAYOUT_6(W, P, A, ...) W(A) P EMP_LAYOUT_5(W, P, __VA_ARGS__)
  618|       |#define EMP_LAYOUT_7(W, P, A, ...) W(A) P EMP_LAYOUT_6(W, P, __VA_ARGS__)
  619|       |#define EMP_LAYOUT_8(W, P, A, ...) W(A) P EMP_LAYOUT_7(W, P, __VA_ARGS__)
  620|       |#define EMP_LAYOUT_9(W, P, A, ...) W(A) P EMP_LAYOUT_8(W, P, __VA_ARGS__)
  621|       |#define EMP_LAYOUT_10(W, P, A, ...) W(A) P EMP_LAYOUT_9(W, P, __VA_ARGS__)
  622|       |#define EMP_LAYOUT_11(W, P, A, ...) W(A) P EMP_LAYOUT_10(W, P, __VA_ARGS__)
  623|       |#define EMP_LAYOUT_12(W, P, A, ...) W(A) P EMP_LAYOUT_11(W, P, __VA_ARGS__)
  624|       |#define EMP_LAYOUT_13(W, P, A, ...) W(A) P EMP_LAYOUT_12(W, P, __VA_ARGS__)
  625|       |#define EMP_LAYOUT_14(W, P, A, ...) W(A) P EMP_LAYOUT_13(W, P, __VA_ARGS__)
  626|       |#define EMP_LAYOUT_15(W, P, A, ...) W(A) P EMP_LAYOUT_14(W, P, __VA_ARGS__)
  627|       |#define EMP_LAYOUT_16(W, P, A, ...) W(A) P EMP_LAYOUT_15(W, P, __VA_ARGS__)
  628|       |#define EMP_LAYOUT_17(W, P, A, ...) W(A) P EMP_LAYOUT_16(W, P, __VA_ARGS__)
  629|       |#define EMP_LAYOUT_18(W, P, A, ...) W(A) P EMP_LAYOUT_17(W, P, __VA_ARGS__)
  630|       |#define EMP_LAYOUT_19(W, P, A, ...) W(A) P EMP_LAYOUT_18(W, P, __VA_ARGS__)
  631|       |#define EMP_LAYOUT_20(W, P, A, ...) W(A) P EMP_LAYOUT_19(W, P, __VA_ARGS__)
  632|       |#define EMP_LAYOUT_21(W, P, A, ...) W(A) P EMP_LAYOUT_20(W, P, __VA_ARGS__)
  633|       |#define EMP_LAYOUT_22(W, P, A, ...) W(A) P EMP_LAYOUT_21(W, P, __VA_ARGS__)
  634|       |#define EMP_LAYOUT_23(W, P, A, ...) W(A) P EMP_LAYOUT_22(W, P, __VA_ARGS__)
  635|       |#define EMP_LAYOUT_24(W, P, A, ...) W(A) P EMP_LAYOUT_23(W, P, __VA_ARGS__)
  636|       |#define EMP_LAYOUT_25(W, P, A, ...) W(A) P EMP_LAYOUT_24(W, P, __VA_ARGS__)
  637|       |#define EMP_LAYOUT_26(W, P, A, ...) W(A) P EMP_LAYOUT_25(W, P, __VA_ARGS__)
  638|       |#define EMP_LAYOUT_27(W, P, A, ...) W(A) P EMP_LAYOUT_26(W, P, __VA_ARGS__)
  639|       |#define EMP_LAYOUT_28(W, P, A, ...) W(A) P EMP_LAYOUT_27(W, P, __VA_ARGS__)
  640|       |#define EMP_LAYOUT_29(W, P, A, ...) W(A) P EMP_LAYOUT_28(W, P, __VA_ARGS__)
  641|       |#define EMP_LAYOUT_30(W, P, A, ...) W(A) P EMP_LAYOUT_29(W, P, __VA_ARGS__)
  642|       |#define EMP_LAYOUT_31(W, P, A, ...) W(A) P EMP_LAYOUT_30(W, P, __VA_ARGS__)
  643|       |#define EMP_LAYOUT_32(W, P, A, ...) W(A) P EMP_LAYOUT_31(W, P, __VA_ARGS__)
  644|       |#define EMP_LAYOUT_33(W, P, A, ...) W(A) P EMP_LAYOUT_32(W, P, __VA_ARGS__)
  645|       |#define EMP_LAYOUT_34(W, P, A, ...) W(A) P EMP_LAYOUT_33(W, P, __VA_ARGS__)
  646|       |#define EMP_LAYOUT_35(W, P, A, ...) W(A) P EMP_LAYOUT_34(W, P, __VA_ARGS__)
  647|       |#define EMP_LAYOUT_36(W, P, A, ...) W(A) P EMP_LAYOUT_35(W, P, __VA_ARGS__)
  648|       |#define EMP_LAYOUT_37(W, P, A, ...) W(A) P EMP_LAYOUT_36(W, P, __VA_ARGS__)
  649|       |#define EMP_LAYOUT_38(W, P, A, ...) W(A) P EMP_LAYOUT_37(W, P, __VA_ARGS__)
  650|       |#define EMP_LAYOUT_39(W, P, A, ...) W(A) P EMP_LAYOUT_38(W, P, __VA_ARGS__)
  651|       |#define EMP_LAYOUT_40(W, P, A, ...) W(A) P EMP_LAYOUT_39(W, P, __VA_ARGS__)
  652|       |#define EMP_LAYOUT_41(W, P, A, ...) W(A) P EMP_LAYOUT_40(W, P, __VA_ARGS__)
  653|       |#define EMP_LAYOUT_42(W, P, A, ...) W(A) P EMP_LAYOUT_41(W, P, __VA_ARGS__)
  654|       |#define EMP_LAYOUT_43(W, P, A, ...) W(A) P EMP_LAYOUT_42(W, P, __VA_ARGS__)
  655|       |#define EMP_LAYOUT_44(W, P, A, ...) W(A) P EMP_LAYOUT_43(W, P, __VA_ARGS__)
  656|       |#define EMP_LAYOUT_45(W, P, A, ...) W(A) P EMP_LAYOUT_44(W, P, __VA_ARGS__)
  657|       |#define EMP_LAYOUT_46(W, P, A, ...) W(A) P EMP_LAYOUT_45(W, P, __VA_ARGS__)
  658|       |#define EMP_LAYOUT_47(W, P, A, ...) W(A) P EMP_LAYOUT_46(W, P, __VA_ARGS__)
  659|       |#define EMP_LAYOUT_48(W, P, A, ...) W(A) P EMP_LAYOUT_47(W, P, __VA_ARGS__)
  660|       |#define EMP_LAYOUT_49(W, P, A, ...) W(A) P EMP_LAYOUT_48(W, P, __VA_ARGS__)
  661|       |#define EMP_LAYOUT_50(W, P, A, ...) W(A) P EMP_LAYOUT_49(W, P, __VA_ARGS__)
  662|       |#define EMP_LAYOUT_51(W, P, A, ...) W(A) P EMP_LAYOUT_50(W, P, __VA_ARGS__)
  663|       |#define EMP_LAYOUT_52(W, P, A, ...) W(A) P EMP_LAYOUT_51(W, P, __VA_ARGS__)
  664|       |#define EMP_LAYOUT_53(W, P, A, ...) W(A) P EMP_LAYOUT_52(W, P, __VA_ARGS__)
  665|       |#define EMP_LAYOUT_54(W, P, A, ...) W(A) P EMP_LAYOUT_53(W, P, __VA_ARGS__)
  666|       |#define EMP_LAYOUT_55(W, P, A, ...) W(A) P EMP_LAYOUT_54(W, P, __VA_ARGS__)
  667|       |#define EMP_LAYOUT_56(W, P, A, ...) W(A) P EMP_LAYOUT_55(W, P, __VA_ARGS__)
  668|       |#define EMP_LAYOUT_57(W, P, A, ...) W(A) P EMP_LAYOUT_56(W, P, __VA_ARGS__)
  669|       |#define EMP_LAYOUT_58(W, P, A, ...) W(A) P EMP_LAYOUT_57(W, P, __VA_ARGS__)
  670|       |#define EMP_LAYOUT_59(W, P, A, ...) W(A) P EMP_LAYOUT_58(W, P, __VA_ARGS__)
  671|       |#define EMP_LAYOUT_60(W, P, A, ...) W(A) P EMP_LAYOUT_59(W, P, __VA_ARGS__)
  672|       |#define EMP_LAYOUT_61(W, P, A, ...) W(A) P EMP_LAYOUT_60(W, P, __VA_ARGS__)
  673|       |#define EMP_LAYOUT_62(W, P, A, ...) W(A) P EMP_LAYOUT_61(W, P, __VA_ARGS__)
  674|       |#define EMP_LAYOUT_63(W, P, A, ...) W(A) P EMP_LAYOUT_62(W, P, __VA_ARGS__)
  675|       |/// @endcond
  676|       |
  677|       |// Wrap C different arguments.
  678|       |#define EMP_WRAP_ARGSET(W, C, ...) EMP_ASSEMBLE_MACRO_2ARG(EMP_WRAP_ARGS_, W, C, __VA_ARGS__)
  679|       |/// @cond MACROS
  680|       |#define EMP_WRAP_ARGSET_0(W, C, ...)
  681|       |#define EMP_WRAP_ARGSET_1(W, C, ...) W( EMP_CROP_ARGS_TO(C, __VA_ARGS__) ), \
  682|       |                                                                                                     EMP_MERGE_2( EMP_WRAP_ARGSET_, EMP_SUB_1_ ## C ) (W, C, EMP_CROP_OFF(C, __VA_ARGS__) )
  683|       |#define EMP_WRAP_ARGSET_2(W, C, ...) W(A), EMP_WRAP_ARGSET_1(W, C, __VA_ARGS__)
  684|       |#define EMP_WRAP_ARGSET_3(W, C, ...) W(A), EMP_WRAP_ARGSET_2(W, C, __VA_ARGS__)
  685|       |/// @endcond
  686|       |
  687|       |/// Individually stringifies each variable passed to it and returns them
  688|       |/// with commas in between.
  689|       |#define EMP_STRINGIFY_EACH(...) EMP_WRAP_ARGS(EMP_STRINGIFY, __VA_ARGS__)
  690|       |
  691|       |/// Similar to EMP_WRAP_ARGS, but passes pairs of args into W.
  692|       |#define EMP_WRAP_ARG_PAIRS(W, ...) EMP_ASSEMBLE_MACRO_1ARG(EMP_WRAP_ARG_PAIRS_, W, __VA_ARGS__)
  693|       |/// @cond MACROS
  694|       |#define EMP_WRAP_ARG_PAIRS_2(W, A1, A2) W(A1, A2)
  695|       |#define EMP_WRAP_ARG_PAIRS_4(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_2(W, __VA_ARGS__)
  696|       |#define EMP_WRAP_ARG_PAIRS_6(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_4(W, __VA_ARGS__)
  697|       |#define EMP_WRAP_ARG_PAIRS_8(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_6(W, __VA_ARGS__)
  698|       |#define EMP_WRAP_ARG_PAIRS_10(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_8(W, __VA_ARGS__)
  699|       |#define EMP_WRAP_ARG_PAIRS_12(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_10(W, __VA_ARGS__)
  700|       |#define EMP_WRAP_ARG_PAIRS_14(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_12(W, __VA_ARGS__)
  701|       |#define EMP_WRAP_ARG_PAIRS_16(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_14(W, __VA_ARGS__)
  702|       |#define EMP_WRAP_ARG_PAIRS_18(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_16(W, __VA_ARGS__)
  703|       |#define EMP_WRAP_ARG_PAIRS_20(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_18(W, __VA_ARGS__)
  704|       |#define EMP_WRAP_ARG_PAIRS_22(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_20(W, __VA_ARGS__)
  705|       |#define EMP_WRAP_ARG_PAIRS_24(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_22(W, __VA_ARGS__)
  706|       |#define EMP_WRAP_ARG_PAIRS_26(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_24(W, __VA_ARGS__)
  707|       |#define EMP_WRAP_ARG_PAIRS_28(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_26(W, __VA_ARGS__)
  708|       |#define EMP_WRAP_ARG_PAIRS_30(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_28(W, __VA_ARGS__)
  709|       |#define EMP_WRAP_ARG_PAIRS_32(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_30(W, __VA_ARGS__)
  710|       |#define EMP_WRAP_ARG_PAIRS_34(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_32(W, __VA_ARGS__)
  711|       |#define EMP_WRAP_ARG_PAIRS_36(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_34(W, __VA_ARGS__)
  712|       |#define EMP_WRAP_ARG_PAIRS_38(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_36(W, __VA_ARGS__)
  713|       |#define EMP_WRAP_ARG_PAIRS_40(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_38(W, __VA_ARGS__)
  714|       |#define EMP_WRAP_ARG_PAIRS_42(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_40(W, __VA_ARGS__)
  715|       |#define EMP_WRAP_ARG_PAIRS_44(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_42(W, __VA_ARGS__)
  716|       |#define EMP_WRAP_ARG_PAIRS_46(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_44(W, __VA_ARGS__)
  717|       |#define EMP_WRAP_ARG_PAIRS_48(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_46(W, __VA_ARGS__)
  718|       |#define EMP_WRAP_ARG_PAIRS_50(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_48(W, __VA_ARGS__)
  719|       |#define EMP_WRAP_ARG_PAIRS_52(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_50(W, __VA_ARGS__)
  720|       |#define EMP_WRAP_ARG_PAIRS_54(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_52(W, __VA_ARGS__)
  721|       |#define EMP_WRAP_ARG_PAIRS_56(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_54(W, __VA_ARGS__)
  722|       |#define EMP_WRAP_ARG_PAIRS_58(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_56(W, __VA_ARGS__)
  723|       |#define EMP_WRAP_ARG_PAIRS_60(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_58(W, __VA_ARGS__)
  724|       |#define EMP_WRAP_ARG_PAIRS_62(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_60(W, __VA_ARGS__)
  725|       |#define EMP_WRAP_ARG_PAIRS_64(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_62(W, __VA_ARGS__)
  726|       |#define EMP_WRAP_ARG_PAIRS_66(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_64(W, __VA_ARGS__)
  727|       |#define EMP_WRAP_ARG_PAIRS_68(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_66(W, __VA_ARGS__)
  728|       |#define EMP_WRAP_ARG_PAIRS_70(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_68(W, __VA_ARGS__)
  729|       |#define EMP_WRAP_ARG_PAIRS_72(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_70(W, __VA_ARGS__)
  730|       |#define EMP_WRAP_ARG_PAIRS_74(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_72(W, __VA_ARGS__)
  731|       |#define EMP_WRAP_ARG_PAIRS_76(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_74(W, __VA_ARGS__)
  732|       |#define EMP_WRAP_ARG_PAIRS_78(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_76(W, __VA_ARGS__)
  733|       |#define EMP_WRAP_ARG_PAIRS_80(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_78(W, __VA_ARGS__)
  734|       |#define EMP_WRAP_ARG_PAIRS_82(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_80(W, __VA_ARGS__)
  735|       |#define EMP_WRAP_ARG_PAIRS_84(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_82(W, __VA_ARGS__)
  736|       |#define EMP_WRAP_ARG_PAIRS_86(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_84(W, __VA_ARGS__)
  737|       |#define EMP_WRAP_ARG_PAIRS_88(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_86(W, __VA_ARGS__)
  738|       |#define EMP_WRAP_ARG_PAIRS_90(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_88(W, __VA_ARGS__)
  739|       |#define EMP_WRAP_ARG_PAIRS_92(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_90(W, __VA_ARGS__)
  740|       |#define EMP_WRAP_ARG_PAIRS_94(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_92(W, __VA_ARGS__)
  741|       |#define EMP_WRAP_ARG_PAIRS_96(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_94(W, __VA_ARGS__)
  742|       |#define EMP_WRAP_ARG_PAIRS_98(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_96(W, __VA_ARGS__)
  743|       |#define EMP_WRAP_ARG_PAIRS_100(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_98(W, __VA_ARGS__)
  744|       |#define EMP_WRAP_ARG_PAIRS_102(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_100(W, __VA_ARGS__)
  745|       |#define EMP_WRAP_ARG_PAIRS_104(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_102(W, __VA_ARGS__)
  746|       |#define EMP_WRAP_ARG_PAIRS_106(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_104(W, __VA_ARGS__)
  747|       |#define EMP_WRAP_ARG_PAIRS_108(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_106(W, __VA_ARGS__)
  748|       |#define EMP_WRAP_ARG_PAIRS_110(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_108(W, __VA_ARGS__)
  749|       |#define EMP_WRAP_ARG_PAIRS_112(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_110(W, __VA_ARGS__)
  750|       |#define EMP_WRAP_ARG_PAIRS_114(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_112(W, __VA_ARGS__)
  751|       |#define EMP_WRAP_ARG_PAIRS_116(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_114(W, __VA_ARGS__)
  752|       |#define EMP_WRAP_ARG_PAIRS_118(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_116(W, __VA_ARGS__)
  753|       |#define EMP_WRAP_ARG_PAIRS_120(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_118(W, __VA_ARGS__)
  754|       |#define EMP_WRAP_ARG_PAIRS_122(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_120(W, __VA_ARGS__)
  755|       |#define EMP_WRAP_ARG_PAIRS_124(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_122(W, __VA_ARGS__)
  756|       |#define EMP_WRAP_ARG_PAIRS_126(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_124(W, __VA_ARGS__)
  757|       |#define EMP_WRAP_ARG_PAIRS_128(W, A1, A2, ...) W(A1, A2), EMP_WRAP_ARG_PAIRS_126(W, __VA_ARGS__)
  758|       |/// @endcond
  759|       |
  760|       |#define EMP_WRAP_ARG_TRIPLES(W, ...) EMP_ASSEMBLE_MACRO_1ARG(EMP_WRAP_ARG_TRIPLES_, W, __VA_ARGS__)
  761|       |/// @cond MACROS
  762|       |#define EMP_WRAP_ARG_TRIPLES_3(W, A,B,C) W(A, B, C)
  763|       |#define EMP_WRAP_ARG_TRIPLES_6(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_3(W, __VA_ARGS__)
  764|       |#define EMP_WRAP_ARG_TRIPLES_9(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_6(W, __VA_ARGS__)
  765|       |#define EMP_WRAP_ARG_TRIPLES_12(W, A,B,C, ...) W(A,B,C), EMP_WRAP_ARG_TRIPLES_9(W, __VA_ARGS__)
  766|       |/// @endcond
  767|       |
  768|       |/// Reverse the order of arguments passed in.
  769|       |#define EMP_REVERSE_ARGS(...) EMP_ASSEMBLE_MACRO(EMP_REVERSE_ARGS_, __VA_ARGS__)
  770|       |/// @cond MACROS
  771|       |#define EMP_REVERSE_ARGS_1(A) A
  772|       |#define EMP_REVERSE_ARGS_2(A, ...) EMP_REVERSE_ARGS_1(__VA_ARGS__), A
  773|       |#define EMP_REVERSE_ARGS_3(A, ...) EMP_REVERSE_ARGS_2(__VA_ARGS__), A
  774|       |#define EMP_REVERSE_ARGS_4(A, ...) EMP_REVERSE_ARGS_3(__VA_ARGS__), A
  775|       |#define EMP_REVERSE_ARGS_5(A, ...) EMP_REVERSE_ARGS_4(__VA_ARGS__), A
  776|       |#define EMP_REVERSE_ARGS_6(A, ...) EMP_REVERSE_ARGS_5(__VA_ARGS__), A
  777|       |#define EMP_REVERSE_ARGS_7(A, ...) EMP_REVERSE_ARGS_6(__VA_ARGS__), A
  778|       |#define EMP_REVERSE_ARGS_8(A, ...) EMP_REVERSE_ARGS_7(__VA_ARGS__), A
  779|       |#define EMP_REVERSE_ARGS_9(A, ...) EMP_REVERSE_ARGS_8(__VA_ARGS__), A
  780|       |#define EMP_REVERSE_ARGS_10(A, ...) EMP_REVERSE_ARGS_9(__VA_ARGS__), A
  781|       |#define EMP_REVERSE_ARGS_11(A, ...) EMP_REVERSE_ARGS_10(__VA_ARGS__), A
  782|       |#define EMP_REVERSE_ARGS_12(A, ...) EMP_REVERSE_ARGS_11(__VA_ARGS__), A
  783|       |#define EMP_REVERSE_ARGS_13(A, ...) EMP_REVERSE_ARGS_12(__VA_ARGS__), A
  784|       |#define EMP_REVERSE_ARGS_14(A, ...) EMP_REVERSE_ARGS_13(__VA_ARGS__), A
  785|       |#define EMP_REVERSE_ARGS_15(A, ...) EMP_REVERSE_ARGS_14(__VA_ARGS__), A
  786|       |#define EMP_REVERSE_ARGS_16(A, ...) EMP_REVERSE_ARGS_15(__VA_ARGS__), A
  787|       |#define EMP_REVERSE_ARGS_17(A, ...) EMP_REVERSE_ARGS_16(__VA_ARGS__), A
  788|       |#define EMP_REVERSE_ARGS_18(A, ...) EMP_REVERSE_ARGS_17(__VA_ARGS__), A
  789|       |#define EMP_REVERSE_ARGS_19(A, ...) EMP_REVERSE_ARGS_18(__VA_ARGS__), A
  790|       |#define EMP_REVERSE_ARGS_20(A, ...) EMP_REVERSE_ARGS_19(__VA_ARGS__), A
  791|       |#define EMP_REVERSE_ARGS_21(A, ...) EMP_REVERSE_ARGS_20(__VA_ARGS__), A
  792|       |#define EMP_REVERSE_ARGS_22(A, ...) EMP_REVERSE_ARGS_21(__VA_ARGS__), A
  793|       |#define EMP_REVERSE_ARGS_23(A, ...) EMP_REVERSE_ARGS_22(__VA_ARGS__), A
  794|       |#define EMP_REVERSE_ARGS_24(A, ...) EMP_REVERSE_ARGS_23(__VA_ARGS__), A
  795|       |#define EMP_REVERSE_ARGS_25(A, ...) EMP_REVERSE_ARGS_24(__VA_ARGS__), A
  796|       |#define EMP_REVERSE_ARGS_26(A, ...) EMP_REVERSE_ARGS_25(__VA_ARGS__), A
  797|       |#define EMP_REVERSE_ARGS_27(A, ...) EMP_REVERSE_ARGS_26(__VA_ARGS__), A
  798|       |#define EMP_REVERSE_ARGS_28(A, ...) EMP_REVERSE_ARGS_27(__VA_ARGS__), A
  799|       |#define EMP_REVERSE_ARGS_29(A, ...) EMP_REVERSE_ARGS_28(__VA_ARGS__), A
  800|       |#define EMP_REVERSE_ARGS_30(A, ...) EMP_REVERSE_ARGS_29(__VA_ARGS__), A
  801|       |#define EMP_REVERSE_ARGS_31(A, ...) EMP_REVERSE_ARGS_30(__VA_ARGS__), A
  802|       |#define EMP_REVERSE_ARGS_32(A, ...) EMP_REVERSE_ARGS_31(__VA_ARGS__), A
  803|       |#define EMP_REVERSE_ARGS_33(A, ...) EMP_REVERSE_ARGS_32(__VA_ARGS__), A
  804|       |#define EMP_REVERSE_ARGS_34(A, ...) EMP_REVERSE_ARGS_33(__VA_ARGS__), A
  805|       |#define EMP_REVERSE_ARGS_35(A, ...) EMP_REVERSE_ARGS_34(__VA_ARGS__), A
  806|       |#define EMP_REVERSE_ARGS_36(A, ...) EMP_REVERSE_ARGS_35(__VA_ARGS__), A
  807|       |#define EMP_REVERSE_ARGS_37(A, ...) EMP_REVERSE_ARGS_36(__VA_ARGS__), A
  808|       |#define EMP_REVERSE_ARGS_38(A, ...) EMP_REVERSE_ARGS_37(__VA_ARGS__), A
  809|       |#define EMP_REVERSE_ARGS_39(A, ...) EMP_REVERSE_ARGS_38(__VA_ARGS__), A
  810|       |#define EMP_REVERSE_ARGS_40(A, ...) EMP_REVERSE_ARGS_39(__VA_ARGS__), A
  811|       |#define EMP_REVERSE_ARGS_41(A, ...) EMP_REVERSE_ARGS_40(__VA_ARGS__), A
  812|       |#define EMP_REVERSE_ARGS_42(A, ...) EMP_REVERSE_ARGS_41(__VA_ARGS__), A
  813|       |#define EMP_REVERSE_ARGS_43(A, ...) EMP_REVERSE_ARGS_42(__VA_ARGS__), A
  814|       |#define EMP_REVERSE_ARGS_44(A, ...) EMP_REVERSE_ARGS_43(__VA_ARGS__), A
  815|       |#define EMP_REVERSE_ARGS_45(A, ...) EMP_REVERSE_ARGS_44(__VA_ARGS__), A
  816|       |#define EMP_REVERSE_ARGS_46(A, ...) EMP_REVERSE_ARGS_45(__VA_ARGS__), A
  817|       |#define EMP_REVERSE_ARGS_47(A, ...) EMP_REVERSE_ARGS_46(__VA_ARGS__), A
  818|       |#define EMP_REVERSE_ARGS_48(A, ...) EMP_REVERSE_ARGS_47(__VA_ARGS__), A
  819|       |#define EMP_REVERSE_ARGS_49(A, ...) EMP_REVERSE_ARGS_48(__VA_ARGS__), A
  820|       |#define EMP_REVERSE_ARGS_50(A, ...) EMP_REVERSE_ARGS_49(__VA_ARGS__), A
  821|       |#define EMP_REVERSE_ARGS_51(A, ...) EMP_REVERSE_ARGS_50(__VA_ARGS__), A
  822|       |#define EMP_REVERSE_ARGS_52(A, ...) EMP_REVERSE_ARGS_51(__VA_ARGS__), A
  823|       |#define EMP_REVERSE_ARGS_53(A, ...) EMP_REVERSE_ARGS_52(__VA_ARGS__), A
  824|       |#define EMP_REVERSE_ARGS_54(A, ...) EMP_REVERSE_ARGS_53(__VA_ARGS__), A
  825|       |#define EMP_REVERSE_ARGS_55(A, ...) EMP_REVERSE_ARGS_54(__VA_ARGS__), A
  826|       |#define EMP_REVERSE_ARGS_56(A, ...) EMP_REVERSE_ARGS_55(__VA_ARGS__), A
  827|       |#define EMP_REVERSE_ARGS_57(A, ...) EMP_REVERSE_ARGS_56(__VA_ARGS__), A
  828|       |#define EMP_REVERSE_ARGS_58(A, ...) EMP_REVERSE_ARGS_57(__VA_ARGS__), A
  829|       |#define EMP_REVERSE_ARGS_59(A, ...) EMP_REVERSE_ARGS_58(__VA_ARGS__), A
  830|       |#define EMP_REVERSE_ARGS_60(A, ...) EMP_REVERSE_ARGS_59(__VA_ARGS__), A
  831|       |#define EMP_REVERSE_ARGS_61(A, ...) EMP_REVERSE_ARGS_60(__VA_ARGS__), A
  832|       |#define EMP_REVERSE_ARGS_62(A, ...) EMP_REVERSE_ARGS_61(__VA_ARGS__), A
  833|       |#define EMP_REVERSE_ARGS_63(A, ...) EMP_REVERSE_ARGS_62(__VA_ARGS__), A
  834|       |#define EMP_REVERSE_ARGS_64(A, ...) EMP_REVERSE_ARGS_63(__VA_ARGS__), A
  835|       |/// @endcond
  836|       |
  837|       |#define EMP_TYPES_TO_ARGS(...) EMP_ASSEMBLE_MACRO(EMP_TYPES_TO_ARGS_, EMP_REVERSE_ARGS(__VA_ARGS__))
  838|       |/// @cond MACROS
  839|       |#define EMP_TYPES_TO_ARGS_1(A) A arg1
  840|       |#define EMP_TYPES_TO_ARGS_2(A, ...) EMP_TYPES_TO_ARGS_1(__VA_ARGS__), A arg2
  841|       |#define EMP_TYPES_TO_ARGS_3(A, ...) EMP_TYPES_TO_ARGS_2(__VA_ARGS__), A arg3
  842|       |#define EMP_TYPES_TO_ARGS_4(A, ...) EMP_TYPES_TO_ARGS_3(__VA_ARGS__), A arg4
  843|       |#define EMP_TYPES_TO_ARGS_5(A, ...) EMP_TYPES_TO_ARGS_4(__VA_ARGS__), A arg5
  844|       |#define EMP_TYPES_TO_ARGS_6(A, ...) EMP_TYPES_TO_ARGS_5(__VA_ARGS__), A arg6
  845|       |#define EMP_TYPES_TO_ARGS_7(A, ...) EMP_TYPES_TO_ARGS_6(__VA_ARGS__), A arg7
  846|       |#define EMP_TYPES_TO_ARGS_8(A, ...) EMP_TYPES_TO_ARGS_7(__VA_ARGS__), A arg8
  847|       |#define EMP_TYPES_TO_ARGS_9(A, ...) EMP_TYPES_TO_ARGS_8(__VA_ARGS__), A arg9
  848|       |#define EMP_TYPES_TO_ARGS_10(A, ...) EMP_TYPES_TO_ARGS_9(__VA_ARGS__), A arg10
  849|       |#define EMP_TYPES_TO_ARGS_11(A, ...) EMP_TYPES_TO_ARGS_10(__VA_ARGS__), A arg11
  850|       |#define EMP_TYPES_TO_ARGS_12(A, ...) EMP_TYPES_TO_ARGS_11(__VA_ARGS__), A arg12
  851|       |#define EMP_TYPES_TO_ARGS_13(A, ...) EMP_TYPES_TO_ARGS_12(__VA_ARGS__), A arg13
  852|       |#define EMP_TYPES_TO_ARGS_14(A, ...) EMP_TYPES_TO_ARGS_13(__VA_ARGS__), A arg14
  853|       |#define EMP_TYPES_TO_ARGS_15(A, ...) EMP_TYPES_TO_ARGS_14(__VA_ARGS__), A arg15
  854|       |#define EMP_TYPES_TO_ARGS_16(A, ...) EMP_TYPES_TO_ARGS_15(__VA_ARGS__), A arg16
  855|       |#define EMP_TYPES_TO_ARGS_17(A, ...) EMP_TYPES_TO_ARGS_16(__VA_ARGS__), A arg17
  856|       |#define EMP_TYPES_TO_ARGS_18(A, ...) EMP_TYPES_TO_ARGS_17(__VA_ARGS__), A arg18
  857|       |#define EMP_TYPES_TO_ARGS_19(A, ...) EMP_TYPES_TO_ARGS_18(__VA_ARGS__), A arg19
  858|       |#define EMP_TYPES_TO_ARGS_20(A, ...) EMP_TYPES_TO_ARGS_19(__VA_ARGS__), A arg20
  859|       |#define EMP_TYPES_TO_ARGS_21(A, ...) EMP_TYPES_TO_ARGS_20(__VA_ARGS__), A arg21
  860|       |#define EMP_TYPES_TO_ARGS_22(A, ...) EMP_TYPES_TO_ARGS_21(__VA_ARGS__), A arg22
  861|       |#define EMP_TYPES_TO_ARGS_23(A, ...) EMP_TYPES_TO_ARGS_22(__VA_ARGS__), A arg23
  862|       |#define EMP_TYPES_TO_ARGS_24(A, ...) EMP_TYPES_TO_ARGS_23(__VA_ARGS__), A arg24
  863|       |#define EMP_TYPES_TO_ARGS_25(A, ...) EMP_TYPES_TO_ARGS_24(__VA_ARGS__), A arg25
  864|       |#define EMP_TYPES_TO_ARGS_26(A, ...) EMP_TYPES_TO_ARGS_25(__VA_ARGS__), A arg26
  865|       |#define EMP_TYPES_TO_ARGS_27(A, ...) EMP_TYPES_TO_ARGS_26(__VA_ARGS__), A arg27
  866|       |#define EMP_TYPES_TO_ARGS_28(A, ...) EMP_TYPES_TO_ARGS_27(__VA_ARGS__), A arg28
  867|       |#define EMP_TYPES_TO_ARGS_29(A, ...) EMP_TYPES_TO_ARGS_28(__VA_ARGS__), A arg29
  868|       |#define EMP_TYPES_TO_ARGS_30(A, ...) EMP_TYPES_TO_ARGS_29(__VA_ARGS__), A arg30
  869|       |#define EMP_TYPES_TO_ARGS_31(A, ...) EMP_TYPES_TO_ARGS_30(__VA_ARGS__), A arg31
  870|       |#define EMP_TYPES_TO_ARGS_32(A, ...) EMP_TYPES_TO_ARGS_31(__VA_ARGS__), A arg32
  871|       |#define EMP_TYPES_TO_ARGS_33(A, ...) EMP_TYPES_TO_ARGS_32(__VA_ARGS__), A arg33
  872|       |#define EMP_TYPES_TO_ARGS_34(A, ...) EMP_TYPES_TO_ARGS_33(__VA_ARGS__), A arg34
  873|       |#define EMP_TYPES_TO_ARGS_35(A, ...) EMP_TYPES_TO_ARGS_34(__VA_ARGS__), A arg35
  874|       |#define EMP_TYPES_TO_ARGS_36(A, ...) EMP_TYPES_TO_ARGS_35(__VA_ARGS__), A arg36
  875|       |#define EMP_TYPES_TO_ARGS_37(A, ...) EMP_TYPES_TO_ARGS_36(__VA_ARGS__), A arg37
  876|       |#define EMP_TYPES_TO_ARGS_38(A, ...) EMP_TYPES_TO_ARGS_37(__VA_ARGS__), A arg38
  877|       |#define EMP_TYPES_TO_ARGS_39(A, ...) EMP_TYPES_TO_ARGS_38(__VA_ARGS__), A arg39
  878|       |#define EMP_TYPES_TO_ARGS_40(A, ...) EMP_TYPES_TO_ARGS_39(__VA_ARGS__), A arg40
  879|       |#define EMP_TYPES_TO_ARGS_41(A, ...) EMP_TYPES_TO_ARGS_40(__VA_ARGS__), A arg41
  880|       |#define EMP_TYPES_TO_ARGS_42(A, ...) EMP_TYPES_TO_ARGS_41(__VA_ARGS__), A arg42
  881|       |#define EMP_TYPES_TO_ARGS_43(A, ...) EMP_TYPES_TO_ARGS_42(__VA_ARGS__), A arg43
  882|       |#define EMP_TYPES_TO_ARGS_44(A, ...) EMP_TYPES_TO_ARGS_43(__VA_ARGS__), A arg44
  883|       |#define EMP_TYPES_TO_ARGS_45(A, ...) EMP_TYPES_TO_ARGS_44(__VA_ARGS__), A arg45
  884|       |#define EMP_TYPES_TO_ARGS_46(A, ...) EMP_TYPES_TO_ARGS_45(__VA_ARGS__), A arg46
  885|       |#define EMP_TYPES_TO_ARGS_47(A, ...) EMP_TYPES_TO_ARGS_46(__VA_ARGS__), A arg47
  886|       |#define EMP_TYPES_TO_ARGS_48(A, ...) EMP_TYPES_TO_ARGS_47(__VA_ARGS__), A arg48
  887|       |#define EMP_TYPES_TO_ARGS_49(A, ...) EMP_TYPES_TO_ARGS_48(__VA_ARGS__), A arg49
  888|       |#define EMP_TYPES_TO_ARGS_50(A, ...) EMP_TYPES_TO_ARGS_49(__VA_ARGS__), A arg50
  889|       |#define EMP_TYPES_TO_ARGS_51(A, ...) EMP_TYPES_TO_ARGS_50(__VA_ARGS__), A arg51
  890|       |#define EMP_TYPES_TO_ARGS_52(A, ...) EMP_TYPES_TO_ARGS_51(__VA_ARGS__), A arg52
  891|       |#define EMP_TYPES_TO_ARGS_53(A, ...) EMP_TYPES_TO_ARGS_52(__VA_ARGS__), A arg53
  892|       |#define EMP_TYPES_TO_ARGS_54(A, ...) EMP_TYPES_TO_ARGS_53(__VA_ARGS__), A arg54
  893|       |#define EMP_TYPES_TO_ARGS_55(A, ...) EMP_TYPES_TO_ARGS_54(__VA_ARGS__), A arg55
  894|       |#define EMP_TYPES_TO_ARGS_56(A, ...) EMP_TYPES_TO_ARGS_55(__VA_ARGS__), A arg56
  895|       |#define EMP_TYPES_TO_ARGS_57(A, ...) EMP_TYPES_TO_ARGS_56(__VA_ARGS__), A arg57
  896|       |#define EMP_TYPES_TO_ARGS_58(A, ...) EMP_TYPES_TO_ARGS_57(__VA_ARGS__), A arg58
  897|       |#define EMP_TYPES_TO_ARGS_59(A, ...) EMP_TYPES_TO_ARGS_58(__VA_ARGS__), A arg59
  898|       |#define EMP_TYPES_TO_ARGS_60(A, ...) EMP_TYPES_TO_ARGS_59(__VA_ARGS__), A arg60
  899|       |#define EMP_TYPES_TO_ARGS_61(A, ...) EMP_TYPES_TO_ARGS_60(__VA_ARGS__), A arg61
  900|       |#define EMP_TYPES_TO_ARGS_62(A, ...) EMP_TYPES_TO_ARGS_61(__VA_ARGS__), A arg62
  901|       |#define EMP_TYPES_TO_ARGS_63(A, ...) EMP_TYPES_TO_ARGS_62(__VA_ARGS__), A arg63
  902|       |/// @endcond
  903|       |
  904|       |/// EMP_ASSEMBLE_MACRO takes in a prefix and set of arguments and appends the size of the
  905|       |/// number of arguments to the prefix, and passes in all of the arguments.
  906|       |/// Setup a generic method of calling a specific version of a macro based on argument count.
  907|       |/// If some of the args need to be passed to each version, specify number in macro call.
  908|       |#define EMP_ASSEMBLE_MACRO(BASE, ...)                                   \
  909|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), __VA_ARGS__)
  910|       |
  911|       |///  EMP_ASSEMBLE_MACRO_1ARG assumes the first argument after the prefix should not count
  912|       |///  toward the size, but passed in anyway. (*_?ARG  works for more arguments up to 10).
  913|       |#define EMP_ASSEMBLE_MACRO_1ARG(BASE, A, ...)                           \
  914|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, __VA_ARGS__)
  915|       |
  916|       |/// @cond MACROS
  917|       |#define EMP_ASSEMBLE_MACRO_2ARG(BASE, A, B, ...)                         \
  918|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, __VA_ARGS__)
  919|       |
  920|       |#define EMP_ASSEMBLE_MACRO_3ARG(BASE, A, B, C, ...)                      \
  921|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, __VA_ARGS__)
  922|       |
  923|       |#define EMP_ASSEMBLE_MACRO_4ARG(BASE, A, B, C, D, ...)                   \
  924|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, __VA_ARGS__)
  925|       |
  926|       |#define EMP_ASSEMBLE_MACRO_5ARG(BASE, A, B, C, D, E, ...)                \
  927|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, __VA_ARGS__)
  928|       |
  929|       |#define EMP_ASSEMBLE_MACRO_6ARG(BASE, A, B, C, D, E, F, ...)             \
  930|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, __VA_ARGS__)
  931|       |
  932|       |#define EMP_ASSEMBLE_MACRO_7ARG(BASE, A, B, C, D, E, F, G, ...)          \
  933|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, G, __VA_ARGS__)
  934|       |
  935|       |#define EMP_ASSEMBLE_MACRO_8ARG(BASE, A, B, C, D, E, F, G, H, ...)       \
  936|       |  EMP_ASSEMBLE_IMPL(BASE, EMP_COUNT_ARGS(__VA_ARGS__), A, B, C, D, E, F, G, H, __VA_ARGS__)
  937|       |
  938|       |#define EMP_ASSEMBLE_IMPL(BASE, ARG_COUNT, ...) EMP_ASSEMBLE_MERGE(BASE, ARG_COUNT) (__VA_ARGS__)
  939|       |#define EMP_ASSEMBLE_MERGE(A, B) A ## B
  940|       |/// @endcond
  941|       |
  942|       |#endif
  943|       |

/home/emily/repos/Empirical_Tests/source/base/vector.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file vector.h
    7|       | *  @brief A drop-in wrapper for std::vector; adds on bounds checking in debug mode.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  This class is a drop-in wrapper for std::vector, adding on bounds checking.
   11|       | *  If EMP_NDEBUG is set then it reverts back to std::vector.
   12|       | *
   13|       | *  @todo Debug code: member functions that take iterators should also take emp iterators that verify
   14|       | *        whether those iterators are valid.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef EMP_VECTOR_H
   19|       |#define EMP_VECTOR_H
   20|       |
   21|       |#include <initializer_list>
   22|       |#include <iterator>
   23|       |#include <utility>
   24|       |#include <vector>
   25|       |
   26|       |#include "assert.h"
   27|       |
   28|       |#ifdef EMP_NDEBUG
   29|       |
   30|       |// Seemlessly translate emp::vector to std::vector
   31|       |namespace emp {
   32|       |  template <typename... Ts> using vector = std::vector<Ts...>;
   33|       |}
   34|       |
   35|       |
   36|       |#else // #EMP_NDEBUG *not* set
   37|       |
   38|       |namespace emp {
   39|       |
   40|       |  /// Build a debug wrapper emp::vector around std::vector.
   41|       |  template <typename T, typename... Ts>
   42|       |  class vector : public std::vector<T,Ts...> {
   43|       |  private:
   44|       |    using this_t = emp::vector<T,Ts...>;
   45|       |    using stdv_t = std::vector<T,Ts...>;
   46|       |
   47|       |    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.
   48|       |    constexpr static const size_t MAX_SIZE = 2000000001; // 2x10^9 + 1
   49|       |
   50|       |  public:
   51|       |    /// Setup a revision number - iterators must match the revision of their vector.
   52|       |    int revision;
   53|       |
   54|       |    /// Setup an iterator wrapper to make sure that they're not used again after a vector changes.
   55|       |    template<typename ITERATOR_T>
   56|       |    struct iterator_wrapper : public ITERATOR_T {
   57|       |      using this_t = iterator_wrapper<ITERATOR_T>;
   58|       |      using wrapped_t = ITERATOR_T;
   59|       |      using vec_t = emp::vector<T,Ts...>;
   60|       |
   61|       |      /// What vector and revision was this iterator created from?
   62|       |      const vec_t * v_ptr;
   63|       |      int revision;
   64|       |
   65|       |      // @CAO: For the moment cannot create an emp iterator from a base since we don't know vector to use.
   66|       |      // iterator_wrapper(const ITERATOR_T & _in)
   67|       |      //   : ITERATOR_T(_in), v_ptr(nullptr), revision(0) { ; }
   68|       |      /*_FORCE_COVER_START_*/iterator_wrapper(const ITERATOR_T & _in, const vec_t * _v)
   69|  10.5k|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEEC2ERKSB_PKS3_:
  |   69|     86|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS2_St6vectorIS2_SaIS2_EEEEEC2ERKSC_PKS3_:
  |   69|     46|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEEC2ERKS9_PKS1_:
  |   69|  2.90k|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKmSt6vectorImSaImEEEEEC2ERKSA_PKS1_:
  |   69|  5.55k|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS4_St6vectorIS4_SaIS4_EEEEEC2ERKSE_PKS5_:
  |   69|    588|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEC2ERKSA_PKS2_
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEC2ERKSB_PKS2_
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS9_St6vectorIS9_SaIS9_EEEEEC2ERKSI_PKSA_:
  |   69|      2|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS9_St6vectorIS9_SaIS9_EEEEEC2ERKSJ_PKSA_:
  |   69|      4|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEEC2ERKSD_PKS4_:
  |   69|     19|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS3_St6vectorIS3_SaIS3_EEEEEC2ERKSC_PKS4_:
  |   69|      3|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEEC2ERKSA_PKS1_:
  |   69|    655|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKdSt6vectorIdSaIdEEEEEC2ERKSA_PKS1_:
  |   69|     28|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEC2ERKSD_PKS5_:
  |   69|    370|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEC2ERKSB_PKS2_:
  |   69|     47|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEC2ERKS9_PKS1_:
  |   69|    145|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEC2ERKSA_PKS2_:
  |   69|     16|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEC2ERKSB_PKS2_:
  |   69|     64|        : ITERATOR_T(_in), v_ptr(_v), revision(_v->revision) { ; }/*_FORCE_COVER_END_*/
  ------------------
   70|       |      /*_FORCE_COVER_START_*/iterator_wrapper(const this_t &) = default/*_FORCE_COVER_END_*/;
   71|       |      /*_FORCE_COVER_START_*/iterator_wrapper(this_t &&) = default/*_FORCE_COVER_END_*/;
   72|  25.5k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEED2Ev:
  |   72|    258|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS2_St6vectorIS2_SaIS2_EEEEED2Ev:
  |   72|     92|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEED2Ev:
  |   72|  8.70k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKmSt6vectorImSaImEEEEED2Ev:
  |   72|  11.1k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS4_St6vectorIS4_SaIS4_EEEEED2Ev:
  |   72|  1.21k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEED2Ev
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEED2Ev
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS9_St6vectorIS9_SaIS9_EEEEED2Ev:
  |   72|      6|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS9_St6vectorIS9_SaIS9_EEEEED2Ev:
  |   72|      8|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEED2Ev:
  |   72|     42|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS3_St6vectorIS3_SaIS3_EEEEED2Ev:
  |   72|      6|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEED2Ev:
  |   72|  1.31k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKdSt6vectorIdSaIdEEEEED2Ev:
  |   72|     60|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEED2Ev:
  |   72|  1.11k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEED2Ev:
  |   72|    102|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEED2Ev:
  |   72|  1.32k|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEED2Ev:
  |   72|     48|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEED2Ev:
  |   72|    128|      /*_FORCE_COVER_START_*/~iterator_wrapper() { ; }/*_FORCE_COVER_END_*/
  ------------------
   73|       |
   74|       |      // Debug tools to make sure this iterator is okay.
   75|  6.94k|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
   76|  6.94k|        if (v_ptr == nullptr) return false;                // Invalid vector
   77|  6.94k|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
   78|  6.94k|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
   79|  6.94k|        size_t pos = (size_t) (*this - v_ptr->begin());
   80|  6.94k|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
   81|  6.94k|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
   82|  6.94k|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
   83|  6.94k|        return true;
   84|  6.94k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEE2OKEbb:
  |   75|     46|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     46|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     46|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     46|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     46|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     46|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     46|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     46|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     46|        return true;
  |   84|     46|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEE2OKEbb:
  |   75|  5.55k|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|  5.55k|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|  5.55k|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|  5.55k|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|  5.55k|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|  5.55k|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|  5.55k|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|  5.55k|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|  5.55k|        return true;
  |   84|  5.55k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS4_St6vectorIS4_SaIS4_EEEEE2OKEbb:
  |   75|     70|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     70|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     70|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     70|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     70|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     70|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     70|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     70|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     70|        return true;
  |   84|     70|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEE2OKEbb
  ------------------
  | _ZNK3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS9_St6vectorIS9_SaIS9_EEEEE2OKEbb:
  |   75|      4|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|      4|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|      4|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|      4|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|      4|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|      4|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|      4|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|      4|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|      4|        return true;
  |   84|      4|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEE2OKEbb:
  |   75|     14|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     14|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     14|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     14|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     14|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     14|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     14|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     14|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     14|        return true;
  |   84|     14|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS3_St6vectorIS3_SaIS3_EEEEE2OKEbb:
  |   75|      1|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|      1|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|      1|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|      1|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|      1|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|      1|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|      1|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|      1|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|      1|        return true;
  |   84|      1|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEE2OKEbb:
  |   75|     22|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     22|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     22|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     22|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     22|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     22|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     22|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     22|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     22|        return true;
  |   84|     22|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKdSt6vectorIdSaIdEEEEE2OKEbb:
  |   75|     24|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     24|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     24|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     24|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     24|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     24|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     24|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     24|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     24|        return true;
  |   84|     24|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEE2OKEbb:
  |   75|    480|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|    480|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|    480|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|    480|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|    480|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|    480|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|    480|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|    480|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|    480|        return true;
  |   84|    480|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_9TokenInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEE2OKEbb:
  |   75|     39|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     39|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     39|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     39|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     39|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     39|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     39|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     39|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     39|        return true;
  |   84|     39|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEE2OKEbb:
  |   75|    627|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|    627|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|    627|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|    627|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|    627|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|    627|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|    627|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|    627|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|    627|        return true;
  |   84|    627|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEE2OKEbb:
  |   75|     64|      /*_FORCE_COVER_START_*/bool OK(bool begin_ok=true, bool end_ok=true) const {
  |   76|     64|        if (v_ptr == nullptr) return false;                // Invalid vector
  |   77|     64|        if (v_ptr->revision == 0) return false;            // Vector has been deleted!
  |   78|     64|        if (revision != v_ptr->revision) return false;     // Vector has changed memory!
  |   79|     64|        size_t pos = (size_t) (*this - v_ptr->begin());
  |   80|     64|        if (pos > v_ptr->size()) return false;             // Iterator out of range.
  |   81|     64|        if (!begin_ok && pos == 0) return false;           // Iterator not allowed at beginning.
  |   82|     64|        if (!end_ok && pos == v_ptr->size()) return false; // Iterator not allowed at end.
  |   83|     64|        return true;
  |   84|     64|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEE2OKEbb
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_5Graph4NodeEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEE2OKEbb
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS6_St6vectorIS6_SaIS6_EEEEE2OKEbb
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEE2OKEbb
  ------------------
   85|       |
   86|       |      /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
   87|       |      /*_FORCE_COVER_START_*/this_t & operator=(this_t &&) = default/*_FORCE_COVER_END_*/;
   88|       |
   89|       |      /*_FORCE_COVER_START_*/operator ITERATOR_T() { return *this; }/*_FORCE_COVER_END_*/
   90|       |      /*_FORCE_COVER_START_*/operator const ITERATOR_T() const { return *this; }/*_FORCE_COVER_END_*/
   91|       |
   92|  3.47k|      /*_FORCE_COVER_START_*/auto & operator*() {
   93|  3.47k|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
   94|  3.47k|        return wrapped_t::operator*();
   95|  3.47k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEEdeEv:
  |   92|     23|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     23|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     23|        return wrapped_t::operator*();
  |   95|     23|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEEdeEv:
  |   92|  2.77k|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|  2.77k|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|  2.77k|        return wrapped_t::operator*();
  |   95|  2.77k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS4_St6vectorIS4_SaIS4_EEEEEdeEv:
  |   92|     35|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     35|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     35|        return wrapped_t::operator*();
  |   95|     35|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEdeEv
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS9_St6vectorIS9_SaIS9_EEEEEdeEv:
  |   92|      2|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|      2|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|      2|        return wrapped_t::operator*();
  |   95|      2|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEEdeEv:
  |   92|      7|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|      7|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|      7|        return wrapped_t::operator*();
  |   95|      7|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEEdeEv:
  |   92|     11|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     11|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     11|        return wrapped_t::operator*();
  |   95|     11|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKdSt6vectorIdSaIdEEEEEdeEv:
  |   92|     12|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     12|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     12|        return wrapped_t::operator*();
  |   95|     12|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEdeEv:
  |   92|    232|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|    232|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|    232|        return wrapped_t::operator*();
  |   95|    232|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEdeEv:
  |   92|     21|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     21|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     21|        return wrapped_t::operator*();
  |   95|     21|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEdeEv:
  |   92|    322|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|    322|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|    322|        return wrapped_t::operator*();
  |   95|    322|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEdeEv:
  |   92|     32|      /*_FORCE_COVER_START_*/auto & operator*() {
  |   93|     32|        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  |   94|     32|        return wrapped_t::operator*();
  |   95|     32|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEdeEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEEdeEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS6_St6vectorIS6_SaIS6_EEEEEdeEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEEdeEv
  ------------------
   96|       |      /*_FORCE_COVER_START_*/const auto & operator*() const {
   97|       |        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
   98|       |        return wrapped_t::operator*();
   99|       |      }/*_FORCE_COVER_END_*/
  100|       |
  101|       |      /*_FORCE_COVER_START_*/auto operator->() {
  102|       |        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  103|       |        return wrapped_t::operator->();
  104|       |      }/*_FORCE_COVER_END_*/
  105|       |      /*_FORCE_COVER_START_*/const auto operator->() const {
  106|       |        emp_assert(OK(true, false));  // Ensure vector hasn't changed since making iterator.
  107|       |        return wrapped_t::operator->();
  108|       |      }/*_FORCE_COVER_END_*/
  109|       |
  110|  3.29k|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEEppEv:
  |  110|     23|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPmSt6vectorImSaImEEEEEppEv:
  |  110|  2.77k|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS4_St6vectorIS4_SaIS4_EEEEEppEv:
  |  110|     35|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEppEv
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS9_St6vectorIS9_SaIS9_EEEEEppEv:
  |  110|      2|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS3_St6vectorIS3_SaIS3_EEEEEppEv:
  |  110|      7|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKiSt6vectorIiSaIiEEEEEppEv:
  |  110|     11|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKdSt6vectorIdSaIdEEEEEppEv:
  |  110|     12|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEppEv:
  |  110|    232|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPKS1_St6vectorIS1_SaIS1_EEEEEppEv:
  |  110|     18|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEppEv:
  |  110|    139|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEppEv:
  |  110|     32|      /*_FORCE_COVER_START_*/this_t & operator++() { emp_assert(OK(true,false)); wrapped_t::operator++(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS1_St6vectorIS1_SaIS1_EEEEEppEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS2_St6vectorIS2_SaIS2_EEEEEppEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS6_St6vectorIS6_SaIS6_EEEEEppEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPdSt6vectorIdSaIdEEEEEppEv
  ------------------
  111|       |      /*_FORCE_COVER_START_*/this_t operator++(int x) { emp_assert(OK(true,false)); return this_t(wrapped_t::operator++(x), v_ptr); }/*_FORCE_COVER_END_*/
  112|     43|      /*_FORCE_COVER_START_*/this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEmmEv:
  |  112|     43|      /*_FORCE_COVER_START_*/this_t & operator--() { emp_assert(OK(false,true)); wrapped_t::operator--(); return *this; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEmmEv
  ------------------
  113|       |      /*_FORCE_COVER_START_*/this_t operator--(int x) { emp_assert(OK(false,true)); return this_t(wrapped_t::operator--(x), v_ptr); }/*_FORCE_COVER_END_*/
  114|       |
  115|     46|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS3_St6vectorIS3_SaIS3_EEEEEplEi:
  |  115|      1|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEplEi:
  |  115|     12|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEplEi:
  |  115|     33|      /*_FORCE_COVER_START_*/auto operator+(int in) { emp_assert(OK()); return this_t(wrapped_t::operator+(in), v_ptr); }/*_FORCE_COVER_END_*/
  ------------------
  116|      0|      /*_FORCE_COVER_START_*/auto operator-(int in) { emp_assert(OK()); return this_t(wrapped_t::operator-(in), v_ptr); }/*_FORCE_COVER_END_*/
  117|     93|      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEmiERKSE_:
  |  117|      3|      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPiSt6vectorIiSaIiEEEEEmiERKSA_:
  |  117|     90|      /*_FORCE_COVER_START_*/auto operator-(const this_t & in) { emp_assert(OK()); return ((wrapped_t) *this) - (wrapped_t) in; }/*_FORCE_COVER_END_*/
  ------------------
  118|       |
  119|      1|      /*_FORCE_COVER_START_*/this_t & operator+=(int in) { emp_assert(OK()); wrapped_t::operator+=(in); return *this; }/*_FORCE_COVER_END_*/
  120|       |      /*_FORCE_COVER_START_*/this_t & operator-=(int in) { emp_assert(OK()); wrapped_t::operator-=(in); return *this; }/*_FORCE_COVER_END_*/
  121|       |      /*_FORCE_COVER_START_*/auto & operator[](int offset) { emp_assert(OK()); return wrapped_t::operator[](offset); }/*_FORCE_COVER_END_*/
  122|       |
  123|       |      //bool operator==(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator==(in); }
  124|       |      //bool operator!=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator!=(in); }
  125|       |
  126|       |      //bool operator< (const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator< (in); }
  127|       |      //bool operator<=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator<=(in); }
  128|       |      //bool operator> (const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator> (in); }
  129|       |      //bool operator>=(const wrapped_t & in) const { emp_assert(OK()); return wrapped_t::operator>=(in); }
  130|       |    };
  131|       |
  132|       |    using iterator = iterator_wrapper< typename stdv_t::iterator >;
  133|       |    using const_iterator = iterator_wrapper< typename stdv_t::const_iterator >;
  134|       |    using reverse_iterator = iterator_wrapper< typename stdv_t::reverse_iterator >;
  135|       |    using const_reverse_iterator = iterator_wrapper< typename stdv_t::const_reverse_iterator >;
  136|       |    using value_type = T;
  137|       |    using size_type = typename stdv_t::size_type;
  138|       |    using reference = typename stdv_t::reference;
  139|       |    using const_reference = typename stdv_t::const_reference;
  140|       |
  141|  1.56k|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorImJEEC2Ev:
  |  141|  1.44k|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIdJEEC2Ev:
  |  141|      2|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorISt8functionIFddEEJEEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEC2Ev:
  |  141|     29|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEEC2Ev:
  |  141|     74|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIP10TestClass1JEEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIiJEEC2Ev:
  |  141|      4|    /*_FORCE_COVER_START_*/vector() : stdv_t(), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_9DFAStatusEJEEC2Ev
  ------------------
  142|    235|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_4tNFAILm128EhE5StateEJEEC2ERKS4_:
  |  142|     28|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIhJEEC2ERKS1_:
  |  142|     53|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEEC2ERKS3_:
  |  142|     25|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_5Graph4NodeEJEEC2ERKS3_:
  |  142|      2|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEEC2ERKS2_
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEEC2ERKS1_
  ------------------
  | _ZN3emp6vectorIcJEEC2ERKS1_:
  |  142|     31|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEC2ERKS7_:
  |  142|      2|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIiJEEC2ERKS1_:
  |  142|     28|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorImJEEC2ERKS1_:
  |  142|     66|    /*_FORCE_COVER_START_*/vector(const this_t & _in) : stdv_t(_in), revision(1) {}/*_FORCE_COVER_END_*/;
  ------------------
  143|     74|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEEC2Em:
  |  143|     43|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_4tNFAILm128EhE5StateEJEEC2Em:
  |  143|     21|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEEC2Em
  ------------------
  | _ZN3emp6vectorIiJEEC2Em:
  |  143|      1|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIcJEEC2Em:
  |  143|      2|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEEC2Em:
  |  143|      7|    /*_FORCE_COVER_START_*/vector(size_t size) : stdv_t(size), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  144|     68|    /*_FORCE_COVER_START_*/vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIhJEEC2EmRKh:
  |  144|     64|    /*_FORCE_COVER_START_*/vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS0_IcJEEEJEEC2EmRKS1_:
  |  144|      2|    /*_FORCE_COVER_START_*/vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEEC2EmRKi:
  |  144|      2|    /*_FORCE_COVER_START_*/vector(size_t size, const T & val) : stdv_t(size, val), revision(1) { emp_assert(size < MAX_SIZE, size); }/*_FORCE_COVER_END_*/
  ------------------
  145|     12|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEEC2ESt16initializer_listIiE:
  |  145|      9|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEEC2ESt16initializer_listIdE:
  |  145|      1|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEEC2ESt16initializer_listImE:
  |  145|      1|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEEC2ESt16initializer_listIS1_E:
  |  145|      1|    /*_FORCE_COVER_START_*/vector(std::initializer_list<T> in_list) : stdv_t(in_list), revision(1) { ; }/*_FORCE_COVER_END_*/
  ------------------
  146|      1|    /*_FORCE_COVER_START_*/vector(const stdv_t & in) : stdv_t(in), revision(1) { ; }/*_FORCE_COVER_END_*/         // Emergency fallback conversion.
  147|       |    /*_FORCE_COVER_START_*/template <typename InputIt>
  148|      2|    /*_FORCE_COVER_START_*/vector(InputIt first, InputIt last) : stdv_t(first, last), revision(1) { ; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  149|  1.95k|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIhJEED2Ev:
  |  149|    117|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEED2Ev:
  |  149|     68|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_4tNFAILm128EhE5StateEJEED2Ev:
  |  149|     49|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_5Graph4NodeEJEED2Ev:
  |  149|      4|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIdJEED2Ev:
  |  149|      3|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEED2Ev
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorISt8functionIFddEEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIiJEED2Ev:
  |  149|     44|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEED2Ev:
  |  149|     74|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEED2Ev:
  |  149|     31|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIP10TestClass1JEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIcJEED2Ev:
  |  149|     33|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorINS0_IcJEEEJEED2Ev:
  |  149|      2|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorIPdJEED2Ev:
  |  149|      1|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | _ZN3emp6vectorImJEED2Ev:
  |  149|  1.52k|    /*_FORCE_COVER_START_*/~vector() { revision = 0; }/*_FORCE_COVER_END_*/ // Clear out revision when vector is deleted.
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_9DFAStatusEJEED2Ev
  ------------------
  150|       |
  151|  19.4k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE4sizeEv:
  |  151|     11|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_5arrayIiLm128EEEJEE4sizeEv:
  |  151|  3.60k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_4tNFAILm128EhE5StateEJEE4sizeEv:
  |  151|  1.81k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorImJEE4sizeEv:
  |  151|  11.1k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE4sizeEv:
  |  151|  1.22k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_5Graph4NodeEJEE4sizeEv:
  |  151|     69|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS0_IdJEEEJEE4sizeEv
  ------------------
  | _ZNK3emp6vectorISt8functionIFviiEEJEE4sizeEv:
  |  151|     29|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFddEEJEE4sizeEv:
  |  151|     44|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIdJEE4sizeEv:
  |  151|    108|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE4sizeEv:
  |  151|  1.17k|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_9TokenInfoEJEE4sizeEv:
  |  151|     78|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE4sizeEv:
  |  151|      2|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIPdJEE4sizeEv:
  |  151|    135|    /*_FORCE_COVER_START_*/size_t size() const { return stdv_t::size(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_9DFAStatusEJEE4sizeEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_7PtrInfoEJEE4sizeEv
  ------------------
  152|       |
  153|  1.73k|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE5beginEv:
  |  153|     43|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE5beginEv:
  |  153|  1.45k|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE5beginEv
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE5beginEv:
  |  153|      1|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE5beginEv:
  |  153|      1|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE5beginEv:
  |  153|    179|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE5beginEv:
  |  153|     56|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE5beginEv:
  |  153|      8|    /*_FORCE_COVER_START_*/iterator begin() noexcept { return iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEE5beginEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEE5beginEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE5beginEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEE5beginEv
  ------------------
  154|  6.97k|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_5arrayIiLm128EEEJEE5beginEv:
  |  154|     46|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorImJEE5beginEv:
  |  154|  5.55k|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE5beginEv:
  |  154|    569|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS0_IdJEEEJEE5beginEv
  ------------------
  | _ZNK3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE5beginEv:
  |  154|      4|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFviiEEJEE5beginEv:
  |  154|     17|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE5beginEv:
  |  154|    652|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIdJEE5beginEv:
  |  154|     26|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_9TokenInfoEJEE5beginEv:
  |  154|     43|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIPdJEE5beginEv:
  |  154|     64|    /*_FORCE_COVER_START_*/const_iterator begin() const noexcept { return const_iterator(stdv_t::begin(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_7PtrInfoEJEE5beginEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_5Graph4NodeEJEE5beginEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE5beginEv
  ------------------
  155|  1.72k|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE3endEv:
  |  155|     43|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE3endEv:
  |  155|  1.45k|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE3endEv
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE3endEv:
  |  155|      1|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE3endEv:
  |  155|    167|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE3endEv:
  |  155|     56|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIPdJEE3endEv:
  |  155|      8|    /*_FORCE_COVER_START_*/iterator end() noexcept { return iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEE3endEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEE3endEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE3endEv
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEE3endEv
  ------------------
  156|     30|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE3endEv:
  |  156|     19|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFviiEEJEE3endEv:
  |  156|      2|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEE3endEv:
  |  156|      3|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIdJEE3endEv:
  |  156|      2|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_9TokenInfoEJEE3endEv:
  |  156|      4|    /*_FORCE_COVER_START_*/const_iterator end() const noexcept { return const_iterator(stdv_t::end(), this); }/*_FORCE_COVER_END_*/
  ------------------
  157|       |
  158|       |    // operator stdv_t &() { return v; }
  159|       |    // operator const stdv_t &() const { return v; }
  160|       |
  161|    166|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  162|    166|      emp_assert(new_size < MAX_SIZE, new_size);
  163|    166|      stdv_t::resize(new_size);
  164|    166|      revision++;
  165|    166|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEE6resizeEm:
  |  161|     44|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  |  162|     44|      emp_assert(new_size < MAX_SIZE, new_size);
  |  163|     44|      stdv_t::resize(new_size);
  |  164|     44|      revision++;
  |  165|     44|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_4tNFAILm128EhE5StateEJEE6resizeEm:
  |  161|     88|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  |  162|     88|      emp_assert(new_size < MAX_SIZE, new_size);
  |  163|     88|      stdv_t::resize(new_size);
  |  164|     88|      revision++;
  |  165|     88|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIdJEE6resizeEm:
  |  161|     24|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  |  162|     24|      emp_assert(new_size < MAX_SIZE, new_size);
  |  163|     24|      stdv_t::resize(new_size);
  |  164|     24|      revision++;
  |  165|     24|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE6resizeEm:
  |  161|      8|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  |  162|      8|      emp_assert(new_size < MAX_SIZE, new_size);
  |  163|      8|      stdv_t::resize(new_size);
  |  164|      8|      revision++;
  |  165|      8|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE6resizeEm:
  |  161|      2|    /*_FORCE_COVER_START_*/void resize(size_t new_size) {
  |  162|      2|      emp_assert(new_size < MAX_SIZE, new_size);
  |  163|      2|      stdv_t::resize(new_size);
  |  164|      2|      revision++;
  |  165|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE6resizeEm
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEE6resizeEm
  ------------------
  166|    132|    /*_FORCE_COVER_START_*/void resize(size_t new_size, const T & val) {
  167|    132|      emp_assert(new_size < MAX_SIZE, new_size);
  168|    132|      stdv_t::resize(new_size, val);
  169|    132|      revision++;
  170|    132|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIhJEE6resizeEmRKh:
  |  166|    132|    /*_FORCE_COVER_START_*/void resize(size_t new_size, const T & val) {
  |  167|    132|      emp_assert(new_size < MAX_SIZE, new_size);
  |  168|    132|      stdv_t::resize(new_size, val);
  |  169|    132|      revision++;
  |  170|    132|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorIdJEE6resizeEmRKd
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEE6resizeEmRKS2_
  ------------------
  171|    146|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEEaSERKS3_:
  |  171|      8|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIhJEEaSERKS1_:
  |  171|      8|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_5Graph4NodeEJEEaSERKS3_
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEEaSERKS2_
  ------------------
  | _ZN3emp6vectorIdJEEaSERKS1_:
  |  171|      4|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorImJEEaSERKS1_:
  |  171|    124|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  | _ZN3emp6vectorIiJEEaSERKS1_:
  |  171|      2|    /*_FORCE_COVER_START_*/this_t & operator=(const this_t &) = default/*_FORCE_COVER_END_*/;
  ------------------
  172|       |
  173|   213k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  174|   213k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  175|   213k|      return stdv_t::operator[](pos);
  176|   213k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIhJEEixEm:
  |  173|    214|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    214|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    214|      return stdv_t::operator[](pos);
  |  176|    214|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5arrayIiLm128EEEJEEixEm:
  |  173|  1.49k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|  1.49k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|  1.49k|      return stdv_t::operator[](pos);
  |  176|  1.49k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_4tNFAILm128EhE5StateEJEEixEm:
  |  173|  1.60k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|  1.60k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|  1.60k|      return stdv_t::operator[](pos);
  |  176|  1.60k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_5Graph4NodeEJEEixEm:
  |  173|     68|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|     68|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|     68|      return stdv_t::operator[](pos);
  |  176|     68|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS0_IdJEEEJEEixEm
  ------------------
  | _ZN3emp6vectorIdJEEixEm:
  |  173|    148|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    148|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    148|      return stdv_t::operator[](pos);
  |  176|    148|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEEixEm:
  |  173|      1|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|      1|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|      1|      return stdv_t::operator[](pos);
  |  176|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEEixEm:
  |  173|    288|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    288|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    288|      return stdv_t::operator[](pos);
  |  176|    288|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIP10TestClass1JEEixEm:
  |  173|    500|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    500|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    500|      return stdv_t::operator[](pos);
  |  176|    500|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEEixEm:
  |  173|   200k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|   200k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|   200k|      return stdv_t::operator[](pos);
  |  176|   200k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS0_IcJEEEJEEixEm:
  |  173|    736|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    736|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    736|      return stdv_t::operator[](pos);
  |  176|    736|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIcJEEixEm:
  |  173|    736|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|    736|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|    736|      return stdv_t::operator[](pos);
  |  176|    736|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEixEm:
  |  173|     85|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|     85|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|     85|      return stdv_t::operator[](pos);
  |  176|     85|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEEixEm:
  |  173|  7.83k|    /*_FORCE_COVER_START_*/T & operator[](size_t pos) {
  |  174|  7.83k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  175|  7.83k|      return stdv_t::operator[](pos);
  |  176|  7.83k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_9DFAStatusEJEEixEm
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEEixEm
  ------------------
  177|       |
  178|  29.1k|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  179|  29.1k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  180|  29.1k|      return stdv_t::operator[](pos);
  181|  29.1k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEEixEm:
  |  178|     10|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|     10|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|     10|      return stdv_t::operator[](pos);
  |  181|     10|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_4tNFAILm128EhE5StateEJEEixEm:
  |  178|  24.6k|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|  24.6k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|  24.6k|      return stdv_t::operator[](pos);
  |  181|  24.6k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIhJEEixEm:
  |  178|  4.14k|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|  4.14k|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|  4.14k|      return stdv_t::operator[](pos);
  |  181|  4.14k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_5Graph4NodeEJEEixEm
  ------------------
  | _ZNK3emp6vectorINS_5arrayIiLm128EEEJEEixEm:
  |  178|    276|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|    276|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|    276|      return stdv_t::operator[](pos);
  |  181|    276|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorISt8functionIFddEEJEEixEm:
  |  178|     72|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|     72|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|     72|      return stdv_t::operator[](pos);
  |  181|     72|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEEixEm:
  |  178|     28|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|     28|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|     28|      return stdv_t::operator[](pos);
  |  181|     28|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6vectorIiJEEixEm:
  |  178|     11|    /*_FORCE_COVER_START_*/const T & operator[](size_t pos) const {
  |  179|     11|      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  |  180|     11|      return stdv_t::operator[](pos);
  |  181|     11|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS_7PtrInfoEJEEixEm
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorINS0_IdJEEEJEEixEm
  ------------------
  | Unexecuted instantiation: _ZNK3emp6vectorIdJEEixEm
  ------------------
  182|       |
  183|     36|    /*_FORCE_COVER_START_*/T & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }/*_FORCE_COVER_END_*/
  184|       |    /*_FORCE_COVER_START_*/const T & back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }/*_FORCE_COVER_END_*/
  185|      2|    /*_FORCE_COVER_START_*/T & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }/*_FORCE_COVER_END_*/
  186|       |    /*_FORCE_COVER_START_*/const T & front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }/*_FORCE_COVER_END_*/
  187|       |
  188|       |    /*_FORCE_COVER_START_*/template <typename... PB_Ts>
  189|  3.94k|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  190|  3.94k|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  191|  3.94k|      revision++;
  192|  3.94k|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorImJEE9push_backIJRmEEEvDpOT_:
  |  189|  2.77k|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|  2.77k|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|  2.77k|      revision++;
  |  192|  2.77k|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEvEEJEE9push_backIJRKS9_EEEvDpOT_:
  |  189|      5|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|      5|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|      5|      revision++;
  |  192|      5|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE9push_backIJRKS3_EEEvDpOT_:
  |  189|      4|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|      4|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|      4|      revision++;
  |  192|      4|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFddEEJEE9push_backIJRKS3_EEEvDpOT_:
  |  189|      3|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|      3|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|      3|      revision++;
  |  192|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE9push_backIJRS4_EEEvDpOT_:
  |  189|    146|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|    146|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|    146|      revision++;
  |  192|    146|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEE9push_backIJS6_EEEvDpOT_
  ------------------
  | _ZN3emp6vectorIP10TestClass1JEE9push_backIJS2_EEEvDpOT_:
  |  189|  1.00k|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|  1.00k|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|  1.00k|      revision++;
  |  192|  1.00k|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE9push_backIJiEEEvDpOT_:
  |  189|     10|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|     10|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|     10|      revision++;
  |  192|     10|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorIiJEE9push_backIJRiEEEvDpOT_:
  |  189|      2|    /*_FORCE_COVER_START_*/void push_back(PB_Ts &&... args) {
  |  190|      2|      stdv_t::push_back(std::forward<PB_Ts>(args)...);
  |  191|      2|      revision++;
  |  192|      2|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  193|       |
  194|     36|    /*_FORCE_COVER_START_*/void pop_back() {
  195|     36|      emp_assert(stdv_t::size() > 0, stdv_t::size());
  196|     36|      stdv_t::pop_back();
  197|     36|      revision++;           // Technically reducing size can cause memory reallocation, but less likely.
  198|     36|    }/*_FORCE_COVER_END_*/
  199|       |
  200|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  201|      2|    /*_FORCE_COVER_START_*/iterator insert(ARGS &&... args) {
  202|      2|      ++revision;
  203|      2|      return iterator( stdv_t::insert(std::forward<ARGS>(args)...), this );
  204|      2|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  205|       |
  206|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  207|     11|    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  208|     11|      ++revision;
  209|     11|      return iterator( stdv_t::erase(std::forward<ARGS>(args)...), this );
  210|     11|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorISt8functionIFviiEEJEE5eraseIJNS4_16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS3_St6vectorIS3_SaIS3_EEEEEEEEESE_DpOT_:
  |  207|      1|    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  |  208|      1|      ++revision;
  |  209|      1|      return iterator( stdv_t::erase(std::forward<ARGS>(args)...), this );
  |  210|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_3PtrINS_5RegEx7re_baseEEEJEE5eraseIJNS5_16iterator_wrapperIN9__gnu_cxx17__normal_iteratorIPS4_St6vectorIS4_SaIS4_EEEEEEEEESF_DpOT_:
  |  207|     10|    /*_FORCE_COVER_START_*/iterator erase(ARGS &&... args) {
  |  208|     10|      ++revision;
  |  209|     10|      return iterator( stdv_t::erase(std::forward<ARGS>(args)...), this );
  |  210|     10|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  211|       |
  212|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  213|       |    /*_FORCE_COVER_START_*/iterator emplace(ARGS &&... args) {
  214|       |      ++revision;
  215|       |      return iterator( stdv_t::emplace(std::forward<ARGS>(args)...), this );
  216|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  217|       |
  218|       |    /*_FORCE_COVER_START_*/template <typename... ARGS>
  219|      7|    /*_FORCE_COVER_START_*/void emplace_back(ARGS &&... args) {
  220|      7|      stdv_t::emplace_back(std::forward<ARGS>(args)...);
  221|      7|      revision++;
  222|      7|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6vectorINS_9TokenInfoEJEE12emplace_backIJRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESB_RmEEEvDpOT_:
  |  219|      7|    /*_FORCE_COVER_START_*/void emplace_back(ARGS &&... args) {
  |  220|      7|      stdv_t::emplace_back(std::forward<ARGS>(args)...);
  |  221|      7|      revision++;
  |  222|      7|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_9DFAStatusEJEE12emplace_backIJiRA1_KcEEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_9DFAStatusEJEE12emplace_backIJRKiRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp6vectorINS_7PtrInfoEJEE12emplace_backIJRPKvEEEvDpOT_
  ------------------
  223|       |  };
  224|       |
  225|       |  /// Build a specialized debug wrapper for emp::vector<bool>
  226|       |  template <typename... Ts>
  227|       |  class vector<bool, Ts...> : public std::vector<bool,Ts...> {
  228|       |  private:
  229|       |    using this_t = emp::vector<bool,Ts...>;
  230|       |    using stdv_t = std::vector<bool,Ts...>;
  231|       |
  232|       |    /// Setup a threshold; if we try to make a vector bigger than MAX_SIZE, throw a warning.
  233|       |    constexpr static const size_t MAX_SIZE = 2000000001;
  234|       |
  235|       |  public:
  236|       |    using iterator = typename stdv_t::iterator;
  237|       |    using const_iterator = typename stdv_t::const_iterator;
  238|       |    using value_type = bool;
  239|       |    using size_type = typename stdv_t::size_type;
  240|       |    using reference = typename stdv_t::reference;
  241|       |    using const_reference = typename stdv_t::const_reference;
  242|       |
  243|       |    vector() : stdv_t() {};
  244|       |    vector(const this_t & _in) : stdv_t(_in) {};
  245|       |    vector(size_t size) : stdv_t(size) { emp_assert(size < MAX_SIZE, size); }
  246|       |    vector(size_t size, bool val) : stdv_t(size, val) { emp_assert(size < MAX_SIZE, size); }
  247|       |    vector(std::initializer_list<bool> in_list) : stdv_t(in_list) { ; }
  248|       |    vector(const stdv_t & in) : stdv_t(in) { ; }         // Emergency fallback conversion.
  249|       |    /*_FORCE_COVER_START_*/template <typename InputIt>
  250|       |    vector(InputIt first, InputIt last) : stdv_t(first, last){;}/*_FORCE_COVER_END_*/
  251|       |
  252|       |
  253|       |    // operator stdv_t &() { return v; }
  254|       |    // operator const stdv_t &() const { return v; }
  255|       |
  256|       |    void resize(size_t new_size) { emp_assert(new_size < MAX_SIZE, new_size); stdv_t::resize(new_size); }
  257|       |    void resize(size_t new_size, bool val) {
  258|       |      emp_assert(new_size < MAX_SIZE, new_size);
  259|       |      stdv_t::resize(new_size, val);
  260|       |    }
  261|       |    this_t & operator=(const this_t &) = default;
  262|       |
  263|       |    auto operator[](size_t pos) -> decltype(stdv_t::operator[](pos)) {
  264|       |      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  265|       |      return stdv_t::operator[](pos);
  266|       |    }
  267|       |
  268|       |    bool operator[](size_t pos) const {
  269|       |      emp_assert(pos < stdv_t::size(), pos, stdv_t::size());
  270|       |      return stdv_t::operator[](pos);
  271|       |    }
  272|       |
  273|       |    auto & back() { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }
  274|       |    bool back() const { emp_assert(stdv_t::size() > 0); return stdv_t::back(); }
  275|       |    auto & front() { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }
  276|       |    bool front() const { emp_assert(stdv_t::size() > 0); return stdv_t::front(); }
  277|       |
  278|       |    void pop_back() {
  279|       |      emp_assert(stdv_t::size() > 0, stdv_t::size());
  280|       |      stdv_t::pop_back();
  281|       |    }
  282|       |  };
  283|       |
  284|       |}
  285|       |
  286|       |// A crude, generic printing function for vectors.
  287|       |/*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  288|       |std::ostream & operator<<(std::ostream & out, const emp::vector<T,Ts...> & v) {
  289|       |  for (const T & x : v) out << x << " ";
  290|       |  return out;
  291|       |}/*_FORCE_COVER_END_*/
  292|       |
  293|       |/*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  294|       |std::istream & operator>>(std::istream & is, emp::vector<T,Ts...> & v) {
  295|       |  for (T & x : v) is >> x;
  296|       |  return is;
  297|       |}/*_FORCE_COVER_END_*/
  298|       |
  299|       |#endif
  300|       |
  301|       |// namespace emp {
  302|       |//   template<typename T, typename... Ts> struct TypeID< emp::vector<T,Ts...> > {
  303|       |//     static std::string GetName() {
  304|       |//       using simple_vt = emp::vector<T>;
  305|       |//       using full_vt = emp::vector<T,Ts...>;
  306|       |//       if (std::is_same<simple_vt,full_vt>::value) {
  307|       |//         return "emp::vector<" + TypeID<T>::GetName() + ">";
  308|       |//       }
  309|       |//       return "emp::vector<" + TypeID<TypePack<T,Ts...>>::GetTypes() + ">";
  310|       |//     }
  311|       |//   };
  312|       |// }
  313|       |
  314|       |#endif
  315|       |

/home/emily/repos/Empirical_Tests/source/meta/IntPack.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  IntPack.h
    7|       | *  @brief A set of integers that can be manipulated at compile time (good for metaprogramming)
    8|       | *
    9|       | *  These objects are able to measure a specific trait on another object.  They
   10|       | *  (will eventually) interface smoothly with DataNodes for data collection.
   11|       | *
   12|       | *  @todo Shift to ValPack where the type is specified and then the values; specialize as IntPack.
   13|       | */
   14|       |
   15|       |
   16|       |#ifndef EMP_INT_PACK_H
   17|       |#define EMP_INT_PACK_H
   18|       |
   19|       |#include "meta.h"
   20|       |
   21|       |#include <iostream>
   22|       |
   23|       |namespace emp {
   24|       |
   25|       |  // Pre-declaration of IntPack
   26|       |  template <int... Ts> struct IntPack;
   27|       |
   28|       |  // Anonymous implementations of IntPack interface.
   29|       |  namespace internal {
   30|       |    template <bool DONE, int START, int END, int STEP, int... VALS>
   31|       |    struct ip_range {
   32|       |      static constexpr int NEXT = START + STEP;
   33|       |      using type = typename ip_range<(NEXT >= END), NEXT, END, STEP, VALS..., START>::type;
   34|       |    };
   35|       |    template <int START, int END, int STEP, int... VALS>
   36|       |    struct ip_range <true, START, END, STEP, VALS...> {
   37|       |      using type = IntPack<VALS...>;
   38|       |    };
   39|       |
   40|       |    template <typename T1, typename T2> struct ip_concat;
   41|       |    template <int... T1s, int... T2s>
   42|       |    struct ip_concat<IntPack<T1s...>, IntPack<T2s...>> {
   43|       |      using result = IntPack<T1s..., T2s...>;
   44|       |    };
   45|       |
   46|       |    template <typename T_IN, typename T_OUT=IntPack<>, bool DONE=false, int VERSION=0>
   47|       |    struct ip_loop {
   48|       |      // Helpers...
   49|       |      using in_pop = typename T_IN::pop;
   50|       |      template <int V> using out_pbin = typename T_OUT::template push_back_if_not<T_IN::first, V>;
   51|       |      template <int V, bool D=false> using pnext = ip_loop< in_pop, out_pbin<V>, D, VERSION >;  // Prune
   52|       |
   53|       |      // Main operations...
   54|       |      template <int V> using pop_val = typename pnext<V, T_IN::first==V>::template pop_val<V>;
   55|       |      template <int V> using remove = typename pnext<V>::template remove<V>;
   56|       |      template <int V> using uniq = typename pnext<V>::template uniq<T_IN::first>;
   57|       |    };
   58|       |    template <typename T_IN, typename T_OUT, int VERSION>
   59|       |    struct ip_loop<T_IN, T_OUT, true, VERSION> {
   60|       |      template <int V> using pop_val = typename T_OUT::template append<T_IN>; // Pop done!
   61|       |    };
   62|       |    template <typename T_OUT, int VERSION>
   63|       |    struct ip_loop<IntPack<>, T_OUT, false, VERSION> {
   64|       |      template <int V> using pop_val = T_OUT;  // Nothing to pop! (error?)
   65|       |      template <int V> using remove = T_OUT;   // Nothing left to remove!
   66|       |      template <int V> using uniq = T_OUT;     // Nothing left to check!
   67|       |    };
   68|       |
   69|       |    // Implement == ip_push_if_not ==
   70|       |    template <int V, int X, typename T>
   71|       |    struct ip_push_if_not {
   72|       |      using result = typename T::template push<V>;
   73|       |      using back = typename T::template push_back<V>;
   74|       |    };
   75|       |    template <int V, typename T>
   76|       |    struct ip_push_if_not<V,V,T> {
   77|       |      using result = T;
   78|       |      using back = T;
   79|       |    };
   80|       |
   81|       |    // Setup ==reverse== operation.
   82|       |    template <typename T> struct ip_reverse;
   83|       |    template <int V1, int... Vs> struct ip_reverse<IntPack<V1, Vs...>> {
   84|       |      using result = typename ip_reverse< IntPack<Vs...> >::result::template push_back<V1>;
   85|       |    };
   86|       |    template <> struct ip_reverse<IntPack<>> { using result = IntPack<>; };
   87|       |
   88|       |    // Setup ==uniq== operation.
   89|       |    template <typename T> struct ip_uniq;
   90|       |    template <int V1, int... Vs> struct ip_uniq<IntPack<V1, Vs...>> {
   91|       |      using result = typename ip_loop<IntPack<V1, Vs...>, IntPack<>, false, 1>::template uniq<V1+1>;
   92|       |    };
   93|       |    template <> struct ip_uniq<IntPack<>> { using result = IntPack<>; };
   94|       |
   95|       |    // Setup ==sort== operation.
   96|       |    template <typename T_IN, typename T_OUT>
   97|       |    struct ip_sort_impl {
   98|       |      template <int V> using spop = typename T_IN::template pop_val<V>;
   99|       |      template <int V> using snext = ip_sort_impl< spop<V>, typename T_OUT::template push_back<V> >;
  100|       |      template <int V> using sort = typename snext<V>::template sort< spop<V>::Min(T_IN::first) >;
  101|       |    };
  102|       |    template <typename T_OUT>
  103|       |    struct ip_sort_impl<IntPack<>, T_OUT> {
  104|       |      template <int V> using sort = T_OUT;     // Nothing left to sort!
  105|       |    };
  106|       |
  107|       |    template <typename T> struct ip_sort;
  108|       |    template <int V1, int... Vs> struct ip_sort<IntPack<V1, Vs...>> {
  109|       |      using ip = IntPack<V1, Vs...>;
  110|       |      using result = typename ip_sort_impl<ip, IntPack<>>::template sort<ip::Min()>;
  111|       |    };
  112|       |    template <> struct ip_sort<IntPack<>> { using result = IntPack<>; };
  113|       |  }
  114|       |
  115|       |  // Generate an IntPack with a specified range of values.
  116|       |  template <int START, int END, int STEP=1>
  117|       |  using IntPackRange = typename internal::ip_range<(START >= END), START, END, STEP>::type;
  118|       |
  119|       |  // IntPack with at least one value.
  120|       |  template <int V1, int... Vs>
  121|       |  struct IntPack<V1,Vs...> {
  122|       |    static constexpr int first = V1;
  123|       |
  124|       |    using this_t = IntPack<V1,Vs...>;
  125|       |    using pop = IntPack<Vs...>;
  126|       |
  127|       |    template <int V> using push = IntPack<V, V1, Vs...>;
  128|       |    template <int V> using push_back = IntPack<V1, Vs..., V>;
  129|       |    template <int V, int X> using push_if_not = typename internal::ip_push_if_not<V,X,this_t>::result;
  130|       |    template <int V, int X> using push_back_if_not = typename internal::ip_push_if_not<V,X,this_t>::back;
  131|       |    template <int V> using pop_val = typename internal::ip_loop<this_t, IntPack<>, false, 2>::template pop_val<V>;
  132|       |    template <int V> using remove = typename internal::ip_loop<this_t, IntPack<>, false, 3>::template remove<V>;
  133|       |    template <typename T> using append = typename internal::ip_concat<this_t,T>::result;
  134|       |
  135|       |    constexpr static bool Has(int V) { return (V==V1) | pop::Has(V); }
  136|       |    constexpr static int Count(int V) { return pop::Count(V) + (V==V1); }
  137|       |    constexpr static int GetID(int V) { return (V==V1) ? 0 : (1+pop::GetID(V)); }
  138|       |
  139|       |    constexpr static int SIZE = 1+sizeof...(Vs);
  140|       |    constexpr static int GetSize() { return SIZE; }
  141|       |
  142|       |    constexpr static bool IsEmpty() { return false; }
  143|       |    constexpr static bool IsUnique() { return pop::IsUnique() && !pop::Has(V1); }
  144|       |
  145|       |    constexpr static int Sum() { return V1 + pop::Sum(); }
  146|       |    constexpr static int Product() { return V1 * pop::Product(); }
  147|       |    constexpr static int Min(int cap) { return cap < pop::Min(V1) ? cap : pop::Min(V1); }
  148|       |    constexpr static int Min() { return pop::Min(V1); }
  149|       |    constexpr static int Max(int floor) { return floor > pop::Max(V1) ? floor : pop::Max(V1); }
  150|       |    constexpr static int Max() { return pop::Max(V1); }
  151|       |
  152|       |    static void PrintInts(std::ostream & os=std::cout) {
  153|       |      os << V1;
  154|       |      if (GetSize() > 1) os << ',';
  155|       |      pop::PrintInts(os);
  156|       |    }
  157|       |  };
  158|       |
  159|       |  // IntPack with no values.
  160|       |  template <> struct IntPack<> {
  161|       |    using this_t = IntPack<>;
  162|       |
  163|       |    template <int V> using push = IntPack<V>;
  164|       |    template <int V> using push_back = IntPack<V>;
  165|       |    template <int V, int X> using push_if_not = typename internal::ip_push_if_not<V,X,IntPack<>>::result;
  166|       |    template <int V, int X> using push_back_if_not = typename internal::ip_push_if_not<V,X,IntPack<>>::back;
  167|       |    template <int V> using pop_val = IntPack<>;  // No value to pop!  Faulure?
  168|       |    template <int V> using remove = IntPack<>;
  169|       |    template <typename T> using append = T;
  170|       |
  171|      0|    constexpr static bool Has(int) { return false; }
  172|      0|    constexpr static int Count(int) { return 0; }
  173|      0|    constexpr static int GetID(int V) { return -100000; }
  174|       |
  175|       |    constexpr static int SIZE = 0;
  176|      0|    constexpr static int GetSize() { return 0; }
  177|       |
  178|      0|    constexpr static bool IsEmpty() { return true; }
  179|      0|    constexpr static bool IsUnique() { return true; }
  180|       |
  181|      0|    constexpr static int Sum() { return 0; }
  182|      0|    constexpr static int Product() { return 1; }
  183|      0|    constexpr static int Min(int cap) { return cap; }
  184|      0|    constexpr static int Max(int floor) { return floor; }
  185|       |
  186|      0|    static void PrintInts(std::ostream & os=std::cout) { ; }
  187|       |  };
  188|       |
  189|       |  namespace pack {
  190|       |    template <typename T> using reverse = typename internal::ip_reverse<T>::result;
  191|       |    template <typename T> using uniq = typename internal::ip_uniq<T>::result;
  192|       |
  193|       |    template <typename T> using sort = typename internal::ip_sort<T>::result;
  194|       |    template <typename T> using Rsort = reverse< sort<T> >;
  195|       |    template <typename T> using Usort = uniq< sort<T> >;
  196|       |    template <typename T> using RUsort = reverse< Usort<T> >;
  197|       |  }
  198|       |}
  199|       |
  200|       |#endif
  201|       |

/home/emily/repos/Empirical_Tests/source/meta/TypeID.h:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016.
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//  TypeID provides an easy way to convert types to strings.
    6|       |//
    7|       |//
    8|       |//  Developer notes:
    9|       |//  * Fill out remaining standard library classes (as possible)
   10|       |//  * Default to type_traits typeid rather than Unknown
   11|       |
   12|       |#ifndef EMP_TYPE_ID_H
   13|       |#define EMP_TYPE_ID_H
   14|       |
   15|       |#include <sstream>
   16|       |#include <string>
   17|       |
   18|       |#include "../base/vector.h"
   19|       |#include "TypePack.h"
   20|       |
   21|       |
   22|       |namespace emp {
   23|       |
   24|       |  // Generic TypeID structure for when none of the specialty cases trigger.
   25|       |  template<typename T> struct TypeID {
   26|       |    template<typename TEST> using TypeIDFilter = decltype(&TEST::TypeID);
   27|       |    struct UnknownID { /*_FORCE_COVER_START_*/static std::string TypeID() { return "Unknown"; }/*_FORCE_COVER_END_*/ };
   28|       |    /*_FORCE_COVER_START_*/static std::string GetName() {
   29|       |      using print_t = typename TypePack<T,UnknownID>::template find_t<TypeIDFilter>;
   30|       |      return print_t::TypeID();
   31|       |    }/*_FORCE_COVER_END_*/
   32|       |  };
   33|       |
   34|       |  // Built-in types.
   35|      0|  template<> struct TypeID<void> { static std::string GetName() { return "void"; } };
   36|       |
   37|      0|  template<> struct TypeID<bool> { static std::string GetName() { return "bool"; } };
   38|      0|  template<> struct TypeID<double> { static std::string GetName() { return "double"; } };
   39|      0|  template<> struct TypeID<float> { static std::string GetName() { return "float"; } };
   40|       |
   41|      0|  template<> struct TypeID<char> { static std::string GetName() { return "char"; } };
   42|      0|  template<> struct TypeID<char16_t> { static std::string GetName() { return "char16_t"; } };
   43|      0|  template<> struct TypeID<char32_t> { static std::string GetName() { return "char32_t"; } };
   44|       |
   45|      0|  template<> struct TypeID<int8_t>  { static std::string GetName() { return "int8_t"; } };
   46|      0|  template<> struct TypeID<int16_t> { static std::string GetName() { return "int16_t"; } };
   47|      0|  template<> struct TypeID<int32_t> { static std::string GetName() { return "int32_t"; } };
   48|      0|  template<> struct TypeID<int64_t> { static std::string GetName() { return "int64_t"; } };
   49|      0|  template<> struct TypeID<uint8_t>  { static std::string GetName() { return "uint8_t"; } };
   50|      0|  template<> struct TypeID<uint16_t> { static std::string GetName() { return "uint16_t"; } };
   51|      0|  template<> struct TypeID<uint32_t> { static std::string GetName() { return "uint32_t"; } };
   52|      0|  template<> struct TypeID<uint64_t> { static std::string GetName() { return "uint64_t"; } };
   53|       |
   54|       |  // Check for type attributes...
   55|       |  template<typename T> struct TypeID<T*> {
   56|       |    static std::string GetName() { return TypeID<T>::GetName() + '*'; }
   57|       |  };
   58|       |
   59|       |  // Tools for using TypePack
   60|       |  template<typename T, typename... Ts> struct TypeID<emp::TypePack<T,Ts...>> {
   61|       |    static std::string GetTypes() {
   62|       |      std::string out = TypeID<T>::GetName();
   63|       |      if (sizeof...(Ts) > 0) out += ",";
   64|       |      out += TypeID<emp::TypePack<Ts...>>::GetTypes();
   65|       |      return out;
   66|       |    }
   67|       |	  static std::string GetName() {
   68|       |      std::string out = "emp::TypePack<";
   69|       |	    out += GetTypes();
   70|       |	    out += ">";
   71|       |	    return out;
   72|       |    }
   73|       |  };
   74|       |  template<> struct TypeID< emp::TypePack<> > {
   75|      0|    static std::string GetTypes() { return ""; }
   76|      0|    static std::string GetName() { return "emp::TypePack<>"; }
   77|       |  };
   78|       |
   79|       |  // Generic TemplateID structure for when none of the specialty cases trigger.
   80|       |  template <typename T> struct TemplateID {
   81|       |    /*_FORCE_COVER_START_*/static std::string GetName() { return "UnknownTemplate"; }/*_FORCE_COVER_END_*/
   82|       |  };
   83|       |
   84|       |  template<template <typename...> class TEMPLATE, typename... Ts>
   85|       |  struct TypeID<TEMPLATE<Ts...>> {
   86|       |    static std::string GetName() {
   87|       |      return TemplateID<TEMPLATE<Ts...>>::GetName()
   88|       |            + '<' + TypeID<emp::TypePack<Ts...>>::GetTypes() + '>';
   89|       |    }
   90|       |  };
   91|       |}
   92|       |
   93|       |
   94|       |namespace emp{
   95|       |
   96|       |  // Standard library types.
   97|      0|  template<> struct TypeID<std::string> { static std::string GetName() { return "std::string"; } };
   98|       |
   99|       |  // Standard library templates.
  100|       |  //  template <typename... Ts> struct TemplateID<std::array<Ts...>> { static std::string GetName() { return "array"; } };
  101|       |
  102|       |  template<typename T, typename... Ts> struct TypeID< emp::vector<T,Ts...> > {
  103|       |    static std::string GetName() {
  104|       |      using simple_vt = emp::vector<T>;
  105|       |      using full_vt = emp::vector<T,Ts...>;
  106|       |      if (std::is_same<simple_vt,full_vt>::value) {
  107|       |        return "emp::vector<" + TypeID<T>::GetName() + ">";
  108|       |      }
  109|       |      return "emp::vector<" + TypeID<TypePack<T,Ts...>>::GetTypes() + ">";
  110|       |    }
  111|       |  };
  112|       |
  113|       |}
  114|       |
  115|       |#endif
  116|       |

/home/emily/repos/Empirical_Tests/source/meta/TypePack.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  TypePack.h
    7|       | *  @brief A set of types that can be manipulated at compile time (good for metaprogramming)
    8|       | *
    9|       | *  TypePacks are static structues that provide a large set of mechanisms to access and adjust
   10|       | *  the included types.
   11|       | *
   12|       | *  To create a typepack, just pass in zero or more types into the TypePack templete.
   13|       | *
   14|       | *    using my_pack = emp::TypePack<int, std::string, double>;
   15|       | *
   16|       | *  After manipulations, you can apply a type pack using the apply<> member template.  E.g.,
   17|       | *
   18|       | *    my_pack::resize<5,char>::reverse::apply<std::tuple> my_tuple;
   19|       | *
   20|       | *  ...would create a variable of type std::tuple<char, char, double, std::string, int>.
   21|       | *
   22|       | *
   23|       | *  Member functions include (all of which are constexpr):
   24|       | *    Has<T>()          - Return true/false: Is T is part of the pack?
   25|       | *    Count<T>()        - Return number of times T is in the pack.
   26|       | *    GetID<T>()        - Return first position of T in the pack, (or -1 if none).
   27|       | *    GetSize()         - Return total number of types in this pack.
   28|       | *    IsEmpty()         - Return true/false: Is this pack empty?
   29|       | *    IsUnique()        - Return true/false: are all types in pack are distinct?
   30|       | *
   31|       | *  Type accessors:
   32|       | *    get<POS>          - Type at position POS in the pack.
   33|       | *    first_t           - Type of first position in the pack.
   34|       | *    last_t            - Type of last position in the pack.
   35|       | *    select<Ps...>     - Create a new pack with types from selected position.
   36|       | *
   37|       | *  Type manipulations:
   38|       | *    set<POS, T>       - Change types at position POS to T.
   39|       | *    push_front<Ts...> - Add any number of types Ts to the front of the pack.
   40|       | *    push_back<Ts...>  - Add any number of types Ts to the back of the pack.
   41|       | *    pop               - Pack with first type missing.
   42|       | *    popN<N>           - Pack with first N types missing.
   43|       | *    shrink<N>         - Pack with ONLY first N types.
   44|       | *    resize<N,D>       - Resize pack to N types; if N greater than current size, pad with D.
   45|       | *    merge<P>          - Append all of pack P to the end of this pack.
   46|       | *    reverse           - Reverse the order of types in this pack.
   47|       | *    rotate            - Move the first type in pack to the end.
   48|       | *
   49|       | *  Applications:
   50|       | *    apply<T>          - Take template T and apply these types as its arguments.
   51|       | *    to_function_t<T>  - Convert to a function type, with return type T and arg types from pack.
   52|       | *    filter<FILTER>    - Keep only those types, T, that can legally form FILTER<T> and does not
   53|       | *                        have a FILTER<T>::value == false.
   54|       | *    find<FILTER>      - Convert to first type, T, that can legally form FILTER<T> and does not
   55|       | *                        have a FILTER<T>::value == false.
   56|       | *    wrap<WRAPPER>     - Convert to TypePack where all members are run through WRAPPER
   57|       | *
   58|       | *
   59|       | *  Developer notes:
   60|       | *    - GetIDPack could return an IntPack of ALL ID's for a type that appears more than once.
   61|       | */
   62|       |
   63|       |#ifndef EMP_TYPE_PACK_H
   64|       |#define EMP_TYPE_PACK_H
   65|       |
   66|       |#include "meta.h"
   67|       |
   68|       |namespace emp {
   69|       |
   70|       |  // Pre-declaration of TypePack
   71|       |  template <typename... Ts> struct TypePack;
   72|       |
   73|       |  // Create a null type for padding.
   74|       |  struct null_t {};
   75|       |
   76|       |  // Anonymous helpers for TypePack
   77|       |  namespace {
   78|       |    // Create add N copies of the same type to the end of a TypePack.
   79|       |    template <typename START, typename T, int N>
   80|       |    struct tp_pad { using type = typename tp_pad<START,T,N-1>::type::template add<T>; };
   81|       |    template <typename START, typename T>
   82|       |    struct tp_pad<START, T,0> { using type = START; };
   83|       |
   84|       |    /// Helper for shifting a specified number of types to TypePack T1 from TypePack T2.
   85|       |    /// Example: to shrink, move the specified number of types to empty TypePack and return it.
   86|       |    ///          to merge, move all of one TypePack over to the other and return it.
   87|       |    template <int S, typename T1, typename T2>
   88|       |    struct tp_shift {
   89|       |      using move_t = typename T2::first_t;
   90|       |      using inc_t = typename T1::template add<move_t>;
   91|       |      using dec_t = typename T2::pop;
   92|       |      using type1 = typename tp_shift<S-1, inc_t, dec_t>::type1;
   93|       |      using type2 = typename tp_shift<S-1, inc_t, dec_t>::type2;
   94|       |    };
   95|       |    template <typename T1, typename T2>
   96|       |    struct tp_shift<0, T1, T2> {
   97|       |      using type1 = T1;
   98|       |      using type2 = T2;
   99|       |    };
  100|       |
  101|       |    // Filters create a TypePack with the element if the filter is true, empty if false.
  102|       |    template <typename T, bool> struct tp_filter1 { using type=TypePack<T>; };
  103|       |    template <typename T> struct tp_filter1<T,false> { using type=TypePack<>; };
  104|       |
  105|       |    /// Remove types from a TypePack that can't satisfy a filter.
  106|       |    template <typename T, template <typename...> class FILTER, int N>
  107|       |    struct tp_filter {
  108|       |      using cur_t = typename T::first_t;                                 // Isolate the first type
  109|       |      using other_tp = typename T::pop;                                  // Isolate remaining types
  110|       |      constexpr static bool cur_result = test_type<FILTER,cur_t>();      // Run filter of cur type
  111|       |      using cur_ftp = typename tp_filter1<cur_t, cur_result>::type;      // Use cur type if true
  112|       |      using other_ftp = typename tp_filter<other_tp, FILTER, N-1>::type; // Recurse
  113|       |      using type = typename cur_ftp::template merge< other_ftp >;        // Merge
  114|       |    };
  115|       |    template <typename T, template <typename...> class FILTER>
  116|       |      struct tp_filter<T,FILTER,0> { using type = TypePack<>; };
  117|       |
  118|       |    template <typename T, template <typename...> class FILTER>
  119|       |      using tp_filter_t = typename tp_filter<T,FILTER,T::SIZE>::type;
  120|       |
  121|       |    // Wrappers create a TypePack with the wrapped element if the filter is true, empty if false.
  122|       |    template <typename T, template <typename...> class W, bool> struct tp_wrap1
  123|       |      { using type=TypePack<W<T>>; };
  124|       |    template <typename T, template <typename...> class W> struct tp_wrap1<T,W,false>
  125|       |      { using type=TypePack<>; };
  126|       |
  127|       |    /// Wrap all types in a TypePack in a template; remove any that can't be wrapped.
  128|       |    template <typename T, template <typename...> class W, int N> struct tp_wrap {
  129|       |      using cur_t = typename T::first_t;                               // Isolate the first type
  130|       |      using other_tp = typename T::pop;                                // Isolate remaining types
  131|       |      constexpr static bool cur_result = test_type<W,cur_t>();         // Use wrap to filter cur type
  132|       |      using cur_ftp = typename tp_wrap1<cur_t, W, cur_result>::type;   // Use cur type if true
  133|       |      using other_ftp = typename tp_wrap<other_tp, W, N-1>::type;      // Recurse
  134|       |      using type = typename cur_ftp::template merge< other_ftp >;      // Merge
  135|       |    };
  136|       |    template <typename T, template <typename...> class W>
  137|       |      struct tp_wrap<T,W,0> { using type = TypePack<>; };
  138|       |
  139|       |    template <typename T, template <typename...> class W>
  140|       |      using tp_wrap_t = typename tp_wrap<T,W,T::SIZE>::type;
  141|       |  }
  142|       |
  143|       |  template <typename T, int N> using TypePackFill = typename tp_pad<TypePack<>,T,N>::type;
  144|       |
  145|       |  // Specialized TypePack with at least one type.
  146|       |  template <typename T1, typename... Ts>
  147|       |  struct TypePack<T1, Ts...> {
  148|       |    /// Return a bool indicating whether the specified type is present.
  149|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static bool Has() { return has_type<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  150|       |
  151|       |    /// Count the number of instances of the specified type.
  152|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static size_t Count() { return count_type<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  153|       |
  154|       |    /// Return the position of the specified type.
  155|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static int GetID() { return get_type_index<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  156|       |
  157|       |    /// Return the position of the type of owner.
  158|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static int GetID(const T &) { return get_type_index<T,T1,Ts...>(); }/*_FORCE_COVER_END_*/
  159|       |
  160|       |    /// Set to the number of types in this pack.
  161|       |    constexpr static int SIZE = 1+sizeof...(Ts);
  162|       |
  163|       |    /// Return the number of types in this pack.
  164|       |    constexpr static int GetSize() { return SIZE; }
  165|       |
  166|       |    /// Return bool indicating if there are any types in this pack.
  167|       |    constexpr static bool IsEmpty() { return false; }
  168|       |
  169|       |    /// Return bool indicating if all types in this pack are different from each other.
  170|       |    constexpr static bool IsUnique() { return has_unique_types<T1,Ts...>(); }
  171|       |
  172|       |    /// Get the type associated with a specified position in the pack.
  173|       |    template <int POS> using get = pack_id<POS, T1, Ts...>;
  174|       |
  175|       |    // Other type lookups
  176|       |
  177|       |    /// What is the full type of this TypePack?
  178|       |    // (mostly a helper for the code below)
  179|       |    using this_t = TypePack<T1, Ts...>;
  180|       |
  181|       |    /// What is the first type in this TypePack?
  182|       |    using first_t = T1;
  183|       |
  184|       |    /// What is the final type in this TypePack?
  185|       |    using last_t = last_type<T1,Ts...>;
  186|       |
  187|       |    // Modifications
  188|       |
  189|       |    /// Push a new type onto the front of this TypePack.
  190|       |    template <typename... T> using push_front = TypePack<T...,T1,Ts...>;
  191|       |
  192|       |    /// Push a new type onto the back of this TypePack.
  193|       |    template <typename... T> using push_back = TypePack<T1,Ts...,T...>;
  194|       |
  195|       |    /// Push a new type onto the back of this TypePack.
  196|       |    template <typename... T> using add = TypePack<T1,Ts...,T...>;    // Same as push_back_t...
  197|       |
  198|       |    /// Remove the first type from this TypePack and return the rest.
  199|       |    using pop = TypePack<Ts...>;
  200|       |    template <int N> using popN = typename tp_shift<N, TypePack<>, this_t>::type2;
  201|       |
  202|       |    /// Reduce the size of this TypePack down to N.
  203|       |    template <int N> using shrink = typename tp_shift<N, TypePack<>, this_t>::type1;
  204|       |
  205|       |    /// Add N new entries onto TypePack, all of provided type T.
  206|       |    template <typename T, int N=1> using pad = typename tp_pad<this_t,T,N>::type;
  207|       |
  208|       |    /// Make this TypePack the specified size, padding with provided type T.
  209|       |    template <int N, typename DEFAULT=null_t>
  210|       |      using resize = typename pad<DEFAULT,(N>SIZE)?(N-SIZE):0>::template shrink<N>;
  211|       |
  212|       |    /// Join this TypePack with another TypePack.
  213|       |    template <typename IN> using merge = typename tp_shift<IN::SIZE, this_t, IN>::type1;
  214|       |
  215|       |    /// Rearrange types in TypePack into reverse order.
  216|       |    using reverse = typename pop::reverse::template push_back<T1>;
  217|       |
  218|       |    /// Rotate types through typepack by the specified number of steps.
  219|       |    using rotate = typename pop::template push_back<T1>;
  220|       |
  221|       |    /// Set the type at the specified position to the new type provided.  Return as new TypePack.
  222|       |    template <int ID, typename T>
  223|       |      using set = typename shrink<ID>::template push_back<T>::template merge<popN<ID+1>>;
  224|       |
  225|       |    /// Choose a set of specific positions.  Return as new TypePack.
  226|       |    template <int... Ps> using select = TypePack< get<Ps>... >;
  227|       |
  228|       |    /// Convert to a function signature with a specified return type.
  229|       |    template <typename RETURN_T> using to_function_t = RETURN_T(T1,Ts...);
  230|       |
  231|       |    /// Apply to a specified template with TypePack as template arguments.
  232|       |    template <template <typename...> class TEMPLATE> using apply = TEMPLATE<T1, Ts...>;
  233|       |
  234|       |    /// Remove all types that cannot pass a filter.  Return as new TypePack.
  235|       |    template <template <typename...> class FILTER> using filter = tp_filter_t<this_t, FILTER>;
  236|       |
  237|       |    /// Return the first type that satisfies a filter.
  238|       |    template <template <typename...> class FILTER>
  239|       |      using find_t = typename tp_filter_t<this_t, FILTER>::first_t;
  240|       |
  241|       |    /// Wrap all types in a specified wrapper template.
  242|       |    template <template <typename...> class WRAPPER> using wrap = tp_wrap_t<this_t, WRAPPER>;
  243|       |  };
  244|       |
  245|       |  // Specialized TypePack with no types.
  246|       |  template <>
  247|       |  struct TypePack<> {
  248|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static bool Has() { return false; }/*_FORCE_COVER_END_*/
  249|       |    /*_FORCE_COVER_START_*/template <typename T> constexpr static size_t Count() { return 0; }/*_FORCE_COVER_END_*/
  250|       |
  251|       |    // GetID() NOT IMPLEMENTED since no ID's are available.
  252|       |    constexpr static int SIZE = 0;
  253|      0|    constexpr static int GetSize() { return 0; }
  254|      0|    constexpr static bool IsEmpty() { return true; }
  255|      0|    constexpr static bool IsUnique() { return true; }
  256|       |
  257|       |    // pop_t not implemented, since no types are available.
  258|       |
  259|       |    using this_t = TypePack<>;
  260|       |    using first_t = null_t;
  261|       |    using last_t = null_t;
  262|       |
  263|       |    template <typename... T> using push_front = TypePack<T...>;
  264|       |    template <typename... T> using push_back = TypePack<T...>;
  265|       |    template <typename... T> using add = TypePack<T...>;
  266|       |
  267|       |    // In both of these cases, N had better be zero... but no easy way to assert.
  268|       |    template <int N> using popN = this_t;
  269|       |    template <int N> using shrink = this_t;
  270|       |
  271|       |    template <typename T, int N=1> using pad = typename tp_pad<this_t,T,N>::type;
  272|       |    template <int N, typename DEFAULT=null_t> using resize = pad<DEFAULT,N>;
  273|       |
  274|       |    template <typename IN> using merge = IN;
  275|       |    using reverse = this_t;
  276|       |    using rotate = this_t;
  277|       |
  278|       |    template <typename RETURN_T> using to_function_t = RETURN_T();
  279|       |
  280|       |    template <template <typename...> class TEMPLATE> using apply = TEMPLATE<>;
  281|       |
  282|       |    // There's nothing to filter, so return this_t (TypePack<>) or null_t
  283|       |    template <template <typename...> class FILTER> using filter = this_t;
  284|       |    template <template <typename...> class FILTER> using find_t = null_t;
  285|       |    template <template <typename...> class WRAPPER> using wrap = this_t;
  286|       |  };
  287|       |}
  288|       |
  289|       |#endif
  290|       |

/home/emily/repos/Empirical_Tests/source/meta/meta.h:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016-2018
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//  A bunch of C++ Template Meta-programming tricks.
    6|       |//
    7|       |//
    8|       |//  Developer notes:
    9|       |//  * Right now test_type<> returns false if a template can't resolve, but if it's true it checks
   10|       |//    if a value field is present; if so that determines success.  The reason for this choice was
   11|       |//    to make sure that true_type and false_type are handled correctly (with built-in type_tratis)
   12|       |
   13|       |#ifndef EMP_META_H
   14|       |#define EMP_META_H
   15|       |
   16|       |#include <functional>
   17|       |#include <tuple>
   18|       |#include <utility>
   19|       |
   20|       |namespace emp {
   21|       |
   22|       |  // Effectively create a function (via constructor) where all args are computed, then ignored.
   23|       |  struct run_and_ignore { /*_FORCE_COVER_START_*/template <typename... T> run_and_ignore(T&&...) {}/*_FORCE_COVER_END_*/ };
   24|       |
   25|       |  // Trim off a specific type position from a pack.
   26|       |  template <typename T1, typename... Ts> using first_type = T1;
   27|       |  template <typename T1, typename T2, typename... Ts> using second_type = T2;
   28|       |  template <typename T1, typename T2, typename T3, typename... Ts> using third_type = T3;
   29|       |
   30|       |  // Index into a template parameter pack to grab a specific type.
   31|       |  namespace internal {
   32|       |    template <size_t ID, typename T, typename... Ts>
   33|       |    struct pack_id_impl { using type = typename pack_id_impl<ID-1,Ts...>::type; };
   34|       |
   35|       |    template <typename T, typename... Ts>
   36|       |    struct pack_id_impl<0,T,Ts...> { using type = T; };
   37|       |  }
   38|       |
   39|       |  template <size_t ID, typename... Ts>
   40|       |  using pack_id = typename internal::pack_id_impl<ID,Ts...>::type;
   41|       |
   42|       |  // Trim off the last type from a pack.
   43|       |  template <typename... Ts> using last_type = pack_id<sizeof...(Ts)-1,Ts...>;
   44|       |
   45|       |  // Trick to call a function using each entry in a parameter pack.
   46|       |#define EMP_EXPAND_PPACK(PPACK) ::emp::run_and_ignore{ 0, ((PPACK), void(), 0)... }
   47|       |
   48|       |  // Check to see if a specified type is part of a set of types.
   49|      0|  /*_FORCE_COVER_START_*/template <typename TEST> constexpr bool has_type() { return false; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIiEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIdEEbv
  ------------------
   50|       |  /*_FORCE_COVER_START_*/template <typename TEST, typename FIRST, typename... OTHERS>
   51|      0|  constexpr bool has_type() { return std::is_same<TEST, FIRST>() || has_type<TEST,OTHERS...>(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIidJEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJdEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIiiJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdJEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_JdEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiJS6_dEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIddJEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIdNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJdEEEbv
  ------------------
  | Unexecuted instantiation: _ZN3emp8has_typeIdiJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEbv
  ------------------
   52|       |
   53|       |  // Count how many times a specified type appears in a set of types.
   54|       |  /*_FORCE_COVER_START_*/template <typename TEST> constexpr size_t count_type() { return 0; }/*_FORCE_COVER_END_*/
   55|       |  /*_FORCE_COVER_START_*/template <typename TEST, typename FIRST, typename... OTHERS>
   56|       |  constexpr size_t count_type() { return count_type<TEST,OTHERS...>() + (std::is_same<TEST, FIRST>()?1:0); }/*_FORCE_COVER_END_*/
   57|       |
   58|       |  // Return the index of a test type in a set of types.
   59|       |  namespace internal {
   60|      0|    /*_FORCE_COVER_START_*/template <typename TEST_T> constexpr int get_type_index_impl() { return -1; }/*_FORCE_COVER_END_*/ // Not found!
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIiEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIdEEiv
  ------------------
   61|       |    /*_FORCE_COVER_START_*/template <typename TEST_T, typename T1, typename... Ts>
   62|      6|    constexpr int get_type_index_impl() {
   63|      6|      if (std::is_same<TEST_T, T1>()) return 0;                     // Found here!
   64|      4|      constexpr int next_id = get_type_index_impl<TEST_T,Ts...>();  // Keep looking...
   65|      4|      if (next_id < 0) return -1;                                   // Not found!
   66|      4|      return next_id + 1;                                           // Found later!
   67|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal19get_type_index_implIiiJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEiv:
  |   62|      2|    constexpr int get_type_index_impl() {
  |   63|      2|      if (std::is_same<TEST_T, T1>()) return 0;                     // Found here!
  |   64|      0|      constexpr int next_id = get_type_index_impl<TEST_T,Ts...>();  // Keep looking...
  |   65|      0|      if (next_id < 0) return -1;                                   // Not found!
  |   66|      0|      return next_id + 1;                                           // Found later!
  |   67|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal19get_type_index_implINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiJS7_dEEEiv:
  |   62|      2|    constexpr int get_type_index_impl() {
  |   63|      2|      if (std::is_same<TEST_T, T1>()) return 0;                     // Found here!
  |   64|      2|      constexpr int next_id = get_type_index_impl<TEST_T,Ts...>();  // Keep looking...
  |   65|      2|      if (next_id < 0) return -1;                                   // Not found!
  |   66|      2|      return next_id + 1;                                           // Found later!
  |   67|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal19get_type_index_implIdiJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEiv:
  |   62|      2|    constexpr int get_type_index_impl() {
  |   63|      2|      if (std::is_same<TEST_T, T1>()) return 0;                     // Found here!
  |   64|      2|      constexpr int next_id = get_type_index_impl<TEST_T,Ts...>();  // Keep looking...
  |   65|      2|      if (next_id < 0) return -1;                                   // Not found!
  |   66|      2|      return next_id + 1;                                           // Found later!
  |   67|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIidJEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJdEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdJEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_JdEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIddJEEEiv
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal19get_type_index_implIdNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJdEEEiv
  ------------------
   68|       |  }
   69|       |  /*_FORCE_COVER_START_*/template <typename TEST_T, typename... Ts>
   70|      6|  constexpr int get_type_index() { return internal::get_type_index_impl<TEST_T, Ts...>(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp14get_type_indexIiJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEiv:
  |   70|      2|  constexpr int get_type_index() { return internal::get_type_index_impl<TEST_T, Ts...>(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp14get_type_indexINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJiS6_dEEEiv:
  |   70|      2|  constexpr int get_type_index() { return internal::get_type_index_impl<TEST_T, Ts...>(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp14get_type_indexIdJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEiv:
  |   70|      2|  constexpr int get_type_index() { return internal::get_type_index_impl<TEST_T, Ts...>(); }/*_FORCE_COVER_END_*/
  ------------------
   71|       |
   72|       |
   73|       |  // These functions can be used to test if a type-set has all unique types or not.
   74|       |
   75|       |  // Base cases...
   76|       |  /*_FORCE_COVER_START_*/template <typename TYPE1> constexpr bool has_unique_first_type() { return true; }/*_FORCE_COVER_END_*/
   77|       |  /*_FORCE_COVER_START_*/template <typename TYPE1> constexpr bool has_unique_types() { return true; }/*_FORCE_COVER_END_*/
   78|       |
   79|       |  /*_FORCE_COVER_START_*/template <typename TYPE1, typename TYPE2, typename... TYPE_LIST>
   80|       |  constexpr bool has_unique_first_type() {
   81|       |    return (!std::is_same<TYPE1, TYPE2>()) && emp::has_unique_first_type<TYPE1, TYPE_LIST...>();
   82|       |  }/*_FORCE_COVER_END_*/
   83|       |
   84|       |  /*_FORCE_COVER_START_*/template <typename TYPE1, typename TYPE2, typename... TYPE_LIST>
   85|       |  constexpr bool has_unique_types() {
   86|       |    return has_unique_first_type<TYPE1, TYPE2, TYPE_LIST...>()  // Check first against all others...
   87|       |      && has_unique_types<TYPE2, TYPE_LIST...>();               // Recurse through other types.
   88|       |  }/*_FORCE_COVER_END_*/
   89|       |
   90|       |
   91|       |  // sfinae_decoy<X,Y> will always evaluate to X no matter what Y is.
   92|       |  // X is type you want it to be; Y is a decoy trigger potential substituion failue.
   93|       |  template <typename REAL_TYPE, typename EVAL_TYPE> using sfinae_decoy = REAL_TYPE;
   94|       |  template <typename REAL_TYPE, typename EVAL_TYPE> using type_decoy = REAL_TYPE;
   95|       |  template <typename EVAL_TYPE>                     using bool_decoy = bool;
   96|       |  template <typename EVAL_TYPE>                     using int_decoy = int;
   97|       |
   98|       |  // Deprecated macros
   99|       |#define emp_bool_decoy(TEST) emp::sfinae_decoy<bool, decltype(TEST)>
  100|       |#define emp_int_decoy(TEST) emp::sfinae_decoy<int, decltype(TEST)>
  101|       |
  102|       |
  103|       |  // constexpr bool test_type<TEST,T>() returns true if T passes the TEST, false otherwise.
  104|       |  //
  105|       |  // TEST is a template.  TEST will fail if TEST<T> fails to resolve (substitution failure) -OR-
  106|       |  // if TEST<T> does resolve, but TEST<T>::value == false.  Otherwise the test passes.
  107|       |  //
  108|       |  // Two helper functions exist to test each part: test_type_exist and test_type_value.
  109|       |
  110|       |  namespace internal {
  111|       |    /*_FORCE_COVER_START_*/template <template <typename...> class FILTER, typename T>
  112|       |    constexpr bool tt_exist_impl(bool_decoy<FILTER<T>> x) { return true; }/*_FORCE_COVER_END_*/
  113|       |    /*_FORCE_COVER_START_*/template <template <typename...> class FILTER, typename T>
  114|       |    constexpr bool tt_exist_impl(...) { return false; }/*_FORCE_COVER_END_*/
  115|       |  }
  116|       |
  117|       |  /*_FORCE_COVER_START_*/template <template <typename...> class TEST, typename T>
  118|       |  constexpr bool test_type_exist() { return internal::tt_exist_impl<TEST, T>(true); }/*_FORCE_COVER_END_*/
  119|       |
  120|       |  /*_FORCE_COVER_START_*/template <template <typename...> class TEST, typename T>
  121|       |  constexpr bool test_type_value() { return TEST<T>::value; }/*_FORCE_COVER_END_*/
  122|       |
  123|       |  namespace internal {
  124|       |    // If a test does have a value field, that value determines success.
  125|       |    template <typename RESULT, bool value_exist>
  126|       |    struct test_type_v_impl { /*_FORCE_COVER_START_*/constexpr static bool Test() { return RESULT::value; }/*_FORCE_COVER_END_*/ };
  127|       |    // If a test does not have a value field, the fact it resolved at all indicates success.
  128|       |    template <typename RESULT>
  129|       |    struct test_type_v_impl<RESULT,0> { constexpr static bool Test() { return true; } };
  130|       |
  131|       |    template <typename T> using value_member = decltype(T::value);
  132|       |    // If TEST<T> *does* resolve, check the value field to determine test success.
  133|       |    template <template <typename...> class TEST, typename T, bool exist>
  134|       |    struct test_type_e_impl {
  135|       |      /*_FORCE_COVER_START_*/constexpr static bool Test() {
  136|       |        using result_t = TEST<T>;
  137|       |        constexpr bool has_value = test_type_exist<value_member, result_t>();
  138|       |        return test_type_v_impl<result_t,has_value>::Test();
  139|       |      }/*_FORCE_COVER_END_*/
  140|       |    };
  141|       |    // If TEST<T> does *not* resolve, test fails, so return false.
  142|       |    template <template <typename...> class TEST, typename T>
  143|       |    struct test_type_e_impl<TEST,T,0> { constexpr static bool Test() { return false; } };
  144|       |  }
  145|       |
  146|       |  // Function to actually perform a universal test.
  147|       |  /*_FORCE_COVER_START_*/template <template <typename...> class TEST, typename T>
  148|       |  constexpr bool test_type() {
  149|       |    return internal::test_type_e_impl<TEST,T,test_type_exist<TEST,T>()>::Test();
  150|       |  }/*_FORCE_COVER_END_*/
  151|       |
  152|       |
  153|       |  // TruncateCall reduces the number of arguments for calling a function if too many are used.
  154|       |  // @CAO: This should be simplified using TypeSet
  155|       |
  156|       |  namespace internal {
  157|       |    template <typename... PARAMS>
  158|       |    struct tcall_impl {
  159|       |      /*_FORCE_COVER_START_*/template <typename FUN_T, typename... EXTRA>
  160|       |      /*_FORCE_COVER_START_*/static auto call(FUN_T fun, PARAMS... args, EXTRA...) {
  161|       |        return fun(args...);
  162|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  163|       |    };
  164|       |  }
  165|       |
  166|       |  // Truncate the arguments provided, using only the relevant ones for a function call.
  167|       |  /*_FORCE_COVER_START_*/template <typename R, typename... PARAMS, typename... ARGS>
  168|       |  auto TruncateCall(std::function<R(PARAMS...)> fun, ARGS &&... args) {
  169|       |    return internal::tcall_impl<PARAMS...>::call(fun, std::forward<ARGS>(args)...);
  170|       |  }/*_FORCE_COVER_END_*/
  171|       |
  172|       |  // Expand a function to take (and ignore) extra arguments.
  173|       |  template <typename R, typename... ARGS>
  174|       |  struct AdaptFunction {
  175|       |    /*_FORCE_COVER_START_*/template <typename... EXTRA_ARGS>
  176|       |    /*_FORCE_COVER_START_*/static auto Expand(const std::function<R(ARGS...)> & fun) {
  177|       |      return [fun](ARGS... args, EXTRA_ARGS...){ return fun(args...); };
  178|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  179|       |  };
  180|       |
  181|       |
  182|       |  namespace internal {
  183|       |    // Allow a hash to be determined by a GetHash() member function.
  184|       |    /*_FORCE_COVER_START_*/template <typename T>
  185|       |    auto Hash_impl(const T & x, bool) -> decltype(x.GetHash()) { return x.GetHash(); }/*_FORCE_COVER_END_*/
  186|       |
  187|       |    // By default, use std::hash if nothing else exists.
  188|       |    /*_FORCE_COVER_START_*/template <typename T>
  189|       |    auto Hash_impl(const T & x, int) -> decltype(std::hash<T>()(x)) { return std::hash<T>()(x); }/*_FORCE_COVER_END_*/
  190|       |
  191|       |    // Try direct cast to size_t if nothing else works.
  192|       |    /*_FORCE_COVER_START_*/template <typename T>
  193|       |    std::size_t Hash_impl(const T & x, ...) {
  194|       |      // @CAO Setup directory structure to allow the following to work:
  195|       |      // LibraryWarning("Resorting to casting to size_t for emp::Hash implementation.");
  196|       |      return (size_t) x;
  197|       |    }/*_FORCE_COVER_END_*/
  198|       |  }
  199|       |
  200|       |  // Setup hashes to be dynamically determined.
  201|       |  /*_FORCE_COVER_START_*/template <typename T>
  202|       |  std::size_t Hash(const T & x) { return internal::Hash_impl(x, true); }/*_FORCE_COVER_END_*/
  203|       |
  204|       |  // Combine multiple keys into a single hash value.
  205|       |  /*_FORCE_COVER_START_*/template <typename T>
  206|       |  //std::size_t CombineHash(const T & x) { return std::hash<T>()(x); }
  207|       |  std::size_t CombineHash(const T & x) { return Hash<T>(x); }/*_FORCE_COVER_END_*/
  208|       |
  209|       |  /*_FORCE_COVER_START_*/template<typename T1, typename T2, typename... EXTRA>
  210|       |  std::size_t CombineHash(const T1 & x1, const T2 & x2, const EXTRA &... x_extra) {
  211|       |    const std::size_t hash2 = CombineHash(x2, x_extra...);
  212|       |    //return std::hash<T1>()(x1) + 0x9e3779b9 + (hash2 << 19) + (hash2 >> 13);
  213|       |    return Hash<T1>(x1) + 0x9e3779b9 + (hash2 << 19) + (hash2 >> 13);
  214|       |  }/*_FORCE_COVER_END_*/
  215|       |
  216|       |
  217|       |
  218|       |  // Change the internal type arguments on a template...
  219|       |  // Adapted from: Sam Varshavchik
  220|       |  // http://stackoverflow.com/questions/36511990/is-it-possible-to-disentangle-a-template-from-its-arguments-in-c
  221|       |  namespace internal {
  222|       |    template<typename T, typename ...U> struct AdaptTemplateHelper {
  223|       |      using type = T;
  224|       |    };
  225|       |
  226|       |    template<template <typename...> class T, typename... V, typename... U>
  227|       |    struct AdaptTemplateHelper<T<V...>, U...> {
  228|       |      using type = T<U...>;
  229|       |    };
  230|       |  }
  231|       |
  232|       |  template<typename T, typename... U>
  233|       |  using AdaptTemplate = typename internal::AdaptTemplateHelper<T, U...>::type;
  234|       |
  235|       |
  236|       |  // Variation of AdaptTemplate that only adapts first template argument.
  237|       |  namespace internal {
  238|       |    template<typename T, typename U> class AdaptTemplateHelper_Arg1 {
  239|       |    public:
  240|       |      using type = T;
  241|       |    };
  242|       |
  243|       |    template<template <typename...> class T, typename X, typename ...V, typename U>
  244|       |    class AdaptTemplateHelper_Arg1<T<X, V...>, U> {
  245|       |    public:
  246|       |      using type = T<U, V...>;
  247|       |    };
  248|       |  }
  249|       |
  250|       |  template<typename T, typename U>
  251|       |  using AdaptTemplate_Arg1 = typename internal::AdaptTemplateHelper_Arg1<T, U>::type;
  252|       |
  253|       |
  254|       |  // Some math inside templates...
  255|       |  template <int I, int... Is> struct tIntMath {
  256|       |    /*_FORCE_COVER_START_*/static constexpr int Sum() { return I + tIntMath<Is...>::Sum(); }/*_FORCE_COVER_END_*/
  257|       |    /*_FORCE_COVER_START_*/static constexpr int Product() { return I * tIntMath<Is...>::Product(); }/*_FORCE_COVER_END_*/
  258|       |  };
  259|       |
  260|       |  template <int I> struct tIntMath<I> {
  261|       |    static constexpr int Sum() { return I; }
  262|       |    static constexpr int Product() { return I; }
  263|       |  };
  264|       |
  265|       |  //This bit of magic is from
  266|       |  //http://meh.schizofreni.co/programming/magic/2013/01/23/function-pointer-from-lambda.html
  267|       |  //and is useful for fixing lambda function woes
  268|       |  template <typename Function>
  269|       |  struct function_traits
  270|       |    : public function_traits<decltype(&Function::operator())>
  271|       |  {};
  272|       |
  273|       |  template <typename ClassType, typename ReturnType, typename... Args>
  274|       |  struct function_traits<ReturnType(ClassType::*)(Args...) const>
  275|       |  {
  276|       |    typedef ReturnType (*pointer)(Args...);
  277|       |    typedef std::function<ReturnType(Args...)> function;
  278|       |  };
  279|       |
  280|       |  /*_FORCE_COVER_START_*/template <typename Function>
  281|       |  typename function_traits<Function>::pointer
  282|       |  to_function_pointer (Function& lambda)
  283|       |  {
  284|       |    return static_cast<typename function_traits<Function>::pointer>(lambda);
  285|       |  }/*_FORCE_COVER_END_*/
  286|       |
  287|       |  /*_FORCE_COVER_START_*/template <typename Function>
  288|       |  typename function_traits<Function>::function
  289|       |  to_function (Function& lambda)
  290|       |  {
  291|       |    return static_cast<typename function_traits<Function>::function>(lambda);
  292|       |  }/*_FORCE_COVER_END_*/
  293|       |
  294|       |
  295|       |}
  296|       |
  297|       |
  298|       |#endif
  299|       |

/home/emily/repos/Empirical_Tests/source/tools/BitMatrix.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  BitMatrix.h
    7|       | *  @brief A COL x ROW matrix of bits and provides easy indexing and manipulation
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_BIT_MATRIX_H
   12|       |#define EMP_BIT_MATRIX_H
   13|       |
   14|       |#include <iostream>
   15|       |#include <typeinfo>
   16|       |
   17|       |#include "BitSet.h"
   18|       |
   19|       |#ifndef functions
   20|       |#include "functions.h"
   21|       |#endif
   22|       |
   23|       |#include "bitset_utils.h"
   24|       |
   25|       |namespace emp {
   26|       |
   27|       |  /// @brief A simple class to manage a COLS x ROWS matrix of bits.
   28|       |  ///
   29|       |  ///  Bits are translated to a bitset with 0 in the upper left and moving through bits from
   30|       |  ///  left to right and top to bottom.  For example, the indecies in a 3x3 bit matrix would be
   31|       |  ///  organized as such:
   32|       |  ///
   33|       |  ///    0 1 2
   34|       |  ///    3 4 5
   35|       |  ///    6 7 8
   36|       |
   37|       |  template <size_t COLS, size_t ROWS>
   38|       |  class BitMatrix {
   39|       |  private:
   40|       |    BitSet<COLS*ROWS> bits;   ///< Actual bits in matrix.
   41|       |
   42|       |  public:
   43|       |    /*_FORCE_COVER_START_*/template <size_t START_POS, size_t STEP_POS, size_t END_POS>
   44|       |    /*_FORCE_COVER_START_*/constexpr BitSet<COLS*ROWS> Mask() const {
   45|       |      return BitSet<COLS*ROWS>();
   46|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   47|       |
   48|       |    /// Keep only a single column of values, reducing all others to zeros.
   49|       |    /*_FORCE_COVER_START_*/template <size_t COL_ID>
   50|      2|    /*_FORCE_COVER_START_*/static const BitSet<COLS*ROWS> & MaskCol() {
   51|      2|      static bool init = false;
   52|      2|      static BitSet<COLS*ROWS> mask;
   53|      2|      if (!init) {
   54|      6|        for (size_t i = 0; i < ROWS; i++) mask[i*COLS + COL_ID] = 1;
   55|      1|        init = true;
   56|      1|      }
   57|      2|      return mask;
   58|      2|      // return mask_pattern<COLS*ROWS, COL_ID, COLS, COLS*ROWS-1>();
   59|      2|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   60|       |
   61|       |    /// Keep only a single row of values, reducing all others to zeros.
   62|       |    /*_FORCE_COVER_START_*/template <size_t ROW_ID>
   63|      3|    /*_FORCE_COVER_START_*/static const BitSet<COLS*ROWS> & MaskRow() {
   64|      3|      static bool init = false;
   65|      3|      static BitSet<COLS*ROWS> mask;
   66|      3|      if (!init) {
   67|      5|        for (size_t i = 0; i < COLS; i++) mask[ROW_ID * COLS + i] = 1;
   68|      1|        init = true;
   69|      1|      }
   70|      3|      return mask;
   71|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   72|       |
   73|       |//  public:
   74|      1|    /*_FORCE_COVER_START_*/BitMatrix() { ; }/*_FORCE_COVER_END_*/
   75|      1|    /*_FORCE_COVER_START_*/BitMatrix(const BitSet<COLS*ROWS> & in_bits) : bits(in_bits) { ; }/*_FORCE_COVER_END_*/
   76|      1|    /*_FORCE_COVER_START_*/BitMatrix(const BitMatrix & in_matrix) : bits(in_matrix.bits) { ; }/*_FORCE_COVER_END_*/
   77|      3|    /*_FORCE_COVER_START_*/~BitMatrix() { ; }/*_FORCE_COVER_END_*/
   78|       |
   79|       |    /// How many rows are in this matrix?
   80|      1|    /*_FORCE_COVER_START_*/constexpr size_t NumRows() const { return ROWS; }/*_FORCE_COVER_END_*/
   81|       |
   82|       |    /// How many columns are in this matrix?
   83|      1|    /*_FORCE_COVER_START_*/constexpr size_t NumCols() const { return COLS; }/*_FORCE_COVER_END_*/
   84|       |
   85|       |    /// How many total cells are in this matrix?
   86|      1|    /*_FORCE_COVER_START_*/constexpr size_t GetSize() const { return ROWS * COLS; }/*_FORCE_COVER_END_*/
   87|       |
   88|       |    /// Identify which column a specific ID is part of.
   89|      0|    /*_FORCE_COVER_START_*/inline static size_t ToCol(size_t id) { return id % COLS; }/*_FORCE_COVER_END_*/
   90|       |
   91|       |    /// Identify which row a specific ID is part of.
   92|      0|    /*_FORCE_COVER_START_*/inline static size_t ToRow(size_t id) { return id / COLS; }/*_FORCE_COVER_END_*/
   93|       |
   94|       |    /// Identify the ID associated with a specified row and column.
   95|     15|    /*_FORCE_COVER_START_*/inline static size_t ToID(size_t col, size_t row) { return row * COLS + col; }/*_FORCE_COVER_END_*/
   96|       |
   97|      2|    /*_FORCE_COVER_START_*/bool Any() const { return bits.any(); }/*_FORCE_COVER_END_*/
   98|      3|    /*_FORCE_COVER_START_*/bool None() const { return bits.none(); }/*_FORCE_COVER_END_*/
   99|      3|    /*_FORCE_COVER_START_*/bool All() const { return bits.all(); }/*_FORCE_COVER_END_*/
  100|       |
  101|     13|    /*_FORCE_COVER_START_*/bool Get(size_t col, size_t row) const { return bits[ToID(col,row)]; }/*_FORCE_COVER_END_*/
  102|      0|    /*_FORCE_COVER_START_*/bool Get(size_t id) const { return bits[id]; }/*_FORCE_COVER_END_*/
  103|       |
  104|      1|    /*_FORCE_COVER_START_*/void Set(size_t col, size_t row, bool val=true) { bits[ToID(col, row)] = val; }/*_FORCE_COVER_END_*/
  105|      0|    /*_FORCE_COVER_START_*/void Set(size_t id) { bits[id] = true; }/*_FORCE_COVER_END_*/
  106|      0|    /*_FORCE_COVER_START_*/void Unset(size_t col, size_t row) { bits[ToID(col, row)] = false; }/*_FORCE_COVER_END_*/
  107|      0|    /*_FORCE_COVER_START_*/void Unset(size_t id) { bits[id] = false; }/*_FORCE_COVER_END_*/
  108|      0|    /*_FORCE_COVER_START_*/void Flip(size_t col, size_t row) { bits.flip(ToID(col, row)); }/*_FORCE_COVER_END_*/
  109|      0|    /*_FORCE_COVER_START_*/void Flip(size_t id) { bits.flip(id); }/*_FORCE_COVER_END_*/
  110|       |
  111|      1|    /*_FORCE_COVER_START_*/void SetAll() { bits.SetAll(); }/*_FORCE_COVER_END_*/
  112|      1|    /*_FORCE_COVER_START_*/void SetCol(size_t col) { bits |= MaskCol<0>() << col;}/*_FORCE_COVER_END_*/
  113|      2|    /*_FORCE_COVER_START_*/void SetRow(size_t row) { bits |= (MaskRow<0>() << (row * COLS)); }/*_FORCE_COVER_END_*/
  114|      2|    /*_FORCE_COVER_START_*/void Clear() { bits.Clear(); }/*_FORCE_COVER_END_*/
  115|      1|    /*_FORCE_COVER_START_*/void ClearCol(size_t col) { bits &= ~(MaskCol<0>() << col); }/*_FORCE_COVER_END_*/
  116|      1|    /*_FORCE_COVER_START_*/void ClearRow(size_t row) { bits &= ~(MaskRow<0>() << (row * COLS)); }/*_FORCE_COVER_END_*/
  117|       |
  118|       |    // Count the number of set bits in the matrix.
  119|      2|    /*_FORCE_COVER_START_*/size_t CountOnes() const { return bits.count(); }/*_FORCE_COVER_END_*/
  120|       |
  121|       |    // Find the position of the first non-zero bit.
  122|       |    // size_t FindBit() const { return (~bits & (bits - 1)).count(); }
  123|       |
  124|      1|    /*_FORCE_COVER_START_*/int FindBit() const { return bits.FindBit(); }/*_FORCE_COVER_END_*/
  125|       |
  126|       |    // Shift the whole matrix in the specified direction.
  127|      0|    /*_FORCE_COVER_START_*/BitMatrix LeftShift() const { return ((bits & ~MaskCol<0>()) >> 1); }/*_FORCE_COVER_END_*/
  128|      0|    /*_FORCE_COVER_START_*/BitMatrix RightShift() const { return ((bits << 1) & ~MaskCol<0>()); }/*_FORCE_COVER_END_*/
  129|      1|    /*_FORCE_COVER_START_*/BitMatrix UpShift() const { return bits >> COLS; }/*_FORCE_COVER_END_*/
  130|      0|    /*_FORCE_COVER_START_*/BitMatrix DownShift() const { return bits << COLS; }/*_FORCE_COVER_END_*/
  131|      0|    /*_FORCE_COVER_START_*/BitMatrix ULShift() const { return ((bits & ~MaskCol<0>()) >> (COLS+1)); }/*_FORCE_COVER_END_*/
  132|      0|    /*_FORCE_COVER_START_*/BitMatrix DLShift() const { return ((bits & ~MaskCol<0>()) << (COLS-1)); }/*_FORCE_COVER_END_*/
  133|      0|    /*_FORCE_COVER_START_*/BitMatrix URShift() const { return ((bits >> (COLS-1)) & ~MaskCol<0>()); }/*_FORCE_COVER_END_*/
  134|      0|    /*_FORCE_COVER_START_*/BitMatrix DRShift() const { return ((bits << (COLS+1)) & ~MaskCol<0>()); }/*_FORCE_COVER_END_*/
  135|       |
  136|       |    // Find all points within one step of the ones on this bit matrix.
  137|      0|    /*_FORCE_COVER_START_*/BitMatrix GetReach() const { return *this | LeftShift() | RightShift() | UpShift() | DownShift(); }/*_FORCE_COVER_END_*/
  138|       |
  139|       |    // Find all points reachable from the start position.
  140|      0|    /*_FORCE_COVER_START_*/BitMatrix GetRegion(size_t start_pos) const {
  141|      0|      // Make sure we have a legal region, or else return an empty matrix.
  142|      0|      if (start_pos < 0 || start_pos >= GetSize() || bits[start_pos] == 0) return BitMatrix();
  143|      0|
  144|      0|      BitMatrix cur_region, last_region;
  145|      0|      cur_region.Set(start_pos);
  146|      0|
  147|      0|      while (cur_region != last_region) {
  148|      0|        last_region = cur_region;
  149|      0|        cur_region = *this & cur_region.GetReach();
  150|      0|      }
  151|      0|
  152|      0|      return cur_region;
  153|      0|    }/*_FORCE_COVER_END_*/
  154|      0|    /*_FORCE_COVER_START_*/BitMatrix GetRegion(size_t col, size_t row) const { return GetRegion(ToID(col,row)); }/*_FORCE_COVER_END_*/
  155|       |
  156|       |    // Does this bit matrix represent a connected set of ones?
  157|      0|    /*_FORCE_COVER_START_*/bool IsConnected() const { return GetRegion((size_t)FindBit()) == *this; }/*_FORCE_COVER_END_*/
  158|       |
  159|       |    // Does this bit matrix have any 2x2 square of ones in it?
  160|      0|    /*_FORCE_COVER_START_*/bool Has2x2() const { return (*this & UpShift() & LeftShift() & ULShift()).Any(); }/*_FORCE_COVER_END_*/
  161|       |
  162|      0|    /*_FORCE_COVER_START_*/void Print(std::ostream & os = std::cout) const {
  163|      0|      for (size_t y = 0; y < ROWS; y++) {
  164|      0|        for (size_t x = 0; x < COLS; x++) {
  165|      0|          os << bits[ToID(x,y)];
  166|      0|        }
  167|      0|        os << std::endl;
  168|      0|      }
  169|      0|    }/*_FORCE_COVER_END_*/
  170|       |
  171|       |    // Assignments and compound assignments
  172|      0|    /*_FORCE_COVER_START_*/BitMatrix & operator=(const BitMatrix & in) { bits = in.bits; return *this; }/*_FORCE_COVER_END_*/
  173|      0|    /*_FORCE_COVER_START_*/BitMatrix & operator&=(const BitMatrix & in) { bits &= in.bits; return *this; }/*_FORCE_COVER_END_*/
  174|      0|    /*_FORCE_COVER_START_*/BitMatrix & operator|=(const BitMatrix & in) { bits |= in.bits; return *this; }/*_FORCE_COVER_END_*/
  175|      0|    /*_FORCE_COVER_START_*/BitMatrix & operator^=(const BitMatrix & in) { bits ^= in.bits; return *this; }/*_FORCE_COVER_END_*/
  176|       |
  177|       |    // Comparisons
  178|      0|    /*_FORCE_COVER_START_*/bool operator==(const BitMatrix & in) const { return bits == in.bits; }/*_FORCE_COVER_END_*/
  179|      0|    /*_FORCE_COVER_START_*/bool operator!=(const BitMatrix & in) const { return bits != in.bits; }/*_FORCE_COVER_END_*/
  180|       |
  181|       |    // Logic operators
  182|      0|    /*_FORCE_COVER_START_*/BitMatrix operator~() const { return ~bits; }/*_FORCE_COVER_END_*/
  183|      0|    /*_FORCE_COVER_START_*/BitMatrix operator&(const BitMatrix & in) const { return bits & in.bits; }/*_FORCE_COVER_END_*/
  184|      0|    /*_FORCE_COVER_START_*/BitMatrix operator|(const BitMatrix & in) const { return bits | in.bits; }/*_FORCE_COVER_END_*/
  185|      0|    /*_FORCE_COVER_START_*/BitMatrix operator^(const BitMatrix & in) const { return bits ^ in.bits; }/*_FORCE_COVER_END_*/
  186|       |
  187|       |    // Conversions
  188|      0|    /*_FORCE_COVER_START_*/const BitSet<COLS*ROWS> & to_bitset() { return bits; }/*_FORCE_COVER_END_*/
  189|       |  };
  190|       |}
  191|       |
  192|       |#endif
  193|       |

/home/emily/repos/Empirical_Tests/source/tools/BitSet.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  BitSet.h
    7|       | *  @brief A drop-in replacement for std::bitset, with additional bit magic features.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  @note Like std::bitset, bit zero is on the right side.  Unlike std::bitset, emp::BitSet
   11|       | *       gives access to bit fields for easy access to different sized chucnk of bits and
   12|       | *       implementation new bit-magic tricks.
   13|       | */
   14|       |
   15|       |
   16|       |#ifndef EMP_BIT_SET_H
   17|       |#define EMP_BIT_SET_H
   18|       |
   19|       |#include <iostream>
   20|       |
   21|       |#include "../base/assert.h"
   22|       |#include "../base/vector.h"
   23|       |
   24|       |#include "bitset_utils.h"
   25|       |#include "functions.h"
   26|       |#include "math.h"
   27|       |#include "Random.h"
   28|       |
   29|       |namespace emp {
   30|       |
   31|       |  ///  A fixed-sized (but arbitrarily large) array of bits, and optimizes operations on those bits
   32|       |  ///  to be as fast as possible.
   33|       |  template <size_t NUM_BITS> class BitSet {
   34|       |  private:
   35|       |    /// Fields hold bits in groups of 32 (as uint32_t); how many feilds do we need?
   36|       |    static const uint32_t NUM_FIELDS = 1 + ((NUM_BITS - 1) >> 5);
   37|       |
   38|       |    /// End position of the stored bits in the last field; 0 if perfect fit.
   39|       |    static const uint32_t LAST_BIT = NUM_BITS & 31;
   40|       |
   41|       |    /// How many total bytes are needed to represent these bits? (rounded up to full bytes)
   42|       |    static const uint32_t NUM_BYTES = 1 + ((NUM_BITS - 1) >> 3);
   43|       |
   44|       |    uint32_t bit_set[NUM_FIELDS];  ///< Fields to hold the actual bits for this BitSet.
   45|       |
   46|       |    /// BitProxy lets us use operator[] on with BitSet as an lvalue.
   47|       |    class BitProxy {
   48|       |    private:
   49|       |      BitSet<NUM_BITS> & bit_set;  ///< BitSet object that this proxy refers to.
   50|       |      size_t index;                ///< Position in BitSet the this proxy refers to.
   51|       |    public:
   52|  41.2k|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
   53|  41.2k|        emp_assert(_idx < bit_set.size());
   54|  41.2k|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8BitProxyC2ERS1_m
  ------------------
  | _ZN3emp6BitSetILm80EE8BitProxyC2ERS1_m:
  |   52|      2|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
  |   53|      2|        emp_assert(_idx < bit_set.size());
  |   54|      2|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm10EE8BitProxyC2ERS1_m:
  |   52|     12|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
  |   53|     12|        emp_assert(_idx < bit_set.size());
  |   54|     12|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE8BitProxyC2ERS1_m:
  |   52|  40.0k|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
  |   53|  40.0k|        emp_assert(_idx < bit_set.size());
  |   54|  40.0k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE8BitProxyC2ERS1_m:
  |   52|  1.17k|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
  |   53|  1.17k|        emp_assert(_idx < bit_set.size());
  |   54|  1.17k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE8BitProxyC2ERS1_m:
  |   52|     10|      /*_FORCE_COVER_START_*/BitProxy(BitSet<NUM_BITS> & _set, size_t _idx) : bit_set(_set), index(_idx) {
  |   53|     10|        emp_assert(_idx < bit_set.size());
  |   54|     10|      }/*_FORCE_COVER_END_*/
  ------------------
   55|       |
   56|       |      /// Set the bit value that this proxy refers to.
   57|  41.1k|      /*_FORCE_COVER_START_*/BitProxy & operator=(bool b) {    // lvalue handling...
   58|  41.1k|        bit_set.Set(index, b);
   59|  41.1k|        return *this;
   60|  41.1k|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8BitProxyaSEb
  ------------------
  | _ZN3emp6BitSetILm80EE8BitProxyaSEb:
  |   57|      2|      /*_FORCE_COVER_START_*/BitProxy & operator=(bool b) {    // lvalue handling...
  |   58|      2|        bit_set.Set(index, b);
  |   59|      2|        return *this;
  |   60|      2|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE8BitProxyaSEb:
  |   57|  40.0k|      /*_FORCE_COVER_START_*/BitProxy & operator=(bool b) {    // lvalue handling...
  |   58|  40.0k|        bit_set.Set(index, b);
  |   59|  40.0k|        return *this;
  |   60|  40.0k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE8BitProxyaSEb:
  |   57|  1.17k|      /*_FORCE_COVER_START_*/BitProxy & operator=(bool b) {    // lvalue handling...
  |   58|  1.17k|        bit_set.Set(index, b);
  |   59|  1.17k|        return *this;
  |   60|  1.17k|      }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE8BitProxyaSEb:
  |   57|     10|      /*_FORCE_COVER_START_*/BitProxy & operator=(bool b) {    // lvalue handling...
  |   58|     10|        bit_set.Set(index, b);
  |   59|     10|        return *this;
  |   60|     10|      }/*_FORCE_COVER_END_*/
  ------------------
   61|       |
   62|       |      /// Convert BitProxy to a regular boolean value.
   63|     24|      /*_FORCE_COVER_START_*/operator bool() const {            // rvalue handling...
   64|     24|        return bit_set.Get(index);
   65|     24|      }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE8BitProxycvbEv
  ------------------
  | _ZNK3emp6BitSetILm10EE8BitProxycvbEv:
  |   63|     24|      /*_FORCE_COVER_START_*/operator bool() const {            // rvalue handling...
  |   64|     24|        return bit_set.Get(index);
  |   65|     24|      }/*_FORCE_COVER_END_*/
  ------------------
   66|       |
   67|       |      /// Flip this bit.
   68|      0|      /*_FORCE_COVER_START_*/BitProxy & Toggle() { bit_set.Toggle(index); return *this; }/*_FORCE_COVER_END_*/
   69|       |    };
   70|       |    friend class BitProxy;
   71|       |
   72|  84.2k|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
   73|  84.2k|      emp_assert((index >> 5) < NUM_FIELDS);
   74|  84.2k|      return index >> 5;
   75|  84.2k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE7FieldIDEm
  ------------------
  | _ZN3emp6BitSetILm128EE7FieldIDEm:
  |   72|  15.5k|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
  |   73|  15.5k|      emp_assert((index >> 5) < NUM_FIELDS);
  |   74|  15.5k|      return index >> 5;
  |   75|  15.5k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EE7FieldIDEm:
  |   72|      4|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
  |   73|      4|      emp_assert((index >> 5) < NUM_FIELDS);
  |   74|      4|      return index >> 5;
  |   75|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm10EE7FieldIDEm:
  |   72|     30|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
  |   73|     30|      emp_assert((index >> 5) < NUM_FIELDS);
  |   74|     30|      return index >> 5;
  |   75|     30|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE7FieldIDEm:
  |   72|  68.5k|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
  |   73|  68.5k|      emp_assert((index >> 5) < NUM_FIELDS);
  |   74|  68.5k|      return index >> 5;
  |   75|  68.5k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE7FieldIDEm:
  |   72|     23|    /*_FORCE_COVER_START_*/inline static size_t FieldID(const size_t index) {
  |   73|     23|      emp_assert((index >> 5) < NUM_FIELDS);
  |   74|     23|      return index >> 5;
  |   75|     23|    }/*_FORCE_COVER_END_*/
  ------------------
   76|  84.2k|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8FieldPosEm
  ------------------
  | _ZN3emp6BitSetILm128EE8FieldPosEm:
  |   76|  15.5k|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EE8FieldPosEm:
  |   76|      4|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm10EE8FieldPosEm:
  |   76|     30|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE8FieldPosEm:
  |   76|  68.5k|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE8FieldPosEm:
  |   76|     23|    /*_FORCE_COVER_START_*/inline static size_t FieldPos(const size_t index) { return index & 31; }/*_FORCE_COVER_END_*/
  ------------------
   77|       |
   78|      0|    /*_FORCE_COVER_START_*/inline static size_t Byte2Field(const size_t index) { return index/4; }/*_FORCE_COVER_END_*/
   79|      0|    /*_FORCE_COVER_START_*/inline static size_t Byte2FieldPos(const size_t index) { return (index & 3) << 3; }/*_FORCE_COVER_END_*/
   80|       |
   81|  1.00M|    /*_FORCE_COVER_START_*/inline void Copy(const uint32_t in_set[NUM_FIELDS]) {
   82|  3.12G|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
   83|  1.00M|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE4CopyEPKj
  ------------------
  | _ZN3emp6BitSetILm128EE4CopyEPKj:
  |   81|     73|    /*_FORCE_COVER_START_*/inline void Copy(const uint32_t in_set[NUM_FIELDS]) {
  |   82|    365|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
  |   83|     73|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EE4CopyEPKj:
  |   81|    304|    /*_FORCE_COVER_START_*/inline void Copy(const uint32_t in_set[NUM_FIELDS]) {
  |   82|  1.21k|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
  |   83|    304|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE4CopyEPKj:
  |   81|  1.00M|    /*_FORCE_COVER_START_*/inline void Copy(const uint32_t in_set[NUM_FIELDS]) {
  |   82|  3.12G|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
  |   83|  1.00M|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE4CopyEPKj:
  |   81|     35|    /*_FORCE_COVER_START_*/inline void Copy(const uint32_t in_set[NUM_FIELDS]) {
  |   82|     70|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
  |   83|     35|    }/*_FORCE_COVER_END_*/
  ------------------
   84|       |
   85|       |    /// Helper: call SHIFT with positive number instead
   86|   100k|    /*_FORCE_COVER_START_*/void ShiftLeft(const uint32_t shift_size) {
   87|   100k|      const int field_shift = shift_size / 32;
   88|   100k|      const int bit_shift = shift_size % 32;
   89|   100k|      const int bit_overflow = 32 - bit_shift;
   90|   100k|
   91|   100k|      // Loop through each field, from L to R, and update it.
   92|   100k|      if (field_shift) {
   93|      0|        for (int i = NUM_FIELDS - 1; i >= field_shift; --i) {
   94|      0|          bit_set[i] = bit_set[i - field_shift];
   95|      0|        }
   96|      0|        for (int i = field_shift - 1; i >= 0; i--) bit_set[i] = 0;
   97|      0|      }
   98|   100k|
   99|   100k|      // account for bit_shift
  100|   100k|      if (bit_shift) {
  101|   312M|        for (int i = NUM_FIELDS - 1; i > field_shift; --i) {
  102|   312M|          bit_set[i] <<= bit_shift;
  103|   312M|          bit_set[i] |= (bit_set[i-1] >> bit_overflow);
  104|   312M|        }
  105|   100k|        // Handle final field (field_shift position)
  106|   100k|        bit_set[field_shift] <<= bit_shift;
  107|   100k|      }
  108|   100k|
  109|   100k|      // Mask out any bits that have left-shifted away
  110|   100k|      if (LAST_BIT) { bit_set[NUM_FIELDS - 1] &= (1U << LAST_BIT) - 1U; }
  111|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE9ShiftLeftEj
  ------------------
  | _ZN3emp6BitSetILm80EE9ShiftLeftEj:
  |   86|      1|    /*_FORCE_COVER_START_*/void ShiftLeft(const uint32_t shift_size) {
  |   87|      1|      const int field_shift = shift_size / 32;
  |   88|      1|      const int bit_shift = shift_size % 32;
  |   89|      1|      const int bit_overflow = 32 - bit_shift;
  |   90|      1|
  |   91|      1|      // Loop through each field, from L to R, and update it.
  |   92|      1|      if (field_shift) {
  |   93|      0|        for (int i = NUM_FIELDS - 1; i >= field_shift; --i) {
  |   94|      0|          bit_set[i] = bit_set[i - field_shift];
  |   95|      0|        }
  |   96|      0|        for (int i = field_shift - 1; i >= 0; i--) bit_set[i] = 0;
  |   97|      0|      }
  |   98|      1|
  |   99|      1|      // account for bit_shift
  |  100|      1|      if (bit_shift) {
  |  101|      3|        for (int i = NUM_FIELDS - 1; i > field_shift; --i) {
  |  102|      2|          bit_set[i] <<= bit_shift;
  |  103|      2|          bit_set[i] |= (bit_set[i-1] >> bit_overflow);
  |  104|      2|        }
  |  105|      1|        // Handle final field (field_shift position)
  |  106|      1|        bit_set[field_shift] <<= bit_shift;
  |  107|      1|      }
  |  108|      1|
  |  109|      1|      // Mask out any bits that have left-shifted away
  |  110|      1|      if (LAST_BIT) { bit_set[NUM_FIELDS - 1] &= (1U << LAST_BIT) - 1U; }
  |  111|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE9ShiftLeftEj:
  |   86|   100k|    /*_FORCE_COVER_START_*/void ShiftLeft(const uint32_t shift_size) {
  |   87|   100k|      const int field_shift = shift_size / 32;
  |   88|   100k|      const int bit_shift = shift_size % 32;
  |   89|   100k|      const int bit_overflow = 32 - bit_shift;
  |   90|   100k|
  |   91|   100k|      // Loop through each field, from L to R, and update it.
  |   92|   100k|      if (field_shift) {
  |   93|      0|        for (int i = NUM_FIELDS - 1; i >= field_shift; --i) {
  |   94|      0|          bit_set[i] = bit_set[i - field_shift];
  |   95|      0|        }
  |   96|      0|        for (int i = field_shift - 1; i >= 0; i--) bit_set[i] = 0;
  |   97|      0|      }
  |   98|   100k|
  |   99|   100k|      // account for bit_shift
  |  100|   100k|      if (bit_shift) {
  |  101|   312M|        for (int i = NUM_FIELDS - 1; i > field_shift; --i) {
  |  102|   312M|          bit_set[i] <<= bit_shift;
  |  103|   312M|          bit_set[i] |= (bit_set[i-1] >> bit_overflow);
  |  104|   312M|        }
  |  105|   100k|        // Handle final field (field_shift position)
  |  106|   100k|        bit_set[field_shift] <<= bit_shift;
  |  107|   100k|      }
  |  108|   100k|
  |  109|   100k|      // Mask out any bits that have left-shifted away
  |  110|   100k|      if (LAST_BIT) { bit_set[NUM_FIELDS - 1] &= (1U << LAST_BIT) - 1U; }
  |  111|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE9ShiftLeftEj:
  |   86|      4|    /*_FORCE_COVER_START_*/void ShiftLeft(const uint32_t shift_size) {
  |   87|      4|      const int field_shift = shift_size / 32;
  |   88|      4|      const int bit_shift = shift_size % 32;
  |   89|      4|      const int bit_overflow = 32 - bit_shift;
  |   90|      4|
  |   91|      4|      // Loop through each field, from L to R, and update it.
  |   92|      4|      if (field_shift) {
  |   93|      0|        for (int i = NUM_FIELDS - 1; i >= field_shift; --i) {
  |   94|      0|          bit_set[i] = bit_set[i - field_shift];
  |   95|      0|        }
  |   96|      0|        for (int i = field_shift - 1; i >= 0; i--) bit_set[i] = 0;
  |   97|      0|      }
  |   98|      4|
  |   99|      4|      // account for bit_shift
  |  100|      4|      if (bit_shift) {
  |  101|      4|        for (int i = NUM_FIELDS - 1; i > field_shift; --i) {
  |  102|      0|          bit_set[i] <<= bit_shift;
  |  103|      0|          bit_set[i] |= (bit_set[i-1] >> bit_overflow);
  |  104|      0|        }
  |  105|      4|        // Handle final field (field_shift position)
  |  106|      4|        bit_set[field_shift] <<= bit_shift;
  |  107|      4|      }
  |  108|      4|
  |  109|      4|      // Mask out any bits that have left-shifted away
  |  110|      4|      if (LAST_BIT) { bit_set[NUM_FIELDS - 1] &= (1U << LAST_BIT) - 1U; }
  |  111|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  112|       |
  113|       |
  114|       |    /// Helper for calling SHIFT with negative number
  115|   100k|    /*_FORCE_COVER_START_*/void ShiftRight(const uint32_t shift_size) {
  116|   100k|      emp_assert(shift_size > 0);
  117|   100k|      const uint32_t field_shift = shift_size / 32;
  118|   100k|      const uint32_t bit_shift = shift_size % 32;
  119|   100k|      const uint32_t bit_overflow = 32 - bit_shift;
  120|   100k|
  121|   100k|      // account for field_shift
  122|   100k|      if (field_shift) {
  123|    120|        for (size_t i = 0; i < (NUM_FIELDS - field_shift); ++i) {
  124|     76|          bit_set[i] = bit_set[i + field_shift];
  125|     76|        }
  126|    100|        for (size_t i = NUM_FIELDS - field_shift; i < NUM_FIELDS; i++) bit_set[i] = 0;
  127|     44|      }
  128|   100k|
  129|   100k|      // account for bit_shift
  130|   100k|      if (bit_shift) {
  131|   312M|        for (size_t i = 0; i < (NUM_FIELDS - 1 - field_shift); ++i) {
  132|   312M|          bit_set[i] >>= bit_shift;
  133|   312M|          bit_set[i] |= (bit_set[i+1] << bit_overflow);
  134|   312M|        }
  135|   100k|        bit_set[NUM_FIELDS - 1 - field_shift] >>= bit_shift;
  136|   100k|      }
  137|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE10ShiftRightEj
  ------------------
  | _ZN3emp6BitSetILm80EE10ShiftRightEj:
  |  115|     75|    /*_FORCE_COVER_START_*/void ShiftRight(const uint32_t shift_size) {
  |  116|     75|      emp_assert(shift_size > 0);
  |  117|     75|      const uint32_t field_shift = shift_size / 32;
  |  118|     75|      const uint32_t bit_shift = shift_size % 32;
  |  119|     75|      const uint32_t bit_overflow = 32 - bit_shift;
  |  120|     75|
  |  121|     75|      // account for field_shift
  |  122|     75|      if (field_shift) {
  |  123|    120|        for (size_t i = 0; i < (NUM_FIELDS - field_shift); ++i) {
  |  124|     76|          bit_set[i] = bit_set[i + field_shift];
  |  125|     76|        }
  |  126|    100|        for (size_t i = NUM_FIELDS - field_shift; i < NUM_FIELDS; i++) bit_set[i] = 0;
  |  127|     44|      }
  |  128|     75|
  |  129|     75|      // account for bit_shift
  |  130|     75|      if (bit_shift) {
  |  131|    166|        for (size_t i = 0; i < (NUM_FIELDS - 1 - field_shift); ++i) {
  |  132|     93|          bit_set[i] >>= bit_shift;
  |  133|     93|          bit_set[i] |= (bit_set[i+1] << bit_overflow);
  |  134|     93|        }
  |  135|     73|        bit_set[NUM_FIELDS - 1 - field_shift] >>= bit_shift;
  |  136|     73|      }
  |  137|     75|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE10ShiftRightEj:
  |  115|   100k|    /*_FORCE_COVER_START_*/void ShiftRight(const uint32_t shift_size) {
  |  116|   100k|      emp_assert(shift_size > 0);
  |  117|   100k|      const uint32_t field_shift = shift_size / 32;
  |  118|   100k|      const uint32_t bit_shift = shift_size % 32;
  |  119|   100k|      const uint32_t bit_overflow = 32 - bit_shift;
  |  120|   100k|
  |  121|   100k|      // account for field_shift
  |  122|   100k|      if (field_shift) {
  |  123|      0|        for (size_t i = 0; i < (NUM_FIELDS - field_shift); ++i) {
  |  124|      0|          bit_set[i] = bit_set[i + field_shift];
  |  125|      0|        }
  |  126|      0|        for (size_t i = NUM_FIELDS - field_shift; i < NUM_FIELDS; i++) bit_set[i] = 0;
  |  127|      0|      }
  |  128|   100k|
  |  129|   100k|      // account for bit_shift
  |  130|   100k|      if (bit_shift) {
  |  131|   312M|        for (size_t i = 0; i < (NUM_FIELDS - 1 - field_shift); ++i) {
  |  132|   312M|          bit_set[i] >>= bit_shift;
  |  133|   312M|          bit_set[i] |= (bit_set[i+1] << bit_overflow);
  |  134|   312M|        }
  |  135|   100k|        bit_set[NUM_FIELDS - 1 - field_shift] >>= bit_shift;
  |  136|   100k|      }
  |  137|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE10ShiftRightEj:
  |  115|      1|    /*_FORCE_COVER_START_*/void ShiftRight(const uint32_t shift_size) {
  |  116|      1|      emp_assert(shift_size > 0);
  |  117|      1|      const uint32_t field_shift = shift_size / 32;
  |  118|      1|      const uint32_t bit_shift = shift_size % 32;
  |  119|      1|      const uint32_t bit_overflow = 32 - bit_shift;
  |  120|      1|
  |  121|      1|      // account for field_shift
  |  122|      1|      if (field_shift) {
  |  123|      0|        for (size_t i = 0; i < (NUM_FIELDS - field_shift); ++i) {
  |  124|      0|          bit_set[i] = bit_set[i + field_shift];
  |  125|      0|        }
  |  126|      0|        for (size_t i = NUM_FIELDS - field_shift; i < NUM_FIELDS; i++) bit_set[i] = 0;
  |  127|      0|      }
  |  128|      1|
  |  129|      1|      // account for bit_shift
  |  130|      1|      if (bit_shift) {
  |  131|      1|        for (size_t i = 0; i < (NUM_FIELDS - 1 - field_shift); ++i) {
  |  132|      0|          bit_set[i] >>= bit_shift;
  |  133|      0|          bit_set[i] |= (bit_set[i+1] << bit_overflow);
  |  134|      0|        }
  |  135|      1|        bit_set[NUM_FIELDS - 1 - field_shift] >>= bit_shift;
  |  136|      1|      }
  |  137|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  138|       |
  139|       |  public:
  140|       |    /// Constructor: Assume all zeroes in set
  141|    121|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEC2Ev
  ------------------
  | _ZN3emp6BitSetILm10EEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm32EEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm50EEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm64EEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EEC2Ev:
  |  141|      1|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EEC2Ev:
  |  141|      2|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EEC2Ev:
  |  141|    111|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EEC2Ev:
  |  141|      3|    /*_FORCE_COVER_START_*/BitSet() { Clear(); }/*_FORCE_COVER_END_*/
  ------------------
  142|       |
  143|       |    /// Copy constructor from another BitSet
  144|  1.00M|    /*_FORCE_COVER_START_*/BitSet(const BitSet & in_set) { Copy(in_set.bit_set); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEC2ERKS1_
  ------------------
  | _ZN3emp6BitSetILm128EEC2ERKS1_:
  |  144|     73|    /*_FORCE_COVER_START_*/BitSet(const BitSet & in_set) { Copy(in_set.bit_set); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EEC2ERKS1_:
  |  144|    304|    /*_FORCE_COVER_START_*/BitSet(const BitSet & in_set) { Copy(in_set.bit_set); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EEC2ERKS1_:
  |  144|  1.00M|    /*_FORCE_COVER_START_*/BitSet(const BitSet & in_set) { Copy(in_set.bit_set); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EEC2ERKS1_:
  |  144|     35|    /*_FORCE_COVER_START_*/BitSet(const BitSet & in_set) { Copy(in_set.bit_set); }/*_FORCE_COVER_END_*/
  ------------------
  145|       |
  146|       |    /// Constructor to generate a random BitSet.
  147|      0|    /*_FORCE_COVER_START_*/BitSet(Random & random, const double p1=0.5) { Randomize(random, p1); }/*_FORCE_COVER_END_*/
  148|       |
  149|       |    /// Destructor.
  150|       |    /*_FORCE_COVER_START_*/~BitSet() = default/*_FORCE_COVER_END_*/;
  151|       |
  152|       |    /// Assignment operator.
  153|      0|    /*_FORCE_COVER_START_*/BitSet & operator=(const BitSet<NUM_BITS> & in_set) {
  154|      0|      Copy(in_set.bit_set);
  155|      0|      return *this;
  156|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEaSERKS1_
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm20EEaSERKS1_
  ------------------
  157|       |
  158|       |    /// Set all bits randomly, with a given probability of being a 1.
  159|      0|    /*_FORCE_COVER_START_*/void Randomize(Random & random, const double p1=0.5) {
  160|      0|      for (size_t i = 0; i < NUM_BITS; i++) Set(i, random.P(p1));
  161|      0|    }/*_FORCE_COVER_END_*/
  162|       |
  163|       |    /// Assign from a BitSet of a different size.
  164|       |    /*_FORCE_COVER_START_*/template <size_t NUM_BITS2>
  165|      1|    /*_FORCE_COVER_START_*/BitSet & Import(const BitSet<NUM_BITS2> & in_set) {
  166|      1|      static const size_t NUM_FIELDS2 = 1 + ((NUM_BITS2 - 1) >> 5);
  167|      1|      static const size_t MIN_FIELDS = (NUM_FIELDS < NUM_FIELDS2) ? NUM_FIELDS : NUM_FIELDS2;
  168|      2|      for (size_t i = 0; i < MIN_FIELDS; i++) bit_set[i] = in_set.GetUInt(i);  // Copy avail fields
  169|      1|      for (size_t i = MIN_FIELDS; i < NUM_FIELDS; i++) bit_set[i] = 0;         // Zero extra fields
  170|      1|      return *this;
  171|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  172|       |
  173|       |    /// Convert to a Bitset of a different size.
  174|       |    /*_FORCE_COVER_START_*/template <size_t NUM_BITS2>
  175|       |    /*_FORCE_COVER_START_*/BitSet<NUM_BITS2> Export() const {
  176|       |      static const size_t NUM_FIELDS2 = 1 + ((NUM_BITS2 - 1) >> 5);
  177|       |      static const size_t MIN_FIELDS = (NUM_FIELDS < NUM_FIELDS2) ? NUM_FIELDS : NUM_FIELDS2;
  178|       |      BitSet<NUM_BITS2> out_bits;
  179|       |      for (size_t i = 0; i < MIN_FIELDS; i++) out_bits.SetUInt(i, bit_set[i]);  // Copy avail fields
  180|       |      for (size_t i = MIN_FIELDS; i < NUM_FIELDS; i++) out_bits.SetUInt(i, 0);  // Zero extra fields
  181|       |      return out_bits;
  182|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  183|       |
  184|       |    /// Test if two BitSet objects are identical.
  185|      0|    /*_FORCE_COVER_START_*/bool operator==(const BitSet & in_set) const {
  186|      0|      for (size_t i = 0; i < NUM_FIELDS; ++i) {
  187|      0|        if (bit_set[i] != in_set.bit_set[i]) return false;
  188|      0|      }
  189|      0|      return true;
  190|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEeqERKS1_
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EEeqERKS1_
  ------------------
  191|       |
  192|       |    /// Compare two BitSet objects, based on the associated binary value.
  193|      0|    /*_FORCE_COVER_START_*/bool operator<(const BitSet & in_set) const {
  194|      0|      for (int i = NUM_FIELDS-1; i >= 0; --i) {         // Start loop at the largest field.
  195|      0|        if (bit_set[i] == in_set.bit_set[i]) continue;  // If same, keep looking!
  196|      0|        return (bit_set[i] < in_set.bit_set[i]);        // Otherwise, do comparison
  197|      0|      }
  198|      0|      return false;
  199|      0|    }/*_FORCE_COVER_END_*/
  200|       |
  201|       |    /// Compare two BitSet objects, based on the associated binary value.
  202|      0|    /*_FORCE_COVER_START_*/bool operator<=(const BitSet & in_set) const {
  203|      0|      for (int i = NUM_FIELDS-1; i >= 0; --i) {         // Start loop at the largest field.
  204|      0|        if (bit_set[i] == in_set.bit_set[i]) continue;  // If same, keep looking!
  205|      0|        return (bit_set[i] < in_set.bit_set[i]);        // Otherwise, do comparison
  206|      0|      }
  207|      0|      return true;
  208|      0|    }/*_FORCE_COVER_END_*/
  209|       |
  210|       |    /// Test if two BitSet objects are different.
  211|      0|    /*_FORCE_COVER_START_*/bool operator!=(const BitSet & in_set) const { return !operator==(in_set); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEneERKS1_
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EEneERKS1_
  ------------------
  212|       |
  213|       |    /// Compare two BitSet objects, based on the associated binary value.
  214|      0|    /*_FORCE_COVER_START_*/bool operator>(const BitSet & in_set) const { return !operator<=(in_set); }/*_FORCE_COVER_END_*/
  215|       |
  216|       |    /// Compare two BitSet objects, based on the associated binary value.
  217|      0|    /*_FORCE_COVER_START_*/bool operator>=(const BitSet & in_set) const { return !operator<(in_set); }/*_FORCE_COVER_END_*/
  218|       |
  219|       |    /// How many bits are in this BitSet?
  220|      0|    /*_FORCE_COVER_START_*/constexpr static size_t GetSize() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  221|       |
  222|       |    /// Retrieve the bit as a specified index.
  223|  14.4k|    /*_FORCE_COVER_START_*/bool Get(size_t index) const {
  224|  14.4k|      emp_assert(index >= 0 && index < NUM_BITS);
  225|  14.4k|      const size_t field_id = FieldID(index);
  226|  14.4k|      const size_t pos_id = FieldPos(index);
  227|  14.4k|      return (bit_set[field_id] & (1 << pos_id)) != 0;
  228|  14.4k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3GetEm
  ------------------
  | _ZNK3emp6BitSetILm128EE3GetEm:
  |  223|  14.4k|    /*_FORCE_COVER_START_*/bool Get(size_t index) const {
  |  224|  14.4k|      emp_assert(index >= 0 && index < NUM_BITS);
  |  225|  14.4k|      const size_t field_id = FieldID(index);
  |  226|  14.4k|      const size_t pos_id = FieldPos(index);
  |  227|  14.4k|      return (bit_set[field_id] & (1 << pos_id)) != 0;
  |  228|  14.4k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm10EE3GetEm:
  |  223|     24|    /*_FORCE_COVER_START_*/bool Get(size_t index) const {
  |  224|     24|      emp_assert(index >= 0 && index < NUM_BITS);
  |  225|     24|      const size_t field_id = FieldID(index);
  |  226|     24|      const size_t pos_id = FieldPos(index);
  |  227|     24|      return (bit_set[field_id] & (1 << pos_id)) != 0;
  |  228|     24|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EE3GetEm:
  |  223|     13|    /*_FORCE_COVER_START_*/bool Get(size_t index) const {
  |  224|     13|      emp_assert(index >= 0 && index < NUM_BITS);
  |  225|     13|      const size_t field_id = FieldID(index);
  |  226|     13|      const size_t pos_id = FieldPos(index);
  |  227|     13|      return (bit_set[field_id] & (1 << pos_id)) != 0;
  |  228|     13|    }/*_FORCE_COVER_END_*/
  ------------------
  229|       |
  230|       |    /// Set the bit as a specified index.
  231|  69.7k|    /*_FORCE_COVER_START_*/void Set(size_t index, bool value) {
  232|  69.7k|      emp_assert(index < NUM_BITS);
  233|  69.7k|      const size_t field_id = FieldID(index);
  234|  69.7k|      const size_t pos_id = FieldPos(index);
  235|  69.7k|      const uint32_t pos_mask = 1 << pos_id;
  236|  69.7k|
  237|  69.7k|      if (value) bit_set[field_id] |= pos_mask;
  238|      0|      else       bit_set[field_id] &= ~pos_mask;
  239|  69.7k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE3SetEmb
  ------------------
  | _ZN3emp6BitSetILm80EE3SetEmb:
  |  231|      2|    /*_FORCE_COVER_START_*/void Set(size_t index, bool value) {
  |  232|      2|      emp_assert(index < NUM_BITS);
  |  233|      2|      const size_t field_id = FieldID(index);
  |  234|      2|      const size_t pos_id = FieldPos(index);
  |  235|      2|      const uint32_t pos_mask = 1 << pos_id;
  |  236|      2|
  |  237|      2|      if (value) bit_set[field_id] |= pos_mask;
  |  238|      0|      else       bit_set[field_id] &= ~pos_mask;
  |  239|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE3SetEmb:
  |  231|  68.5k|    /*_FORCE_COVER_START_*/void Set(size_t index, bool value) {
  |  232|  68.5k|      emp_assert(index < NUM_BITS);
  |  233|  68.5k|      const size_t field_id = FieldID(index);
  |  234|  68.5k|      const size_t pos_id = FieldPos(index);
  |  235|  68.5k|      const uint32_t pos_mask = 1 << pos_id;
  |  236|  68.5k|
  |  237|  68.5k|      if (value) bit_set[field_id] |= pos_mask;
  |  238|      0|      else       bit_set[field_id] &= ~pos_mask;
  |  239|  68.5k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE3SetEmb:
  |  231|  1.17k|    /*_FORCE_COVER_START_*/void Set(size_t index, bool value) {
  |  232|  1.17k|      emp_assert(index < NUM_BITS);
  |  233|  1.17k|      const size_t field_id = FieldID(index);
  |  234|  1.17k|      const size_t pos_id = FieldPos(index);
  |  235|  1.17k|      const uint32_t pos_mask = 1 << pos_id;
  |  236|  1.17k|
  |  237|  1.17k|      if (value) bit_set[field_id] |= pos_mask;
  |  238|      0|      else       bit_set[field_id] &= ~pos_mask;
  |  239|  1.17k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE3SetEmb:
  |  231|     10|    /*_FORCE_COVER_START_*/void Set(size_t index, bool value) {
  |  232|     10|      emp_assert(index < NUM_BITS);
  |  233|     10|      const size_t field_id = FieldID(index);
  |  234|     10|      const size_t pos_id = FieldPos(index);
  |  235|     10|      const uint32_t pos_mask = 1 << pos_id;
  |  236|     10|
  |  237|     10|      if (value) bit_set[field_id] |= pos_mask;
  |  238|      0|      else       bit_set[field_id] &= ~pos_mask;
  |  239|     10|    }/*_FORCE_COVER_END_*/
  ------------------
  240|       |
  241|       |    /// Flip all bits in this BitSet
  242|      0|    /*_FORCE_COVER_START_*/BitSet & Toggle() { return NOT_SELF(); }/*_FORCE_COVER_END_*/
  243|       |
  244|       |    /// Flip a single bit
  245|      6|    /*_FORCE_COVER_START_*/BitSet & Toggle(size_t index) {
  246|      6|      emp_assert(index >= 0 && index < NUM_BITS);
  247|      6|      const size_t field_id = FieldID(index);
  248|      6|      const size_t pos_id = FieldPos(index);
  249|      6|      (bit_set[field_id] ^= (1 << pos_id));
  250|      6|      return *this;
  251|      6|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE6ToggleEm
  ------------------
  | _ZN3emp6BitSetILm10EE6ToggleEm:
  |  245|      6|    /*_FORCE_COVER_START_*/BitSet & Toggle(size_t index) {
  |  246|      6|      emp_assert(index >= 0 && index < NUM_BITS);
  |  247|      6|      const size_t field_id = FieldID(index);
  |  248|      6|      const size_t pos_id = FieldPos(index);
  |  249|      6|      (bit_set[field_id] ^= (1 << pos_id));
  |  250|      6|      return *this;
  |  251|      6|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm20EE6ToggleEm
  ------------------
  252|       |
  253|       |    /// Flips all the bits in a range [start, end)
  254|      1|    /*_FORCE_COVER_START_*/BitSet & Toggle(size_t start, size_t end) {
  255|      1|      emp_assert(start <= end && end <= NUM_BITS);
  256|      6|      for(size_t index = start; index < end; index++) {
  257|      5|        Toggle(index);
  258|      5|      }
  259|      1|      return *this;
  260|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE6ToggleEmm
  ------------------
  | _ZN3emp6BitSetILm10EE6ToggleEmm:
  |  254|      1|    /*_FORCE_COVER_START_*/BitSet & Toggle(size_t start, size_t end) {
  |  255|      1|      emp_assert(start <= end && end <= NUM_BITS);
  |  256|      6|      for(size_t index = start; index < end; index++) {
  |  257|      5|        Toggle(index);
  |  258|      5|      }
  |  259|      1|      return *this;
  |  260|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  261|       |
  262|       |    /// Get the full byte starting from the bit at a specified index.
  263|      0|    /*_FORCE_COVER_START_*/uint8_t GetByte(size_t index) const {
  264|      0|      emp_assert(index < NUM_BYTES);
  265|      0|      const size_t field_id = Byte2Field(index);
  266|      0|      const size_t pos_id = Byte2FieldPos(index);
  267|      0|      return (bit_set[field_id] >> pos_id) & 255;
  268|      0|    }/*_FORCE_COVER_END_*/
  269|       |
  270|       |    /// Set the full byte starting at the bit at the specified index.
  271|      0|    /*_FORCE_COVER_START_*/void SetByte(size_t index, uint8_t value) {
  272|      0|      emp_assert(index < NUM_BYTES);
  273|      0|      const size_t field_id = Byte2Field(index);
  274|      0|      const size_t pos_id = Byte2FieldPos(index);
  275|      0|      const uint32_t val_uint = value;
  276|      0|      bit_set[field_id] = (bit_set[field_id] & ~(255U << pos_id)) | (val_uint << pos_id);
  277|      0|    }/*_FORCE_COVER_END_*/
  278|       |
  279|       |    /// Get the 32-bit unsigned int; index in in 32-bit jumps (i.e., this is a field ID not bit id)
  280|      2|    /*_FORCE_COVER_START_*/uint32_t GetUInt(size_t index) const {
  281|      2|      emp_assert(index < NUM_FIELDS);
  282|      2|      return bit_set[index];
  283|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE7GetUIntEm
  ------------------
  | _ZNK3emp6BitSetILm80EE7GetUIntEm:
  |  280|      1|    /*_FORCE_COVER_START_*/uint32_t GetUInt(size_t index) const {
  |  281|      1|      emp_assert(index < NUM_FIELDS);
  |  282|      1|      return bit_set[index];
  |  283|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm10EE7GetUIntEm:
  |  280|      1|    /*_FORCE_COVER_START_*/uint32_t GetUInt(size_t index) const {
  |  281|      1|      emp_assert(index < NUM_FIELDS);
  |  282|      1|      return bit_set[index];
  |  283|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  284|       |
  285|       |    /// Set the 32-bit unsigned int; index in in 32-bit jumps (i.e., this is a field ID not bit id)
  286|      0|    /*_FORCE_COVER_START_*/void SetUInt(size_t index, uint32_t value) {
  287|      0|      emp_assert(index < NUM_FIELDS);
  288|      0|      bit_set[index] = value;
  289|      0|    }/*_FORCE_COVER_END_*/
  290|       |
  291|       |    /// Get the full 32-bit unsigned int starting from the bit at a specified index.
  292|      2|    /*_FORCE_COVER_START_*/uint32_t GetUIntAtBit(size_t index) {
  293|      2|      emp_assert(index < NUM_BITS);
  294|      2|      const size_t field_id = FieldID(index);
  295|      2|      const size_t pos_id = FieldPos(index);
  296|      2|      if (pos_id == 0) return bit_set[field_id];
  297|      0|      return (bit_set[field_id] >> pos_id) |
  298|      0|        ((field_id+1 < NUM_FIELDS) ? bit_set[field_id+1] << (32-pos_id) : 0);
  299|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE12GetUIntAtBitEm
  ------------------
  | _ZN3emp6BitSetILm80EE12GetUIntAtBitEm:
  |  292|      2|    /*_FORCE_COVER_START_*/uint32_t GetUIntAtBit(size_t index) {
  |  293|      2|      emp_assert(index < NUM_BITS);
  |  294|      2|      const size_t field_id = FieldID(index);
  |  295|      2|      const size_t pos_id = FieldPos(index);
  |  296|      2|      if (pos_id == 0) return bit_set[field_id];
  |  297|      0|      return (bit_set[field_id] >> pos_id) |
  |  298|      0|        ((field_id+1 < NUM_FIELDS) ? bit_set[field_id+1] << (32-pos_id) : 0);
  |  299|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  300|       |
  301|       |    /// Get OUT_BITS bits starting from the bit at a specified index (max 32)
  302|       |    /*_FORCE_COVER_START_*/template <size_t OUT_BITS>
  303|      1|    /*_FORCE_COVER_START_*/uint32_t GetValueAtBit(size_t index) {
  304|      1|      static_assert(OUT_BITS <= 32, "Requesting too many bits to fit in a UInt");
  305|      1|      return GetUIntAtBit(index) & MaskLow<uint32_t>(OUT_BITS);
  306|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  307|       |
  308|       |    /// Return true if ANY bits in the BitSet are one, else return false.
  309|      8|    /*_FORCE_COVER_START_*/bool Any() const { for (auto i : bit_set) if (i) return true; return false; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3AnyEv
  ------------------
  | _ZNK3emp6BitSetILm20EE3AnyEv:
  |  309|      8|    /*_FORCE_COVER_START_*/bool Any() const { for (auto i : bit_set) if (i) return true; return false; }/*_FORCE_COVER_END_*/
  ------------------
  310|       |
  311|       |    /// Return true if NO bits in the BitSet are one, else return false.
  312|      3|    /*_FORCE_COVER_START_*/bool None() const { return !Any(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE4NoneEv
  ------------------
  | _ZNK3emp6BitSetILm20EE4NoneEv:
  |  312|      3|    /*_FORCE_COVER_START_*/bool None() const { return !Any(); }/*_FORCE_COVER_END_*/
  ------------------
  313|       |
  314|       |    /// Return true if ALL bits in the BitSet are one, else return false.
  315|      3|    /*_FORCE_COVER_START_*/bool All() const { return (~(*this)).None(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3AllEv
  ------------------
  | _ZNK3emp6BitSetILm20EE3AllEv:
  |  315|      3|    /*_FORCE_COVER_START_*/bool All() const { return (~(*this)).None(); }/*_FORCE_COVER_END_*/
  ------------------
  316|       |
  317|       |    /// Index into a const BitSet (i.e., cannot be set this way.)
  318|  14.4k|    /*_FORCE_COVER_START_*/bool operator[](size_t index) const { return Get(index); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEixEm
  ------------------
  | _ZNK3emp6BitSetILm128EEixEm:
  |  318|  14.4k|    /*_FORCE_COVER_START_*/bool operator[](size_t index) const { return Get(index); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EEixEm:
  |  318|     13|    /*_FORCE_COVER_START_*/bool operator[](size_t index) const { return Get(index); }/*_FORCE_COVER_END_*/
  ------------------
  319|       |
  320|       |    /// Index into a BitSet, returning a proxy that will allow bit assignment to work.
  321|  41.2k|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEixEm
  ------------------
  | _ZN3emp6BitSetILm80EEixEm:
  |  321|      2|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm10EEixEm:
  |  321|     12|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EEixEm:
  |  321|  40.0k|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EEixEm:
  |  321|  1.17k|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EEixEm:
  |  321|     10|    /*_FORCE_COVER_START_*/BitProxy operator[](size_t index) { return BitProxy(*this, index); }/*_FORCE_COVER_END_*/
  ------------------
  322|       |
  323|       |    /// Set all bits to zero.
  324|  6.70k|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE5ClearEv
  ------------------
  | _ZN3emp6BitSetILm10EE5ClearEv:
  |  324|      1|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm32EE5ClearEv:
  |  324|      1|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm50EE5ClearEv:
  |  324|      2|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm64EE5ClearEv:
  |  324|      2|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm80EE5ClearEv:
  |  324|      3|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE5ClearEv:
  |  324|  6.25k|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE5ClearEv:
  |  324|    444|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE5ClearEv:
  |  324|      5|    /*_FORCE_COVER_START_*/void Clear() { for (auto & i : bit_set) i = 0U; }/*_FORCE_COVER_END_*/
  ------------------
  325|       |
  326|       |    /// Set all bits to one.
  327|      1|    /*_FORCE_COVER_START_*/void SetAll() {
  328|      1|      for (auto & i : bit_set) i = ~0U;
  329|      1|      if (LAST_BIT > 0) { bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT); }
  330|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE6SetAllEv
  ------------------
  | _ZN3emp6BitSetILm20EE6SetAllEv:
  |  327|      1|    /*_FORCE_COVER_START_*/void SetAll() {
  |  328|      1|      for (auto & i : bit_set) i = ~0U;
  |  329|      1|      if (LAST_BIT > 0) { bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT); }
  |  330|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  331|       |
  332|       |    /// Print all bits to the provided output stream.
  333|      0|    /*_FORCE_COVER_START_*/void Print(std::ostream & out=std::cout) const {
  334|      0|      for (size_t i = NUM_BITS; i > 0; i--) { out << Get(i-1); }
  335|      0|    }/*_FORCE_COVER_END_*/
  336|       |
  337|       |    /// Print all bits from smallest to largest, as if this were an array, not a bit representation.
  338|      0|    /*_FORCE_COVER_START_*/void PrintArray(std::ostream & out=std::cout) const {
  339|      0|      for (size_t i = 0; i < NUM_BITS; i++) out << Get(i);
  340|      0|    }/*_FORCE_COVER_END_*/
  341|       |
  342|       |    /// Print the locations of all one bits, using the provided spacer (default is a single space)
  343|      0|    /*_FORCE_COVER_START_*/void PrintOneIDs(std::ostream & out=std::cout, char spacer=' ') const {
  344|      0|      for (size_t i = 0; i < NUM_BITS; i++) { if (Get(i)) out << i << spacer; }
  345|      0|    }/*_FORCE_COVER_END_*/
  346|       |
  347|       |    /// Count 1's by looping through once for each bit equal to 1
  348|      0|    /*_FORCE_COVER_START_*/size_t CountOnes_Sparse() const {
  349|      0|      size_t bit_count = 0;
  350|      0|      for (auto i : bit_set) {
  351|      0|        while (i) {
  352|      0|          i &= (i-1);       // Peel off a single 1.
  353|      0|          bit_count++;      // And increment the counter
  354|      0|        }
  355|      0|      }
  356|      0|      return bit_count;
  357|      0|    }/*_FORCE_COVER_END_*/
  358|       |
  359|       |    /// Count 1's in semi-parallel; fastest for even 0's & 1's
  360|   100k|    /*_FORCE_COVER_START_*/size_t CountOnes_Mixed() const {
  361|   100k|      size_t bit_count = 0;
  362|   312M|      for (const auto v : bit_set) {
  363|   312M|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  364|   312M|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  365|   312M|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  366|   312M|      }
  367|   100k|      return bit_count;
  368|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE15CountOnes_MixedEv
  ------------------
  | _ZNK3emp6BitSetILm80EE15CountOnes_MixedEv:
  |  360|     75|    /*_FORCE_COVER_START_*/size_t CountOnes_Mixed() const {
  |  361|     75|      size_t bit_count = 0;
  |  362|    225|      for (const auto v : bit_set) {
  |  363|    225|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  |  364|    225|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  |  365|    225|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  |  366|    225|      }
  |  367|     75|      return bit_count;
  |  368|     75|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm100000EE15CountOnes_MixedEv:
  |  360|   100k|    /*_FORCE_COVER_START_*/size_t CountOnes_Mixed() const {
  |  361|   100k|      size_t bit_count = 0;
  |  362|   312M|      for (const auto v : bit_set) {
  |  363|   312M|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  |  364|   312M|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  |  365|   312M|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  |  366|   312M|      }
  |  367|   100k|      return bit_count;
  |  368|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm128EE15CountOnes_MixedEv:
  |  360|     10|    /*_FORCE_COVER_START_*/size_t CountOnes_Mixed() const {
  |  361|     10|      size_t bit_count = 0;
  |  362|     40|      for (const auto v : bit_set) {
  |  363|     40|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  |  364|     40|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  |  365|     40|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  |  366|     40|      }
  |  367|     10|      return bit_count;
  |  368|     10|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EE15CountOnes_MixedEv:
  |  360|      2|    /*_FORCE_COVER_START_*/size_t CountOnes_Mixed() const {
  |  361|      2|      size_t bit_count = 0;
  |  362|      2|      for (const auto v : bit_set) {
  |  363|      2|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  |  364|      2|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  |  365|      2|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  |  366|      2|      }
  |  367|      2|      return bit_count;
  |  368|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  369|       |
  370|       |    /// Count the number of ones in the BitSet using bit tricks for a speedup.
  371|   100k|    /*_FORCE_COVER_START_*/size_t CountOnes() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE9CountOnesEv
  ------------------
  | _ZNK3emp6BitSetILm80EE9CountOnesEv:
  |  371|     75|    /*_FORCE_COVER_START_*/size_t CountOnes() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm100000EE9CountOnesEv:
  |  371|   100k|    /*_FORCE_COVER_START_*/size_t CountOnes() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm128EE9CountOnesEv:
  |  371|     10|    /*_FORCE_COVER_START_*/size_t CountOnes() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  372|       |
  373|       |    /// Return the index of the first one in the sequence; return -1 if no ones are available.
  374|      3|    /*_FORCE_COVER_START_*/int FindBit() const {
  375|      3|      size_t field_id = 0;
  376|      5|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  377|      3|      return (field_id < NUM_FIELDS) ? (int) (find_bit(bit_set[field_id]) + (field_id << 5)) : -1;
  378|      3|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE7FindBitEv
  ------------------
  | _ZNK3emp6BitSetILm128EE7FindBitEv:
  |  374|      2|    /*_FORCE_COVER_START_*/int FindBit() const {
  |  375|      2|      size_t field_id = 0;
  |  376|      4|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  |  377|      2|      return (field_id < NUM_FIELDS) ? (int) (find_bit(bit_set[field_id]) + (field_id << 5)) : -1;
  |  378|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EE7FindBitEv:
  |  374|      1|    /*_FORCE_COVER_START_*/int FindBit() const {
  |  375|      1|      size_t field_id = 0;
  |  376|      1|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  |  377|      1|      return (field_id < NUM_FIELDS) ? (int) (find_bit(bit_set[field_id]) + (field_id << 5)) : -1;
  |  378|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  379|       |
  380|       |    /// Return index of first one in sequence (or -1 if no ones); change this position to zero.
  381|      0|    /*_FORCE_COVER_START_*/int PopBit() {
  382|      0|      size_t field_id = 0;
  383|      0|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  384|      0|      if (field_id == NUM_FIELDS) return -1;  // Failed to find bit!
  385|      0|
  386|      0|      const int pos_found = (int) find_bit(bit_set[field_id]);
  387|      0|      bit_set[field_id] &= ~(1U << pos_found);
  388|      0|      return pos_found + (int)(field_id << 5);
  389|      0|    }/*_FORCE_COVER_END_*/
  390|       |
  391|       |    /// Return index of first one in sequence AFTER start_pos (or -1 if no ones)
  392|      0|    /*_FORCE_COVER_START_*/int FindBit(const size_t start_pos) const {
  393|      0|      // @CAO -- There are better ways to do this with bit tricks
  394|      0|      //         (but start_pos is tricky...)
  395|      0|      for (size_t i = start_pos; i < NUM_BITS; i++) {
  396|      0|        if (Get(i)) return (int) i;
  397|      0|      }
  398|      0|      return -1;
  399|      0|    }/*_FORCE_COVER_END_*/
  400|       |
  401|       |    /// Return a vector indicating the posistions of all ones in the BitSet.
  402|      0|    /*_FORCE_COVER_START_*/emp::vector<size_t> GetOnes() const {
  403|      0|      // @CAO -- There are better ways to do this with bit tricks.
  404|      0|      emp::vector<size_t> out_set(CountOnes());
  405|      0|      size_t cur_pos = 0;
  406|      0|      for (size_t i = 0; i < NUM_BITS; i++) {
  407|      0|        if (Get(i)) out_set[cur_pos++] = i;
  408|      0|      }
  409|      0|      return out_set;
  410|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE7GetOnesEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm128EE7GetOnesEv
  ------------------
  411|       |
  412|       |    /// Perform a Boolean NOT on this BitSet and return the result.
  413|      5|    /*_FORCE_COVER_START_*/BitSet NOT() const {
  414|      5|      BitSet out_set(*this);
  415|     10|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~bit_set[i];
  416|      5|      if (LAST_BIT > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  417|      5|      return out_set;
  418|      5|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3NOTEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm128EE3NOTEv
  ------------------
  | _ZNK3emp6BitSetILm20EE3NOTEv:
  |  413|      5|    /*_FORCE_COVER_START_*/BitSet NOT() const {
  |  414|      5|      BitSet out_set(*this);
  |  415|     10|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~bit_set[i];
  |  416|      5|      if (LAST_BIT > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  |  417|      5|      return out_set;
  |  418|      5|    }/*_FORCE_COVER_END_*/
  ------------------
  419|       |
  420|       |    /// Perform a Boolean AND with a second BitSet and return the result.
  421|   100k|    /*_FORCE_COVER_START_*/BitSet AND(const BitSet & set2) const {
  422|   100k|      BitSet out_set(*this);
  423|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] & set2.bit_set[i];
  424|   100k|      return out_set;
  425|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3ANDERKS1_
  ------------------
  | _ZNK3emp6BitSetILm100000EE3ANDERKS1_:
  |  421|   100k|    /*_FORCE_COVER_START_*/BitSet AND(const BitSet & set2) const {
  |  422|   100k|      BitSet out_set(*this);
  |  423|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] & set2.bit_set[i];
  |  424|   100k|      return out_set;
  |  425|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EE3ANDERKS1_
  ------------------
  426|       |
  427|       |    /// Perform a Boolean OR with a second BitSet and return the result.
  428|      1|    /*_FORCE_COVER_START_*/BitSet OR(const BitSet & set2) const {
  429|      1|      BitSet out_set(*this);
  430|  3.12k|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] | set2.bit_set[i];
  431|      1|      return out_set;
  432|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE2ORERKS1_
  ------------------
  | _ZNK3emp6BitSetILm100000EE2ORERKS1_:
  |  428|      1|    /*_FORCE_COVER_START_*/BitSet OR(const BitSet & set2) const {
  |  429|      1|      BitSet out_set(*this);
  |  430|  3.12k|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] | set2.bit_set[i];
  |  431|      1|      return out_set;
  |  432|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EE2ORERKS1_
  ------------------
  433|       |
  434|       |    /// Perform a Boolean NAND with a second BitSet and return the result.
  435|      0|    /*_FORCE_COVER_START_*/BitSet NAND(const BitSet & set2) const {
  436|      0|      BitSet out_set(*this);
  437|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] & set2.bit_set[i]);
  438|      0|      if (LAST_BIT > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  439|      0|      return out_set;
  440|      0|    }/*_FORCE_COVER_END_*/
  441|       |
  442|       |    /// Perform a Boolean NOR with a second BitSet and return the result.
  443|      0|    /*_FORCE_COVER_START_*/BitSet NOR(const BitSet & set2) const {
  444|      0|      BitSet out_set(*this);
  445|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] | set2.bit_set[i]);
  446|      0|      if (LAST_BIT > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  447|      0|      return out_set;
  448|      0|    }/*_FORCE_COVER_END_*/
  449|       |
  450|       |    /// Perform a Boolean XOR with a second BitSet and return the result.
  451|      0|    /*_FORCE_COVER_START_*/BitSet XOR(const BitSet & set2) const {
  452|      0|      BitSet out_set(*this);
  453|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] ^ set2.bit_set[i];
  454|      0|      return out_set;
  455|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3XORERKS1_
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EE3XORERKS1_
  ------------------
  456|       |
  457|       |    /// Perform a Boolean EQU with a second BitSet and return the result.
  458|      0|    /*_FORCE_COVER_START_*/BitSet EQU(const BitSet & set2) const {
  459|      0|      BitSet out_set(*this);
  460|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] ^ set2.bit_set[i]);
  461|      0|      if (LAST_BIT > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  462|      0|      return out_set;
  463|      0|    }/*_FORCE_COVER_END_*/
  464|       |
  465|       |
  466|       |    /// Perform a Boolean NOT on this BitSet, store result here, and return this object.
  467|      4|    /*_FORCE_COVER_START_*/BitSet & NOT_SELF() {
  468|     20|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~bit_set[i];
  469|      4|      if (LAST_BIT > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  470|      4|      return *this;
  471|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8NOT_SELFEv
  ------------------
  | _ZN3emp6BitSetILm128EE8NOT_SELFEv:
  |  467|      4|    /*_FORCE_COVER_START_*/BitSet & NOT_SELF() {
  |  468|     20|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~bit_set[i];
  |  469|      4|      if (LAST_BIT > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  |  470|      4|      return *this;
  |  471|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  472|       |
  473|       |    /// Perform a Boolean AND with a second BitSet, store result here, and return this object.
  474|   100k|    /*_FORCE_COVER_START_*/BitSet & AND_SELF(const BitSet & set2) {
  475|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] & set2.bit_set[i];
  476|   100k|      return *this;
  477|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8AND_SELFERKS1_
  ------------------
  | _ZN3emp6BitSetILm100000EE8AND_SELFERKS1_:
  |  474|   100k|    /*_FORCE_COVER_START_*/BitSet & AND_SELF(const BitSet & set2) {
  |  475|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] & set2.bit_set[i];
  |  476|   100k|      return *this;
  |  477|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE8AND_SELFERKS1_:
  |  474|      2|    /*_FORCE_COVER_START_*/BitSet & AND_SELF(const BitSet & set2) {
  |  475|      4|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] & set2.bit_set[i];
  |  476|      2|      return *this;
  |  477|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  478|       |
  479|       |    /// Perform a Boolean OR with a second BitSet, store result here, and return this object.
  480|   100k|    /*_FORCE_COVER_START_*/BitSet & OR_SELF(const BitSet & set2) {
  481|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] | set2.bit_set[i];
  482|   100k|      return *this;
  483|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE7OR_SELFERKS1_
  ------------------
  | _ZN3emp6BitSetILm100000EE7OR_SELFERKS1_:
  |  480|   100k|    /*_FORCE_COVER_START_*/BitSet & OR_SELF(const BitSet & set2) {
  |  481|   312M|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] | set2.bit_set[i];
  |  482|   100k|      return *this;
  |  483|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE7OR_SELFERKS1_:
  |  480|     12|    /*_FORCE_COVER_START_*/BitSet & OR_SELF(const BitSet & set2) {
  |  481|     60|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] | set2.bit_set[i];
  |  482|     12|      return *this;
  |  483|     12|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE7OR_SELFERKS1_:
  |  480|      3|    /*_FORCE_COVER_START_*/BitSet & OR_SELF(const BitSet & set2) {
  |  481|      6|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] | set2.bit_set[i];
  |  482|      3|      return *this;
  |  483|      3|    }/*_FORCE_COVER_END_*/
  ------------------
  484|       |
  485|       |    /// Perform a Boolean NAND with a second BitSet, store result here, and return this object.
  486|      0|    /*_FORCE_COVER_START_*/BitSet & NAND_SELF(const BitSet & set2) {
  487|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] & set2.bit_set[i]);
  488|      0|      if (LAST_BIT > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  489|      0|      return *this;
  490|      0|    }/*_FORCE_COVER_END_*/
  491|       |
  492|       |    /// Perform a Boolean NOR with a second BitSet, store result here, and return this object.
  493|      0|    /*_FORCE_COVER_START_*/BitSet & NOR_SELF(const BitSet & set2) {
  494|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] | set2.bit_set[i]);
  495|      0|      if (LAST_BIT > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  496|      0|      return *this;
  497|      0|    }/*_FORCE_COVER_END_*/
  498|       |
  499|       |    /// Perform a Boolean XOR with a second BitSet, store result here, and return this object.
  500|      0|    /*_FORCE_COVER_START_*/BitSet & XOR_SELF(const BitSet & set2) {
  501|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] ^ set2.bit_set[i];
  502|      0|      return *this;
  503|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE8XOR_SELFERKS1_
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm20EE8XOR_SELFERKS1_
  ------------------
  504|       |
  505|       |    /// Perform a Boolean EQU with a second BitSet, store result here, and return this object.
  506|      0|    /*_FORCE_COVER_START_*/BitSet & EQU_SELF(const BitSet & set2) {
  507|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] ^ set2.bit_set[i]);
  508|      0|      if (LAST_BIT > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<uint32_t>(LAST_BIT);
  509|      0|      return *this;
  510|      0|    }/*_FORCE_COVER_END_*/
  511|       |
  512|       |    /// Positive shifts go left and negative go right (0 does nothing); return result.
  513|   200k|    /*_FORCE_COVER_START_*/BitSet SHIFT(const int shift_size) const {
  514|   200k|      BitSet out_set(*this);
  515|   200k|      if (shift_size > 0) out_set.ShiftRight((uint32_t) shift_size);
  516|   100k|      else if (shift_size < 0) out_set.ShiftLeft((uint32_t) (-shift_size));
  517|   200k|      return out_set;
  518|   200k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE5SHIFTEi
  ------------------
  | _ZNK3emp6BitSetILm80EE5SHIFTEi:
  |  513|     76|    /*_FORCE_COVER_START_*/BitSet SHIFT(const int shift_size) const {
  |  514|     76|      BitSet out_set(*this);
  |  515|     76|      if (shift_size > 0) out_set.ShiftRight((uint32_t) shift_size);
  |  516|      1|      else if (shift_size < 0) out_set.ShiftLeft((uint32_t) (-shift_size));
  |  517|     76|      return out_set;
  |  518|     76|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm100000EE5SHIFTEi:
  |  513|   200k|    /*_FORCE_COVER_START_*/BitSet SHIFT(const int shift_size) const {
  |  514|   200k|      BitSet out_set(*this);
  |  515|   200k|      if (shift_size > 0) out_set.ShiftRight((uint32_t) shift_size);
  |  516|   100k|      else if (shift_size < 0) out_set.ShiftLeft((uint32_t) (-shift_size));
  |  517|   200k|      return out_set;
  |  518|   200k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EE5SHIFTEi:
  |  513|      6|    /*_FORCE_COVER_START_*/BitSet SHIFT(const int shift_size) const {
  |  514|      6|      BitSet out_set(*this);
  |  515|      6|      if (shift_size > 0) out_set.ShiftRight((uint32_t) shift_size);
  |  516|      5|      else if (shift_size < 0) out_set.ShiftLeft((uint32_t) (-shift_size));
  |  517|      6|      return out_set;
  |  518|      6|    }/*_FORCE_COVER_END_*/
  ------------------
  519|       |
  520|       |    /// Positive shifts go left and negative go right; store result here, and return this object.
  521|      1|    /*_FORCE_COVER_START_*/BitSet & SHIFT_SELF(const int shift_size) {
  522|      1|      if (shift_size > 0) ShiftRight((uint32_t) shift_size);
  523|      1|      else if (shift_size < 0) ShiftLeft((uint32_t) -shift_size);
  524|      1|      return *this;
  525|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE10SHIFT_SELFEi
  ------------------
  | _ZN3emp6BitSetILm80EE10SHIFT_SELFEi:
  |  521|      1|    /*_FORCE_COVER_START_*/BitSet & SHIFT_SELF(const int shift_size) {
  |  522|      1|      if (shift_size > 0) ShiftRight((uint32_t) shift_size);
  |  523|      1|      else if (shift_size < 0) ShiftLeft((uint32_t) -shift_size);
  |  524|      1|      return *this;
  |  525|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  526|       |
  527|       |    /// Operator bitwise NOT...
  528|      5|    /*_FORCE_COVER_START_*/BitSet operator~() const { return NOT(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEcoEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm128EEcoEv
  ------------------
  | _ZNK3emp6BitSetILm20EEcoEv:
  |  528|      5|    /*_FORCE_COVER_START_*/BitSet operator~() const { return NOT(); }/*_FORCE_COVER_END_*/
  ------------------
  529|       |
  530|       |    /// Operator bitwise AND...
  531|   100k|    /*_FORCE_COVER_START_*/BitSet operator&(const BitSet & ar2) const { return AND(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEanERKS1_
  ------------------
  | _ZNK3emp6BitSetILm100000EEanERKS1_:
  |  531|   100k|    /*_FORCE_COVER_START_*/BitSet operator&(const BitSet & ar2) const { return AND(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EEanERKS1_
  ------------------
  532|       |
  533|       |    /// Operator bitwise OR...
  534|      1|    /*_FORCE_COVER_START_*/BitSet operator|(const BitSet & ar2) const { return OR(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEorERKS1_
  ------------------
  | _ZNK3emp6BitSetILm100000EEorERKS1_:
  |  534|      1|    /*_FORCE_COVER_START_*/BitSet operator|(const BitSet & ar2) const { return OR(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EEorERKS1_
  ------------------
  535|       |
  536|       |    /// Operator bitwise XOR...
  537|      0|    /*_FORCE_COVER_START_*/BitSet operator^(const BitSet & ar2) const { return XOR(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EEeoERKS1_
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm20EEeoERKS1_
  ------------------
  538|       |
  539|       |    /// Operator shift left...
  540|   100k|    /*_FORCE_COVER_START_*/BitSet operator<<(const size_t shift_size) const { return SHIFT(-(int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EElsEm
  ------------------
  | _ZNK3emp6BitSetILm100000EElsEm:
  |  540|   100k|    /*_FORCE_COVER_START_*/BitSet operator<<(const size_t shift_size) const { return SHIFT(-(int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EElsEm:
  |  540|      5|    /*_FORCE_COVER_START_*/BitSet operator<<(const size_t shift_size) const { return SHIFT(-(int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  541|       |
  542|       |    /// Operator shift right...
  543|   100k|    /*_FORCE_COVER_START_*/BitSet operator>>(const size_t shift_size) const { return SHIFT((int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EErsEm
  ------------------
  | _ZNK3emp6BitSetILm80EErsEm:
  |  543|     76|    /*_FORCE_COVER_START_*/BitSet operator>>(const size_t shift_size) const { return SHIFT((int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm100000EErsEm:
  |  543|   100k|    /*_FORCE_COVER_START_*/BitSet operator>>(const size_t shift_size) const { return SHIFT((int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp6BitSetILm20EErsEm:
  |  543|      1|    /*_FORCE_COVER_START_*/BitSet operator>>(const size_t shift_size) const { return SHIFT((int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  544|       |
  545|       |    /// Compound operator bitwise AND...
  546|   100k|    /*_FORCE_COVER_START_*/const BitSet & operator&=(const BitSet & ar2) { return AND_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEaNERKS1_
  ------------------
  | _ZN3emp6BitSetILm100000EEaNERKS1_:
  |  546|   100k|    /*_FORCE_COVER_START_*/const BitSet & operator&=(const BitSet & ar2) { return AND_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EEaNERKS1_:
  |  546|      2|    /*_FORCE_COVER_START_*/const BitSet & operator&=(const BitSet & ar2) { return AND_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  547|       |
  548|       |    /// Compound operator bitwise OR...
  549|   100k|    /*_FORCE_COVER_START_*/const BitSet & operator|=(const BitSet & ar2) { return OR_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEoRERKS1_
  ------------------
  | _ZN3emp6BitSetILm100000EEoRERKS1_:
  |  549|   100k|    /*_FORCE_COVER_START_*/const BitSet & operator|=(const BitSet & ar2) { return OR_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EEoRERKS1_:
  |  549|     12|    /*_FORCE_COVER_START_*/const BitSet & operator|=(const BitSet & ar2) { return OR_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EEoRERKS1_:
  |  549|      3|    /*_FORCE_COVER_START_*/const BitSet & operator|=(const BitSet & ar2) { return OR_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  550|       |
  551|       |    /// Compound operator bitwise XOR...
  552|      0|    /*_FORCE_COVER_START_*/const BitSet & operator^=(const BitSet & ar2) { return XOR_SELF(ar2); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EEeOERKS1_
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm20EEeOERKS1_
  ------------------
  553|       |
  554|       |    /// Compound operator shift left...
  555|      1|    /*_FORCE_COVER_START_*/const BitSet & operator<<=(const size_t shift_size) { return SHIFT_SELF(-(int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EElSEm
  ------------------
  | _ZN3emp6BitSetILm80EElSEm:
  |  555|      1|    /*_FORCE_COVER_START_*/const BitSet & operator<<=(const size_t shift_size) { return SHIFT_SELF(-(int)shift_size); }/*_FORCE_COVER_END_*/
  ------------------
  556|       |
  557|       |    /// Compound operator shift right...
  558|      0|    /*_FORCE_COVER_START_*/const BitSet & operator>>=(const size_t shift_size) { return SHIFT_SELF((int)shift_size); }/*_FORCE_COVER_END_*/
  559|       |
  560|       |    /// Function to allow drop-in replacement with std::bitset.
  561|  41.2k|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE4sizeEv
  ------------------
  | _ZN3emp6BitSetILm80EE4sizeEv:
  |  561|      2|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm10EE4sizeEv:
  |  561|     12|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm100000EE4sizeEv:
  |  561|  40.0k|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm128EE4sizeEv:
  |  561|  1.17k|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6BitSetILm20EE4sizeEv:
  |  561|     10|    /*_FORCE_COVER_START_*/constexpr static size_t size() { return NUM_BITS; }/*_FORCE_COVER_END_*/
  ------------------
  562|       |
  563|       |    /// Function to allow drop-in replacement with std::bitset.
  564|      3|    /*_FORCE_COVER_START_*/inline bool all() const { return All(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3allEv
  ------------------
  | _ZNK3emp6BitSetILm20EE3allEv:
  |  564|      3|    /*_FORCE_COVER_START_*/inline bool all() const { return All(); }/*_FORCE_COVER_END_*/
  ------------------
  565|       |
  566|       |    /// Function to allow drop-in replacement with std::bitset.
  567|      2|    /*_FORCE_COVER_START_*/inline bool any() const { return Any(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE3anyEv
  ------------------
  | _ZNK3emp6BitSetILm20EE3anyEv:
  |  567|      2|    /*_FORCE_COVER_START_*/inline bool any() const { return Any(); }/*_FORCE_COVER_END_*/
  ------------------
  568|       |
  569|       |    /// Function to allow drop-in replacement with std::bitset.
  570|      3|    /*_FORCE_COVER_START_*/inline bool none() const { return !Any(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE4noneEv
  ------------------
  | _ZNK3emp6BitSetILm20EE4noneEv:
  |  570|      3|    /*_FORCE_COVER_START_*/inline bool none() const { return !Any(); }/*_FORCE_COVER_END_*/
  ------------------
  571|       |
  572|       |    /// Function to allow drop-in replacement with std::bitset.
  573|      2|    /*_FORCE_COVER_START_*/inline size_t count() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp6BitSetILm5EE5countEv
  ------------------
  | _ZNK3emp6BitSetILm20EE5countEv:
  |  573|      2|    /*_FORCE_COVER_START_*/inline size_t count() const { return CountOnes_Mixed(); }/*_FORCE_COVER_END_*/
  ------------------
  574|       |
  575|       |    /// Function to allow drop-in replacement with std::bitset.
  576|      0|    /*_FORCE_COVER_START_*/inline BitSet & flip() { return Toggle(); }/*_FORCE_COVER_END_*/
  577|       |
  578|       |    /// Function to allow drop-in replacement with std::bitset.
  579|      1|    /*_FORCE_COVER_START_*/inline BitSet & flip(size_t pos) { return Toggle(pos); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE4flipEm
  ------------------
  | _ZN3emp6BitSetILm10EE4flipEm:
  |  579|      1|    /*_FORCE_COVER_START_*/inline BitSet & flip(size_t pos) { return Toggle(pos); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm20EE4flipEm
  ------------------
  580|       |
  581|       |    /// Function to allow drop-in replacement with std::bitset.
  582|      1|    /*_FORCE_COVER_START_*/inline BitSet & flip(size_t start, size_t end) { return Toggle(start, end); }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6BitSetILm5EE4flipEmm
  ------------------
  | _ZN3emp6BitSetILm10EE4flipEmm:
  |  582|      1|    /*_FORCE_COVER_START_*/inline BitSet & flip(size_t start, size_t end) { return Toggle(start, end); }/*_FORCE_COVER_END_*/
  ------------------
  583|       |  };
  584|       |
  585|       |  /*_FORCE_COVER_START_*/template <size_t NUM_BITS1, size_t NUM_BITS2>
  586|       |  BitSet<NUM_BITS1+NUM_BITS2> join(const BitSet<NUM_BITS1> & in1, const BitSet<NUM_BITS2> & in2) {
  587|       |    BitSet<NUM_BITS1+NUM_BITS2> out_bits;
  588|       |    out_bits.Import(in2);
  589|       |    out_bits <<= NUM_BITS1;
  590|       |    out_bits |= in2.template Export<NUM_BITS1+NUM_BITS2>();
  591|       |  }/*_FORCE_COVER_END_*/
  592|       |
  593|       |  /// Computes simple matching coefficient (https://en.wikipedia.org/wiki/Simple_matching_coefficient).
  594|       |  /*_FORCE_COVER_START_*/template <size_t NUM_BITS>
  595|       |  double SimpleMatchCoeff(const BitSet<NUM_BITS> & in1, const BitSet<NUM_BITS> & in2) {
  596|       |    emp_assert(NUM_BITS > 0); // TODO: can be done with XOR
  597|       |    return (double)((in1 & in2).CountOnes() + (~in1 & ~in2).CountOnes()) / (double)NUM_BITS;
  598|       |  }/*_FORCE_COVER_END_*/
  599|       |
  600|       |}
  601|       |
  602|       |/*_FORCE_COVER_START_*/template <size_t NUM_BITS> std::ostream & operator<<(std::ostream & out, const emp::BitSet<NUM_BITS> & _bit_set) {
  603|       |  _bit_set.Print(out);
  604|       |  return out;
  605|       |}/*_FORCE_COVER_END_*/
  606|       |
  607|       |
  608|       |
  609|       |#endif
  610|       |

/home/emily/repos/Empirical_Tests/source/tools/BitVector.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  BitVector.h
    7|       | *  @brief A drop-in replacement for std::vector<bool>, with additional bitwise logic features.
    8|       | *  @note Status: RELEASE
    9|       | *
   10|       | *  @todo Implement append(), resize()...
   11|       | *  @todo Implement techniques to push bits (we have pop)
   12|       | *  @todo Implement techniques to insert of remove bits from middle.
   13|       | *
   14|       | *  @note This class is 15-20% slower than emp::BitSet, but more flexible & run-time configurable.
   15|       | */
   16|       |
   17|       |
   18|       |#ifndef EMP_BIT_VECTOR_H
   19|       |#define EMP_BIT_VECTOR_H
   20|       |
   21|       |#include <iostream>
   22|       |
   23|       |#include "../base/assert.h"
   24|       |#include "../base/Ptr.h"
   25|       |#include "../base/vector.h"
   26|       |
   27|       |#include "bitset_utils.h"
   28|       |#include "functions.h"
   29|       |#include "math.h"
   30|       |
   31|       |namespace emp {
   32|       |
   33|       |  /// @brief A drop-in replacement for std::vector<bool>, but with extra bitwise logic features.
   34|       |  ///
   35|       |  /// This class stores an arbirary number of bits in a set of "fields" (either 32-bit or 64-bit,
   36|       |  /// depending on which should be faster.)  Individual bits can be extracted, -or- bitwise logic
   37|       |  /// (or bit magic) can be used on the groups of bits,
   38|       |
   39|       |  class BitVector {
   40|       |  private:
   41|       |#ifdef EMSCRIPTEN
   42|       |    using field_t = uint32_t;  ///< Field sizes are 32 bits in Emscripten (max directly handled)
   43|       |#else
   44|       |    using field_t = uint64_t;  ///< Field sizes are 64 bits in native.
   45|       |#endif
   46|       |
   47|       |    static constexpr size_t FIELD_BITS = sizeof(field_t)*8; ///< How many bits are in a field?
   48|       |    size_t num_bits;                                        ///< How many total bits are we using?
   49|       |    Ptr<field_t> bit_set;                                   ///< What is the status of each bit?
   50|       |
   51|       |    /// End position of the stored bits in the last field; 0 if perfect fit.
   52|      0|    size_t LastBitID() const { return num_bits & (FIELD_BITS - 1); }
   53|       |
   54|       |    /// How many feilds do we need?
   55|    164|    size_t NumFields() const { return num_bits ? (1 + ((num_bits - 1) / FIELD_BITS)) : 0; }
   56|       |
   57|       |    /// How many bytes are used in the current vector (round up to whole bytes.)
   58|      0|    size_t NumBytes()  const { return num_bits ? (1 + ((num_bits - 1) >> 3)) : 0; }
   59|       |
   60|       |    /// How many fields would we need if they had the same number of bits as size_t?
   61|      0|    size_t NumSizeFields() const { return NumFields() * sizeof(field_t) / sizeof(std::size_t); }
   62|       |
   63|       |    /// BitProxy lets us use operator[] on with BitVector as an lvalue.
   64|       |    struct BitProxy {
   65|       |      BitVector & bit_vector;  ///< Which BitVector does this proxy belong to?
   66|       |      size_t index;            ///< Which position in the bit vector does this proxy point at?
   67|       |
   68|       |      /// Setup a new proxy with the associated vector and index.
   69|      0|      BitProxy(BitVector & _v, size_t _idx) : bit_vector(_v), index(_idx) {;}
   70|       |
   71|       |      /// Assignment operator to the bit associated with this proxy (as an lvalue).
   72|      0|      BitProxy & operator=(bool b) {
   73|      0|        bit_vector.Set(index, b);
   74|      0|        return *this;
   75|      0|      }
   76|       |
   77|       |      /// Conversion of this proxy to Boolean (as an rvalue)
   78|      0|      operator bool() const {
   79|      0|        return bit_vector.Get(index);
   80|      0|      }
   81|       |
   82|       |      /// Compound assignement operator AND using BitProxy as lvalue.
   83|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
   84|      0|      BitProxy & operator &=(bool b) {
   85|      0|        const bool v = bit_vector.Get(index);
   86|      0|        bit_vector.Set(index, v & b);
   87|      0|        return *this;
   88|      0|      }
   89|       |
   90|       |      /// Compound assignement operator OR using BitProxy as lvalue.
   91|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
   92|      0|      BitProxy & operator |=(bool b) {
   93|      0|        const bool v = bit_vector.Get(index);
   94|      0|        bit_vector.Set(index, v | b);
   95|      0|        return *this;
   96|      0|      }
   97|       |
   98|       |      /// Compound assignement operator XOR using BitProxy as lvalue.
   99|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
  100|      0|      BitProxy & operator ^=(bool b) {
  101|      0|        const bool v = bit_vector.Get(index);
  102|      0|        bit_vector.Set(index, v ^ b);
  103|      0|        return *this;
  104|      0|      }
  105|       |
  106|       |      /// Compound assignement operator PLUS using BitProxy as lvalue.
  107|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
  108|      0|      BitProxy & operator +=(bool b) {
  109|      0|        const bool v = bit_vector.Get(index);
  110|      0|        bit_vector.Set(index, v || b);
  111|      0|        return *this;
  112|      0|      }
  113|       |
  114|       |      /// Compound assignement operator MINUS using BitProxy as lvalue.
  115|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
  116|      0|      BitProxy & operator -=(bool b) {
  117|      0|        const bool v = bit_vector.Get(index);
  118|      0|        bit_vector.Set(index, v - b);
  119|      0|        return *this;
  120|      0|      }
  121|       |
  122|       |      /// Compound assignement operator TIMES using BitProxy as lvalue.
  123|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
  124|      0|      BitProxy & operator *=(bool b) {
  125|      0|        const bool v = bit_vector.Get(index);
  126|      0|        bit_vector.Set(index, v && b);
  127|      0|        return *this;
  128|      0|      }
  129|       |
  130|       |      /// Compound assignement operator DIV using BitProxy as lvalue.
  131|       |      /// @note Implemented in BitProxy since it needs to work, but may not be efficient.
  132|       |      /// @note Never use this function except for consistency in a template since must divide by 1.
  133|      0|      BitProxy & operator /=(bool b) {
  134|      0|        emp_assert(b == true);
  135|      0|        return *this;
  136|      0|      }
  137|       |    };
  138|       |
  139|       |    /// Identify the field that a specified bit is in.
  140|     68|    static constexpr size_t FieldID(const size_t index)  { return index / FIELD_BITS; }
  141|       |
  142|       |    /// Identify the position in a field where a specified bit is.
  143|     68|    static constexpr size_t FieldPos(const size_t index) { return index & (FIELD_BITS-1); }
  144|       |
  145|       |    /// Identify which field a specified byte position would be in.
  146|      0|    static constexpr size_t Byte2Field(const size_t index) { return index/sizeof(field_t); }
  147|       |
  148|       |    /// Convert a byte position in BitVector to a byte position in the target field.
  149|      0|    static constexpr size_t Byte2FieldPos(const size_t index) {
  150|      0|      return (index & (sizeof(field_t)-1)) << 3;
  151|      0|    }
  152|       |
  153|       |    /// Assume that the size of the bit_set has already been adjusted to be the size of the one
  154|       |    /// being copied and only the fields need to be copied over.
  155|     80|    void RawCopy(const Ptr<field_t> in_set) {
  156|       |      #ifdef EMP_TRACK_MEM
  157|       |      emp_assert(in_set.IsNull() == false);
  158|       |      emp_assert(bit_set.DebugIsArray() && in_set.DebugIsArray());
  159|       |      emp_assert(bit_set.DebugGetArrayBytes() == in_set.DebugGetArrayBytes(),
  160|       |                 bit_set.DebugGetArrayBytes(), in_set.DebugGetArrayBytes());
  161|       |      #endif
  162|       |      
  163|     80|      const size_t NUM_FIELDS = NumFields();
  164|    160|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = in_set[i];
  165|     80|    }
  166|       |
  167|       |    /// Helper: call SHIFT with positive number
  168|      0|    void ShiftLeft(const size_t shift_size) {
  169|      0|      const size_t field_shift = shift_size / FIELD_BITS;
  170|      0|      const size_t bit_shift = shift_size % FIELD_BITS;
  171|      0|      const size_t bit_overflow = FIELD_BITS - bit_shift;
  172|      0|      const size_t NUM_FIELDS = NumFields();
  173|      0|
  174|      0|      // Loop through each field, from L to R, and update it.
  175|      0|      if (field_shift) {
  176|      0|        for (size_t i = NUM_FIELDS; i > field_shift; --i) {
  177|      0|          bit_set[i-1] = bit_set[i - field_shift - 1];
  178|      0|        }
  179|      0|        for (size_t i = field_shift; i > 0; --i) bit_set[i-1] = 0;
  180|      0|      }
  181|      0|
  182|      0|      // account for bit_shift
  183|      0|      if (bit_shift) {
  184|      0|        for (size_t i = NUM_FIELDS - 1; i > field_shift; --i) {
  185|      0|          bit_set[i] <<= bit_shift;
  186|      0|          bit_set[i] |= (bit_set[i-1] >> bit_overflow);
  187|      0|        }
  188|      0|        // Handle final field (field_shift position)
  189|      0|        bit_set[field_shift] <<= bit_shift;
  190|      0|      }
  191|      0|
  192|      0|      // Mask out any bits that have left-shifted away
  193|      0|      const size_t last_bit_id = LastBitID();
  194|      0|      constexpr field_t val_one = 1;
  195|      0|      if (last_bit_id) { bit_set[NUM_FIELDS - 1] &= (val_one << last_bit_id) - val_one; }
  196|      0|    }
  197|       |
  198|       |
  199|       |    /// Helper for calling SHIFT with negative number
  200|      0|    void ShiftRight(const size_t shift_size) {
  201|      0|      const size_t field_shift = shift_size / FIELD_BITS;
  202|      0|      const size_t bit_shift = shift_size % FIELD_BITS;
  203|      0|      const size_t bit_overflow = FIELD_BITS - bit_shift;
  204|      0|      const size_t NUM_FIELDS = NumFields();
  205|      0|      const size_t field_shift2 = NUM_FIELDS - field_shift;
  206|      0|
  207|      0|      // account for field_shift
  208|      0|      if (field_shift) {
  209|      0|        for (size_t i = 0; i < field_shift2; ++i) {
  210|      0|          bit_set[i] = bit_set[i + field_shift];
  211|      0|        }
  212|      0|        for (size_t i = field_shift2; i < NUM_FIELDS; i++) bit_set[i] = 0U;
  213|      0|      }
  214|      0|
  215|      0|      // account for bit_shift
  216|      0|      if (bit_shift) {
  217|      0|        for (size_t i = 0; i < (field_shift2 - 1); ++i) {
  218|      0|          bit_set[i] >>= bit_shift;
  219|      0|          bit_set[i] |= (bit_set[i+1] << bit_overflow);
  220|      0|        }
  221|      0|        bit_set[field_shift2 - 1] >>= bit_shift;
  222|      0|      }
  223|      0|    }
  224|       |
  225|       |  public:
  226|       |    /// Build a new BitVector with specified bit count (default 0) and initialization (default 0)
  227|      2|    BitVector(size_t in_num_bits=0, bool init_val=false) : num_bits(in_num_bits), bit_set(nullptr) {
  228|      2|      if (num_bits) bit_set = NewArrayPtr<field_t>(NumFields());
  229|      2|      if (init_val) SetAll(); else Clear();
  230|      2|    }
  231|       |
  232|       |    /// Copy constructor of existing bit field.
  233|     80|    BitVector(const BitVector & in_set) : num_bits(in_set.num_bits), bit_set(nullptr) {
  234|       |      #ifdef EMP_TRACK_MEM
  235|       |      emp_assert(in_set.bit_set.IsNull() || in_set.bit_set.DebugIsArray(), in_set.bit_set.IsNull(), in_set.bit_set.DebugIsArray());
  236|       |      emp_assert(in_set.bit_set.OK());
  237|       |      #endif
  238|       |
  239|     80|      if (num_bits) bit_set = NewArrayPtr<field_t>(NumFields());
  240|     80|      RawCopy(in_set.bit_set);
  241|     80|    }
  242|       |
  243|       |    /// Move constructor of existing bit field.
  244|      0|    BitVector(BitVector && in_set) : num_bits(in_set.num_bits), bit_set(in_set.bit_set) {
  245|      0|      #ifdef EMP_TRACK_MEM
  246|      0|      emp_assert(bit_set == nullptr || bit_set.DebugIsArray());
  247|      0|      emp_assert(bit_set.OK());
  248|      0|      #endif
  249|      0|
  250|      0|      in_set.bit_set = nullptr;
  251|      0|    }
  252|       |
  253|       |    /// Destructor
  254|     82|    ~BitVector() {
  255|     82|      if (bit_set) {        // A move constructor can make bit_set == nullptr
  256|     82|        bit_set.DeleteArray();
  257|     82|        bit_set = nullptr;
  258|     82|      }
  259|     82|    }
  260|       |
  261|       |    /// Assignment operator.
  262|      0|    BitVector & operator=(const BitVector & in_set) {
  263|       |      #ifdef EMP_TRACK_MEM
  264|       |      emp_assert(in_set.bit_set == nullptr || in_set.bit_set.DebugIsArray());
  265|       |      emp_assert(in_set.bit_set != nullptr || in_set.num_bits == 0);
  266|       |      emp_assert(in_set.bit_set.OK());
  267|       |      #endif
  268|       |      
  269|      0|      if (&in_set == this) return *this;
  270|      0|      const size_t in_num_fields = in_set.NumFields();
  271|      0|      const size_t prev_num_fields = NumFields();
  272|      0|      num_bits = in_set.num_bits;
  273|      0|
  274|      0|      if (in_num_fields != prev_num_fields) {
  275|      0|        if (bit_set) bit_set.DeleteArray();
  276|      0|	      if (num_bits) bit_set = NewArrayPtr<field_t>(in_num_fields);
  277|      0|        else bit_set = nullptr;
  278|      0|      }
  279|      0|
  280|      0|      if (num_bits) RawCopy(in_set.bit_set);
  281|      0|
  282|      0|      return *this;
  283|      0|    }
  284|       |
  285|       |    /// Move operator.
  286|      0|    BitVector & operator=(BitVector && in_set) {
  287|      0|      emp_assert(&in_set != this);        // in_set is an r-value, so this shouldn't be possible...
  288|      0|      if (bit_set) bit_set.DeleteArray(); // If we already had a bitset, get rid of it.
  289|      0|      num_bits = in_set.num_bits;         // Update the number of bits...
  290|      0|      bit_set = in_set.bit_set;           // And steal the old memory for what those bits are.
  291|      0|      in_set.bit_set = nullptr;           // Prepare in_set for deletion without deallocating.
  292|      0|
  293|      0|      return *this;
  294|      0|    }
  295|       |
  296|       |    /// Resize this BitVector to have the specified number of bits.
  297|      0|    BitVector & Resize(size_t new_bits) {
  298|      0|      const size_t old_num_fields = NumFields();
  299|      0|      num_bits = new_bits;
  300|      0|      const size_t NUM_FIELDS = NumFields();
  301|      0|
  302|      0|      if (NUM_FIELDS == old_num_fields) {   // We can use our existing bit field
  303|      0|        num_bits = new_bits;
  304|      0|        // If there are extra bits, zero them out.
  305|      0|        if (LastBitID() > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  306|      0|      }
  307|      0|
  308|      0|      else {  // We have to change the number of bitfields.  Resize & copy old info.
  309|      0|        Ptr<field_t> old_bit_set = bit_set;
  310|      0|        if (num_bits > 0) bit_set = NewArrayPtr<field_t>(NUM_FIELDS);
  311|      0|        else bit_set = nullptr;
  312|      0|        const size_t min_fields = std::min(old_num_fields, NUM_FIELDS);
  313|      0|        for (size_t i = 0; i < min_fields; i++) bit_set[i] = old_bit_set[i];
  314|      0|        for (size_t i = min_fields; i < NUM_FIELDS; i++) bit_set[i] = 0U;
  315|      0|        if (old_bit_set) old_bit_set.DeleteArray();
  316|      0|      }
  317|      0|
  318|      0|      return *this;
  319|      0|    }
  320|       |
  321|       |    /// Test if two bit vectors are identical.
  322|      0|    bool operator==(const BitVector & in_set) const {
  323|      0|      if (num_bits != in_set.num_bits) return false;
  324|      0|
  325|      0|      const size_t NUM_FIELDS = NumFields();
  326|      0|      for (size_t i = 0; i < NUM_FIELDS; ++i) {
  327|      0|        if (bit_set[i] != in_set.bit_set[i]) return false;
  328|      0|      }
  329|      0|      return true;
  330|      0|    }
  331|       |
  332|       |    /// Compare the would-be numerical values of two bit vectors.
  333|      0|    bool operator<(const BitVector & in_set) const {
  334|      0|      if (num_bits != in_set.num_bits) return num_bits < in_set.num_bits;
  335|      0|
  336|      0|      const size_t NUM_FIELDS = NumFields();
  337|      0|      for (size_t i = NUM_FIELDS; i > 0; --i) {         // Start loop at the largest field.
  338|      0|        const size_t pos = i-1;
  339|      0|        if (bit_set[pos] == in_set.bit_set[pos]) continue;  // If same, keep looking!
  340|      0|        return (bit_set[pos] < in_set.bit_set[pos]);        // Otherwise, do comparison
  341|      0|      }
  342|      0|      return false;
  343|      0|    }
  344|       |
  345|       |    /// Compare the would-be numerical values of two bit vectors.
  346|      0|    bool operator<=(const BitVector & in_set) const {
  347|      0|      if (num_bits != in_set.num_bits) return num_bits <= in_set.num_bits;
  348|      0|
  349|      0|      const size_t NUM_FIELDS = NumFields();
  350|      0|      for (size_t i = NUM_FIELDS; i > 0; --i) {         // Start loop at the largest field.
  351|      0|        const size_t pos = i-1;
  352|      0|        if (bit_set[pos] == in_set.bit_set[pos]) continue;  // If same, keep looking!
  353|      0|        return (bit_set[pos] < in_set.bit_set[pos]);        // Otherwise, do comparison
  354|      0|      }
  355|      0|      return true;
  356|      0|    }
  357|       |
  358|       |    /// Determine if two bit vectors are different.
  359|      0|    bool operator!=(const BitVector & in_set) const { return !operator==(in_set); }
  360|       |
  361|       |    /// Compare the would-be numerical values of two bit vectors.
  362|      0|    bool operator>(const BitVector & in_set) const { return !operator<=(in_set); }
  363|       |
  364|       |    /// Compare the would-be numerical values of two bit vectors.
  365|      0|    bool operator>=(const BitVector & in_set) const { return !operator<(in_set); }
  366|       |
  367|       |    /// How many bits do we currently have?
  368|      0|    size_t GetSize() const { return num_bits; }
  369|       |
  370|       |    /// Retrive the bit value from the specified index.
  371|      0|    bool Get(size_t index) const {
  372|      0|      emp_assert(index < num_bits, index, num_bits);
  373|      0|      const size_t field_id = FieldID(index);
  374|      0|      const size_t pos_id = FieldPos(index);
  375|      0|      return (bit_set[field_id] & (static_cast<field_t>(1) << pos_id)) != 0;
  376|      0|    }
  377|       |
  378|       |    /// Update the bit value at the specified index.
  379|     68|    void Set(size_t index, bool value=true) {
  380|     68|      emp_assert(index < num_bits, index, num_bits);
  381|     68|      const size_t field_id = FieldID(index);
  382|     68|      const size_t pos_id = FieldPos(index);
  383|     68|      constexpr field_t val_one = 1;
  384|     68|      const field_t pos_mask = val_one << pos_id;
  385|     68|
  386|     68|      if (value) bit_set[field_id] |= pos_mask;
  387|      0|      else       bit_set[field_id] &= ~pos_mask;
  388|     68|    }
  389|       |
  390|       |    /// A simple hash function for bit vectors.
  391|      0|    std::size_t Hash() const {
  392|      0|      const size_t num_sfields = NumSizeFields();
  393|      0|      std::size_t hash_val = 0;
  394|      0|      for (size_t i = 0; i < num_sfields; i++) {
  395|      0|        hash_val ^= (bit_set.Cast<std::size_t>())[i];
  396|      0|      }
  397|      0|      return hash_val ^ ((97*num_bits) << 8);
  398|      0|    }
  399|       |
  400|       |    /// Retrive the byte at the specified byte index.
  401|      0|    uint8_t GetByte(size_t index) const {
  402|      0|      emp_assert(index < NumBytes(), index, NumBytes());
  403|      0|      const size_t field_id = Byte2Field(index);
  404|      0|      const size_t pos_id = Byte2FieldPos(index);
  405|      0|      return (bit_set[field_id] >> pos_id) & 255U;
  406|      0|    }
  407|       |
  408|       |    /// Update the byte at the specified byte index.
  409|      0|    void SetByte(size_t index, uint8_t value) {
  410|      0|      emp_assert(index < NumBytes(), index, NumBytes());
  411|      0|      const size_t field_id = Byte2Field(index);
  412|      0|      const size_t pos_id = Byte2FieldPos(index);
  413|      0|      const field_t val_uint = value;
  414|      0|      bit_set[field_id] = (bit_set[field_id] & ~(static_cast<field_t>(255) << pos_id)) | (val_uint << pos_id);
  415|      0|    }
  416|       |
  417|       |    /// Retrive the 32-bit uint from the specifeid uint index.
  418|      0|    uint32_t GetUInt(size_t index) const {
  419|      0|      // @CAO Need proper assert for variable bit fields!
  420|      0|      // emp_assert(index < NumFields());
  421|      0|      return bit_set.Cast<uint32_t>()[index];
  422|      0|    }
  423|       |
  424|       |    /// Update the 32-bit uint at the specified uint index.
  425|      0|    void SetUInt(size_t index, uint32_t value) {
  426|      0|      // @CAO Need proper assert for variable bit fields!
  427|      0|      // emp_assert(index < NumFields());
  428|      0|      bit_set.Cast<uint32_t>()[index] = value;
  429|      0|    }
  430|       |
  431|       |    /// Retrive the 32-bit uint at the specified BIT index.
  432|      0|    uint32_t GetUIntAtBit(size_t index) {
  433|      0|      // @CAO Need proper assert for non-32-size bit fields!
  434|      0|      // emp_assert(index < num_bits);
  435|      0|      const size_t field_id = FieldID(index);
  436|      0|      const size_t pos_id = FieldPos(index);
  437|      0|      if (pos_id == 0) return (uint32_t) bit_set[field_id];
  438|      0|      const size_t NUM_FIELDS = NumFields();
  439|      0|      const uint32_t part1 = (uint32_t) (bit_set[field_id] >> pos_id);
  440|      0|      const uint32_t part2 =
  441|      0|        (uint32_t)((field_id+1 < NUM_FIELDS) ? bit_set[field_id+1] << (FIELD_BITS-pos_id) : 0);
  442|      0|      return part1 | part2;
  443|      0|    }
  444|       |
  445|       |    /// Retrieve the specified number of bits (stored in the field type) at the target bit index.
  446|       |    /*_FORCE_COVER_START_*/template <size_t OUT_BITS>
  447|       |    field_t GetValueAtBit(size_t index) {
  448|       |      // @CAO This function needs to be generalized to return more then sizeof(field_t)*8 bits.
  449|       |      static_assert(OUT_BITS <= sizeof(field_t)*8, "Requesting too many bits to fit in a UInt");
  450|       |      return GetUIntAtBit(index) & MaskLow<field_t>(OUT_BITS);
  451|       |    }/*_FORCE_COVER_END_*/
  452|       |
  453|       |    /// Return true if ANY bits are set to 1, otherwise return false.
  454|      0|    bool Any() const {
  455|      0|      const size_t NUM_FIELDS = NumFields();
  456|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) {
  457|      0|        if (bit_set[i]) return true;
  458|      0|      }
  459|      0|      return false;
  460|      0|    }
  461|       |
  462|       |    /// Return true if NO bits are set to 1, otherwise return false.
  463|      0|    bool None() const { return !Any(); }
  464|       |
  465|       |    /// Return true if ALL bits are set to 1, otherwise return false.
  466|      0|    bool All() const { return (~(*this)).None(); }
  467|       |
  468|       |    /// Casting a bit array to bool identifies if ANY bits are set to 1.
  469|      0|    explicit operator bool() const { return Any(); }
  470|       |
  471|       |    /// Const index operator -- return the bit at the specified position.
  472|      0|    bool operator[](size_t index) const { return Get(index); }
  473|       |
  474|       |    /// Index operator -- return a proxy to the bit at the specified position so it can be an lvalue.
  475|      0|    BitProxy operator[](size_t index) { return BitProxy(*this, index); }
  476|       |
  477|       |    /// Set all bits to 0.
  478|      2|    void Clear() {
  479|      2|      const size_t NUM_FIELDS = NumFields();
  480|      4|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = 0U;
  481|      2|    }
  482|       |
  483|       |    /// Set all bits to 1.
  484|      0|    void SetAll() {
  485|      0|      const size_t NUM_FIELDS = NumFields();
  486|      0|      constexpr field_t all0 = 0;
  487|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~all0;
  488|      0|      if (LastBitID() > 0) { bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID()); }
  489|      0|    }
  490|       |
  491|       |    /// Regular print function (from most significant bit to least)
  492|      0|    void Print(std::ostream & out=std::cout) const {
  493|      0|      for (size_t i = num_bits; i > 0; --i) out << Get(i-1);
  494|      0|    }
  495|       |
  496|       |    /// Print a space between each field (or other provided spacer)
  497|      0|    void PrintFields(std::ostream & out=std::cout, const std::string spacer=" ") const {
  498|      0|      for (size_t i = num_bits; i > 0; i--) {
  499|      0|        out << Get(i-1);
  500|      0|        if (i % FIELD_BITS == 0) out << spacer;
  501|      0|      }
  502|      0|    }
  503|       |
  504|       |    /// Print from smallest bit position to largest.
  505|      0|    void PrintArray(std::ostream & out=std::cout) const {
  506|      0|      for (size_t i = 0; i < num_bits; i++) out << Get(i);
  507|      0|    }
  508|       |
  509|       |    /// Print the positions of all one bits, spaces are the default separator.
  510|      0|    void PrintOneIDs(std::ostream & out=std::cout, std::string spacer=" ") const {
  511|      0|      for (size_t i = 0; i < num_bits; i++) { if (Get(i)) out << i << spacer; }
  512|      0|    }
  513|       |
  514|       |
  515|       |    /// Count 1's by looping through once for each bit equal to 1
  516|      0|    size_t CountOnes_Sparse() const {
  517|      0|      const size_t NUM_FIELDS = NumFields();
  518|      0|      size_t bit_count = 0;
  519|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) {
  520|      0|        field_t cur_field = bit_set[i];
  521|      0|        while (cur_field) {
  522|      0|          cur_field &= (cur_field-1);       // Peel off a single 1.
  523|      0|          bit_count++;      // And increment the counter
  524|      0|        }
  525|      0|      }
  526|      0|      return bit_count;
  527|      0|    }
  528|       |
  529|       |    /// Count 1's in semi-parallel; fastest for even 0's & 1's
  530|      0|    size_t CountOnes_Mixed() const {
  531|      0|      const size_t NUM_FIELDS = NumFields() * sizeof(field_t)/4;
  532|      0|      Ptr<const uint32_t> uint_bit_set = bit_set.Cast<const uint32_t>();
  533|      0|      size_t bit_count = 0;
  534|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) {
  535|      0|        const uint32_t v = uint_bit_set[i];
  536|      0|        const uint32_t t1 = v - ((v >> 1) & 0x55555555);
  537|      0|        const uint32_t t2 = (t1 & 0x33333333) + ((t1 >> 2) & 0x33333333);
  538|      0|        bit_count += (((t2 + (t2 >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;
  539|      0|      }
  540|      0|      return bit_count;
  541|      0|    }
  542|       |
  543|       |    /// Count the number of ones in the BitVector.
  544|      0|    size_t CountOnes() const { return CountOnes_Mixed(); }
  545|       |
  546|       |    /// Return the position of the first one; return -1 if no ones in vector.
  547|      0|    int FindBit() const {
  548|      0|      const size_t NUM_FIELDS = NumFields();
  549|      0|      size_t field_id = 0;
  550|      0|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  551|      0|      return (field_id < NUM_FIELDS) ?
  552|      0|        (int) (find_bit(bit_set[field_id]) + (field_id * FIELD_BITS))  :  -1;
  553|      0|    }
  554|       |
  555|       |    /// Return the position of the first one and change it to a zero.  Return -1 if no ones.
  556|      0|    int PopBit() {
  557|      0|      const size_t NUM_FIELDS = NumFields();
  558|      0|      size_t field_id = 0;
  559|      0|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  560|      0|      if (field_id == NUM_FIELDS) return -1;  // Failed to find bit!
  561|      0|
  562|      0|      const size_t pos_found = find_bit(bit_set[field_id]);
  563|      0|      constexpr field_t val_one = 1;
  564|      0|      bit_set[field_id] &= ~(val_one << pos_found);
  565|      0|      return (int) (pos_found + (field_id * FIELD_BITS));
  566|      0|    }
  567|       |
  568|       |    /// Return the position of the first one after start_pos; return -1 if no ones in vector.
  569|       |    /// You can loop through all 1-bit positions of a BitVector "bv" with:
  570|       |    ///
  571|       |    ///   for (int pos = bv.FindBit(); pos >= 0; pos = bv.FindBit(pos+1)) { ... }
  572|       |
  573|      0|    int FindBit(const size_t start_pos) const {
  574|      0|      if (start_pos >= num_bits) return -1;
  575|      0|      size_t field_id  = FieldID(start_pos);     // What field do we start in?
  576|      0|      const size_t field_pos = FieldPos(start_pos);    // What position in that field?
  577|      0|      if (field_pos && (bit_set[field_id] & ~(MaskLow<field_t>(field_pos)))) {  // First field hit!
  578|      0|        return (int) (find_bit(bit_set[field_id] & ~(MaskLow<field_t>(field_pos))) +
  579|      0|                      field_id * FIELD_BITS);
  580|      0|      }
  581|      0|
  582|      0|      // Search other fields...
  583|      0|      const size_t NUM_FIELDS = NumFields();
  584|      0|      if (field_pos) field_id++;
  585|      0|      while (field_id < NUM_FIELDS && bit_set[field_id]==0) field_id++;
  586|      0|      return (field_id < NUM_FIELDS) ?
  587|      0|        (int) (find_bit(bit_set[field_id]) + (field_id * FIELD_BITS)) : -1;
  588|      0|    }
  589|       |
  590|       |    /// Return positions of all ones.
  591|      0|    emp::vector<size_t> GetOnes() const {
  592|      0|      // @CAO -- There are probably better ways to do this with bit tricks.
  593|      0|      emp::vector<size_t> out_set(CountOnes());
  594|      0|      size_t cur_pos = 0;
  595|      0|      for (size_t i = 0; i < num_bits; i++) {
  596|      0|        if (Get(i)) out_set[cur_pos++] = i;
  597|      0|      }
  598|      0|      return out_set;
  599|      0|    }
  600|       |
  601|       |    /// Perform a Boolean NOT on this BitVector and return the result.
  602|      0|    BitVector NOT() const {
  603|      0|      const size_t NUM_FIELDS = NumFields();
  604|      0|      BitVector out_set(*this);
  605|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~bit_set[i];
  606|      0|      if (LastBitID() > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  607|      0|      return out_set;
  608|      0|    }
  609|       |
  610|       |    /// Perform a Boolean AND on this BitVector and return the result.
  611|      0|    BitVector AND(const BitVector & set2) const {
  612|      0|      const size_t NUM_FIELDS = NumFields();
  613|      0|      BitVector out_set(*this);
  614|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] & set2.bit_set[i];
  615|      0|      return out_set;
  616|      0|    }
  617|       |
  618|       |    /// Perform a Boolean OR on this BitVector and return the result.
  619|      0|    BitVector OR(const BitVector & set2) const {
  620|      0|      const size_t NUM_FIELDS = NumFields();
  621|      0|      BitVector out_set(*this);
  622|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] | set2.bit_set[i];
  623|      0|      return out_set;
  624|      0|    }
  625|       |
  626|       |    /// Perform a Boolean NAND on this BitVector and return the result.
  627|      0|    BitVector NAND(const BitVector & set2) const {
  628|      0|      const size_t NUM_FIELDS = NumFields();
  629|      0|      BitVector out_set(*this);
  630|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] & set2.bit_set[i]);
  631|      0|      if (LastBitID() > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  632|      0|      return out_set;
  633|      0|    }
  634|       |
  635|       |    /// Perform a Boolean NOR on this BitVector and return the result.
  636|      0|    BitVector NOR(const BitVector & set2) const {
  637|      0|      const size_t NUM_FIELDS = NumFields();
  638|      0|      BitVector out_set(*this);
  639|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] | set2.bit_set[i]);
  640|      0|      if (LastBitID() > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  641|      0|      return out_set;
  642|      0|    }
  643|       |
  644|       |    /// Perform a Boolean XOR on this BitVector and return the result.
  645|      0|    BitVector XOR(const BitVector & set2) const {
  646|      0|      const size_t NUM_FIELDS = NumFields();
  647|      0|      BitVector out_set(*this);
  648|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = bit_set[i] ^ set2.bit_set[i];
  649|      0|      return out_set;
  650|      0|    }
  651|       |
  652|       |    /// Perform a Boolean EQU on this BitVector and return the result.
  653|      0|    BitVector EQU(const BitVector & set2) const {
  654|      0|      const size_t NUM_FIELDS = NumFields();
  655|      0|      BitVector out_set(*this);
  656|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) out_set.bit_set[i] = ~(bit_set[i] ^ set2.bit_set[i]);
  657|      0|      if (LastBitID() > 0) out_set.bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  658|      0|      return out_set;
  659|      0|    }
  660|       |
  661|       |
  662|       |    /// Perform a Boolean NOT with this BitVector, store result here, and return this object.
  663|      0|    BitVector & NOT_SELF() {
  664|      0|      const size_t NUM_FIELDS = NumFields();
  665|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~bit_set[i];
  666|      0|      if (LastBitID() > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  667|      0|      return *this;
  668|      0|    }
  669|       |
  670|       |    /// Perform a Boolean AND with this BitVector, store result here, and return this object.
  671|      0|    BitVector & AND_SELF(const BitVector & set2) {
  672|      0|      const size_t NUM_FIELDS = NumFields();
  673|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] & set2.bit_set[i];
  674|      0|      return *this;
  675|      0|    }
  676|       |
  677|       |    /// Perform a Boolean OR with this BitVector, store result here, and return this object.
  678|      0|    BitVector & OR_SELF(const BitVector & set2) {
  679|      0|      const size_t NUM_FIELDS = NumFields();
  680|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] | set2.bit_set[i];
  681|      0|      return *this;
  682|      0|    }
  683|       |
  684|       |    /// Perform a Boolean NAND with this BitVector, store result here, and return this object.
  685|      0|    BitVector & NAND_SELF(const BitVector & set2) {
  686|      0|      const size_t NUM_FIELDS = NumFields();
  687|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] & set2.bit_set[i]);
  688|      0|      if (LastBitID() > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  689|      0|      return *this;
  690|      0|    }
  691|       |
  692|       |    /// Perform a Boolean NOR with this BitVector, store result here, and return this object.
  693|      0|    BitVector & NOR_SELF(const BitVector & set2) {
  694|      0|      const size_t NUM_FIELDS = NumFields();
  695|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] | set2.bit_set[i]);
  696|      0|      if (LastBitID() > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  697|      0|      return *this;
  698|      0|    }
  699|       |
  700|       |    /// Perform a Boolean XOR with this BitVector, store result here, and return this object.
  701|      0|    BitVector & XOR_SELF(const BitVector & set2) {
  702|      0|      const size_t NUM_FIELDS = NumFields();
  703|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = bit_set[i] ^ set2.bit_set[i];
  704|      0|      return *this;
  705|      0|    }
  706|       |
  707|       |    /// Perform a Boolean EQU with this BitVector, store result here, and return this object.
  708|      0|    BitVector & EQU_SELF(const BitVector & set2) {
  709|      0|      const size_t NUM_FIELDS = NumFields();
  710|      0|      for (size_t i = 0; i < NUM_FIELDS; i++) bit_set[i] = ~(bit_set[i] ^ set2.bit_set[i]);
  711|      0|      if (LastBitID() > 0) bit_set[NUM_FIELDS - 1] &= MaskLow<field_t>(LastBitID());
  712|      0|      return *this;
  713|      0|    }
  714|       |
  715|       |    /// Positive shifts go left and negative go right (0 does nothing); return result.
  716|      0|    BitVector SHIFT(const int shift_size) const {
  717|      0|      BitVector out_set(*this);
  718|      0|      if (shift_size > 0) out_set.ShiftRight((size_t) shift_size);
  719|      0|      else if (shift_size < 0) out_set.ShiftLeft((size_t) -shift_size);
  720|      0|      return out_set;
  721|      0|    }
  722|       |
  723|       |    /// Positive shifts go left and negative go right; store result here, and return this object.
  724|      0|    BitVector & SHIFT_SELF(const int shift_size) {
  725|      0|      if (shift_size > 0) ShiftRight((size_t) shift_size);
  726|      0|      else if (shift_size < 0) ShiftLeft((size_t) -shift_size);
  727|      0|      return *this;
  728|      0|    }
  729|       |
  730|       |
  731|       |    /// Operator bitwise NOT...
  732|      0|    BitVector operator~() const { return NOT(); }
  733|       |
  734|       |    /// Operator bitwise AND...
  735|      0|    BitVector operator&(const BitVector & ar2) const { return AND(ar2); }
  736|       |
  737|       |    /// Operator bitwise OR...
  738|      0|    BitVector operator|(const BitVector & ar2) const { return OR(ar2); }
  739|       |
  740|       |    /// Operator bitwise XOR...
  741|      0|    BitVector operator^(const BitVector & ar2) const { return XOR(ar2); }
  742|       |
  743|       |    /// Operator shift left...
  744|      0|    inline BitVector operator<<(const size_t shift_size) const { return SHIFT(-(int)shift_size); }
  745|       |
  746|       |    /// Operator shift right...
  747|      0|    inline BitVector operator>>(const size_t shift_size) const { return SHIFT((int)shift_size); }
  748|       |
  749|       |    /// Compound operator bitwise AND...
  750|      0|    const BitVector & operator&=(const BitVector & ar2) { return AND_SELF(ar2); }
  751|       |
  752|       |    /// Compound operator bitwise OR...
  753|      0|    const BitVector & operator|=(const BitVector & ar2) { return OR_SELF(ar2); }
  754|       |
  755|       |    /// Compound operator bitwise XOR...
  756|      0|    const BitVector & operator^=(const BitVector & ar2) { return XOR_SELF(ar2); }
  757|       |
  758|       |    /// Compound operator for shift left...
  759|      0|    const BitVector & operator<<=(const size_t shift_size) { return SHIFT_SELF(-(int)shift_size); }
  760|       |
  761|       |    /// Compound operator for shift right...
  762|      0|    const BitVector & operator>>=(const size_t shift_size) { return SHIFT_SELF((int)shift_size); }
  763|       |
  764|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  765|      0|    size_t size() const { return num_bits; }
  766|       |
  767|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  768|      0|    void resize(std::size_t new_size) { Resize(new_size); }
  769|       |
  770|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  771|      0|    bool all() const { return All(); }
  772|       |
  773|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  774|      0|    bool any() const { return Any(); }
  775|       |
  776|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  777|      0|    bool none() const { return !Any(); }
  778|       |
  779|       |    /// Function to allow drop-in replacement with std::vector<bool>.
  780|      0|    size_t count() const { return CountOnes_Mixed(); }
  781|       |  };
  782|       |
  783|       |}
  784|       |
  785|       |namespace std {
  786|       |  /// Hash function to allow BitVector to be used with maps and sets (must be in std).
  787|       |  template <>
  788|       |  struct hash<emp::BitVector> {
  789|      0|    std::size_t operator()(const emp::BitVector & b) const {
  790|      0|      return b.Hash();
  791|      0|    }
  792|       |  };
  793|       |
  794|       |  /// operator<< to work with ostream (must be in std to work)
  795|      0|  inline std::ostream & operator<<(std::ostream & out, const emp::BitVector & bit_v) {
  796|      0|    bit_v.Print(out);
  797|      0|    return out;
  798|      0|  }
  799|       |}
  800|       |
  801|       |#endif
  802|       |

/home/emily/repos/Empirical_Tests/source/tools/DFA.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  DFA.h
    7|       | *  @brief A Deterministic Finite Automata simulator.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_DFA_H
   12|       |#define EMP_DFA_H
   13|       |
   14|       |#include <string>
   15|       |
   16|       |#include "../base/array.h"
   17|       |#include "../base/vector.h"
   18|       |
   19|       |#include "string_utils.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  template <int NUM_SYMBOLS=128, typename STOP_TYPE=uint8_t>
   24|       |  class tDFA {
   25|       |  private:
   26|       |    emp::vector< emp::array<int, NUM_SYMBOLS> > transitions;
   27|       |    emp::vector< STOP_TYPE > is_stop;  // 0=not stop; other values for STOP return value.
   28|       |  public:
   29|     43|    /*_FORCE_COVER_START_*/tDFA(size_t num_states=0) : transitions(num_states), is_stop(num_states, 0) {
   30|     43|      for (auto & t : transitions) t.fill(-1);
   31|     43|    }/*_FORCE_COVER_END_*/
   32|     25|    /*_FORCE_COVER_START_*/tDFA(const tDFA<NUM_SYMBOLS, STOP_TYPE> &) = default/*_FORCE_COVER_END_*/;
   33|     68|    /*_FORCE_COVER_START_*/~tDFA() { ; }/*_FORCE_COVER_END_*/
   34|      8|    /*_FORCE_COVER_START_*/tDFA<NUM_SYMBOLS, STOP_TYPE> & operator=(const tDFA<NUM_SYMBOLS, STOP_TYPE> &) = default/*_FORCE_COVER_END_*/;
   35|       |
   36|       |    using stop_t = STOP_TYPE;
   37|       |
   38|       |    /// How many states is this DFA using?
   39|     45|    /*_FORCE_COVER_START_*/size_t GetSize() const { return transitions.size(); }/*_FORCE_COVER_END_*/
   40|       |
   41|       |    /// Add Additional empty states.
   42|     44|    /*_FORCE_COVER_START_*/void Resize(size_t new_size) {
   43|     44|      auto old_size = transitions.size();
   44|     44|      transitions.resize(new_size);
   45|     44|      is_stop.resize(new_size, 0);
   46|     88|      for (auto i = old_size; i < transitions.size(); i++) transitions[i].fill(-1);
   47|     44|    }/*_FORCE_COVER_END_*/
   48|       |
   49|       |    /// Return an array of all transitions associated with a specified state.
   50|      0|    /*_FORCE_COVER_START_*/const emp::array<int, NUM_SYMBOLS> & GetTransitions(size_t from) const {
   51|      0|      return transitions[from];
   52|      0|    }/*_FORCE_COVER_END_*/
   53|       |
   54|       |    /// Add a specific transition associated with an input symbol.
   55|  1.45k|    /*_FORCE_COVER_START_*/void SetTransition(size_t from, size_t to, size_t sym) {
   56|  1.45k|      emp_assert(from < transitions.size());
   57|  1.45k|      emp_assert(to < transitions.size());
   58|  1.45k|      emp_assert(sym < NUM_SYMBOLS);
   59|  1.45k|      transitions[from][sym] = (int) to;
   60|  1.45k|    }/*_FORCE_COVER_END_*/
   61|       |
   62|       |    /// Set the stop value (no matter what it currently is)
   63|       |    /*_FORCE_COVER_START_*/void SetStop(size_t state, stop_t stop_val=1) {
   64|       |      emp_assert(state < transitions.size());
   65|       |      is_stop[state] = stop_val;
   66|       |    }/*_FORCE_COVER_END_*/
   67|       |
   68|       |    /// Set the stop value only if it's higher than the current stop value.
   69|    128|    /*_FORCE_COVER_START_*/void AddStop(size_t state, stop_t stop_val=1) {
   70|    128|      emp_assert(state < transitions.size());
   71|    128|      // If we are given a stop value and its higher than our previous stop, use it!
   72|    128|      if (stop_val > is_stop[state]) is_stop[state] = stop_val;
   73|    128|    }/*_FORCE_COVER_END_*/
   74|       |
   75|       |    /// Get the stop value associated with a state.
   76|     68|    /*_FORCE_COVER_START_*/stop_t GetStop(int state) const { return (state == -1) ? 0 : is_stop[(size_t)state]; }/*_FORCE_COVER_END_*/
   77|       |
   78|       |    /// Test if a state is still valid.
   79|       |    /*_FORCE_COVER_START_*/bool IsActive(int state) const { return state != -1; }/*_FORCE_COVER_END_*/
   80|       |
   81|       |    /// Test if a state has a stop.
   82|      9|    /*_FORCE_COVER_START_*/bool IsStop(int state) const { return (state == -1) ? false : is_stop[(size_t)state]; }/*_FORCE_COVER_END_*/
   83|       |
   84|       |    // If a size_t is passed in, it can't be -1...
   85|      0|    /*_FORCE_COVER_START_*/stop_t GetStop(size_t state) const { return is_stop[state]; }/*_FORCE_COVER_END_*/
   86|       |    /*_FORCE_COVER_START_*/bool IsActive(size_t state) const { return true; }/*_FORCE_COVER_END_*/
   87|      0|    /*_FORCE_COVER_START_*/bool IsStop(size_t state) const { return is_stop[state]; }/*_FORCE_COVER_END_*/
   88|       |
   89|       |    /// Return the new state after a symbol occurs.
   90|    299|    /*_FORCE_COVER_START_*/int Next(int state, size_t sym) const {
   91|    299|      emp_assert(state >= -1 && state < (int) transitions.size());
   92|    299|      // emp_assert(sym >= 0 && sym < NUM_SYMBOLS, sym, (char) sym);
   93|    299|      return (state < 0 || sym >= NUM_SYMBOLS) ? -1 : transitions[(size_t)state][sym];
   94|    299|    }/*_FORCE_COVER_END_*/
   95|       |
   96|       |    /// Return the new state after a series of symbols.
   97|     46|    /*_FORCE_COVER_START_*/int Next(int state, std::string sym_set) const {
   98|    247|      for (char x : sym_set) state = Next(state, (size_t) x);
   99|     46|      return state;
  100|     46|    }/*_FORCE_COVER_END_*/
  101|       |
  102|       |    /// Determine if an entire series of symbols is valid.
  103|     23|    /*_FORCE_COVER_START_*/stop_t Test(const std::string & str) const {
  104|     23|      int out = Next(0, str);
  105|     23|      return GetStop(out);
  106|     23|    }/*_FORCE_COVER_END_*/
  107|       |
  108|       |    /// Print details about this DFA.
  109|      0|    /*_FORCE_COVER_START_*/void Print(std::ostream & os=std::cout) {
  110|      0|      os << "Num states = " << GetSize() << std::endl << "Stop IDs:";
  111|      0|      for (size_t i = 0; i < GetSize(); i++) if(IsStop(i)) os << " " << i;
  112|      0|      os << std::endl;
  113|      0|
  114|      0|      for (size_t i = 0; i < transitions.size(); i++) {
  115|      0|        os << " " << i << " ->";
  116|      0|        for (size_t s = 0; s < NUM_SYMBOLS; s++) {
  117|      0|          if (transitions[i][s] == -1) continue;
  118|      0|          os << " " << to_literal((char) s) << ":" << transitions[i][s];
  119|      0|        }
  120|      0|        if (IsStop(i)) os << " [STOP=" << ((int) GetStop(i)) << "]";
  121|      0|        os << std::endl;
  122|      0|      }
  123|      0|
  124|      0|    }/*_FORCE_COVER_END_*/
  125|       |
  126|       |  };
  127|       |
  128|       |  /// Setup DFA to be a simple tDFA with the basic character set for symbols.
  129|       |  using DFA = tDFA<128, uint8_t>;
  130|       |
  131|       |}
  132|       |
  133|       |#endif
  134|       |

/home/emily/repos/Empirical_Tests/source/tools/DynamicString.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  DynamicString.h
    7|       | *  @brief A string handler where sections update dynamically based on functions.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_DYNAMIC_STRING_H
   13|       |#define EMP_DYNAMIC_STRING_H
   14|       |
   15|       |#include <functional>
   16|       |#include <string>
   17|       |
   18|       |#include "../base/vector.h"
   19|       |
   20|       |namespace emp {
   21|       |
   22|       |  /// A string handler where some sections can be fixed strings, while others update
   23|       |  /// dynamically based on functions.
   24|       |  class DynamicString {
   25|       |  public:
   26|       |    using value_t = std::function<std::string()>;
   27|       |  private:
   28|       |    emp::vector<value_t> fun_set;  // Functions to update strings.
   29|       |
   30|       |  public:
   31|      1|    DynamicString() { ; }
   32|       |    DynamicString(const DynamicString &) = default;
   33|       |
   34|       |    /// How many string components (funcations or continuous substrings) are in this DynamicString?
   35|      3|    size_t GetSize() const { return fun_set.size(); }
   36|       |
   37|       |    /// Index in to a specific component (not a specific character, since size is variable)
   38|       |    /// and return it's associated string.
   39|     10|    std::string operator[](size_t id) const { return fun_set[id](); }
   40|       |
   41|       |    /// Index in to a specific component (not a specific character, since size is variable)
   42|       |    /// and return it's associated function.
   43|      0|    const value_t & GetFunction(size_t id) const { return fun_set[id]; }
   44|       |
   45|       |    /// Remove all contents on this DynamicString
   46|      0|    DynamicString & Clear() { fun_set.resize(0); return *this; }
   47|       |
   48|       |    /// Convert to an std::string.
   49|      1|    std::string str() {
   50|      1|      std::stringstream ss;
   51|      2|      for (auto & cur_fun : fun_set) ss << cur_fun();
   52|      1|      return ss.str();
   53|      1|    }
   54|       |
   55|       |    /// Set the value of a specified component to the provided function.
   56|      1|    DynamicString & Set(size_t id, const value_t & in_fun) {
   57|      1|      fun_set[id] = in_fun;
   58|      1|      return *this;
   59|      1|    }
   60|       |
   61|       |    /// Set the value of a specified component to the provided std::string text.
   62|      1|    DynamicString & Set(size_t id, const std::string & in_text) {
   63|      2|      return Set( id, [in_text](){ return in_text; } );
   64|      1|    }
   65|       |
   66|       |    /// Add a new function to the end of the DynamicString.
   67|      5|    DynamicString & Append(const value_t & in_fun) {
   68|      5|      fun_set.push_back(in_fun);
   69|      5|      return *this;
   70|      5|    }
   71|       |
   72|       |    /// Add new std::string text to the end of the DynamicString.
   73|       |    // (automatically create a function that just returns that string.)
   74|      2|    DynamicString & Append(const std::string & in_text) {
   75|      5|      return Append( [in_text](){ return in_text; } );
   76|      2|    }
   77|       |
   78|       |    /// Allow operator<< to append to the back of a DynamicString.
   79|       |    /*_FORCE_COVER_START_*/template <typename IN_TYPE>
   80|      1|    DynamicString & operator<<(IN_TYPE && _in) { return Append(_in); }/*_FORCE_COVER_END_*/
   81|       |
   82|       |  };
   83|       |
   84|       |}
   85|       |
   86|       |namespace std {
   87|       |  /// Make sure that DynamicString works with with std::ostream.
   88|       |  std::ostream & operator<<( std::ostream & os, const emp::DynamicString & strings )
   89|      1|  {
   90|      3|    for (size_t i = 0; i < strings.GetSize(); ++i) {
   91|      2|      os << strings[i];
   92|      2|    }
   93|      1|    return os;
   94|      1|  }
   95|       |}
   96|       |
   97|       |#endif
   98|       |

/home/emily/repos/Empirical_Tests/source/tools/FunctionSet.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  FunctionSet.h
    7|       | *  @brief Setup a collection of functions, all with the same signature, that can be run as a group.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_FUNCTION_SET_H
   12|       |#define EMP_FUNCTION_SET_H
   13|       |
   14|       |#include <functional>
   15|       |#include "../base/vector.h"
   16|       |
   17|       |namespace emp {
   18|       |
   19|       |  template <typename T> class FunctionSet;
   20|       |
   21|       |  /// A vector of functions that can all be triggered at onece; results can either be returned
   22|       |  /// in a vector or post-processed in a function (such as max, min, etc.)
   23|       |  /// Derived from emp::vector, hence with all of the same methods as vector.
   24|       |  template <typename RETURN_T, typename... ARGS>
   25|       |  class FunctionSet<RETURN_T(ARGS...)> : public emp::vector<std::function<RETURN_T(ARGS...)>> {
   26|       |  protected:
   27|       |    mutable emp::vector<RETURN_T> return_vals;
   28|       |
   29|       |  public:
   30|      1|    FunctionSet() : return_vals() { ; }
   31|      1|    ~FunctionSet() { ; }
   32|       |
   33|       |    using base_t = emp::vector<std::function<RETURN_T(ARGS...)>>;
   34|       |    using value_type = typename base_t::value_type;
   35|       |    using return_t = RETURN_T;
   36|       |
   37|       |    /// How many functions are in this FunctionSet?
   38|       |    size_t GetSize() const { return base_t::size(); }
   39|       |
   40|       |    /// Add a new funtion to this FunctionSet
   41|      3|    void Add(const value_type & in_fun) { base_t::push_back(in_fun); }
   42|       |
   43|       |    /// Remove the function at a specified position.
   44|       |    void Remove(size_t pos) { base_t::erase(base_t::begin()+pos); }
   45|       |
   46|       |    /// Run all functions and return a vector of all results.
   47|     24|    const emp::vector<RETURN_T> & Run(ARGS... args) const {
   48|     24|      const size_t num_tests = base_t::size();
   49|     24|      return_vals.resize(num_tests);
   50|     96|      for (size_t i = 0; i < num_tests; i++) {
   51|     72|        return_vals[i] = (*this)[i](args...);
   52|     72|      }
   53|     24|      return return_vals;
   54|     24|    }
   55|       |
   56|       |    /// If you want to provide a filter function, you can retrieve a specific return value.
   57|       |    /// The filter should take in two return values and indicate which is "better".
   58|       |    RETURN_T Run(ARGS... args, std::function<RETURN_T(RETURN_T, RETURN_T)> comp_fun,
   59|     20|                 RETURN_T default_val=0) const {
   60|     20|      if (base_t::size() == 0) return default_val;  // If we have no entries, return the default.
   61|     20|
   62|     20|      Run(args...);
   63|     20|
   64|     20|      RETURN_T best_found = return_vals[0];
   65|     60|      for (size_t i = 1; i < return_vals.size(); i++) {
   66|     40|        best_found = comp_fun(best_found, return_vals[i]);
   67|     40|      }
   68|     20|
   69|     20|      return best_found;
   70|     20|    }
   71|       |
   72|       |    /// Run all functions and return the highest value.
   73|      5|    RETURN_T FindMax(ARGS... args, RETURN_T default_val=0) const {
   74|     10|      return Run(args..., [](double i1, double i2){ return std::max(i1,i2); }, default_val);
   75|      5|    }
   76|       |
   77|       |    /// Run all functions and return the lowest value.
   78|      5|    RETURN_T FindMin(ARGS... args, RETURN_T default_val=0) const {
   79|     10|      return Run(args..., [](double i1, double i2){ return std::min(i1,i2); }, default_val);
   80|      5|    }
   81|       |
   82|       |    /// Run all functions and return the total value.
   83|      5|    RETURN_T FindSum(ARGS... args, RETURN_T default_val=0) const {
   84|     10|      return Run(args..., [](double i1, double i2){ return i1 + i2; }, default_val);
   85|      5|    }
   86|       |
   87|       |    /// Run all functions and return a product of all values.
   88|       |    RETURN_T FindProduct(ARGS... args, RETURN_T default_val=1) const {
   89|       |      return Run(args..., [](double i1, double i2){ return i1 * i2; }, default_val);
   90|       |    }
   91|       |  };
   92|       |
   93|       |
   94|       |  /// A specialized version of FunctionSet for void functions.
   95|       |  template <typename... ARGS>
   96|       |  class FunctionSet<void(ARGS...)> : public emp::vector<std::function<void(ARGS...)>> {
   97|       |  public:
   98|      1|    FunctionSet() { ; }
   99|      1|    ~FunctionSet() { ; }
  100|       |
  101|       |    using base_t = emp::vector<std::function<void(ARGS...)>>;
  102|       |    using value_type = typename base_t::value_type;
  103|       |    using return_t = void;
  104|       |
  105|       |    /// How many functions are in this FunctionSet?
  106|       |    size_t GetSize() const { return base_t::size(); }
  107|       |
  108|       |    /// Add a new function to this FunctionSet.
  109|      4|    void Add(const std::function<void(ARGS...)> & in_fun) { base_t::push_back(in_fun); }
  110|       |
  111|       |    /// Remove the function at the designated position from this FunctionSet.
  112|      1|    void Remove(size_t pos) { base_t::erase(base_t::begin()+(int)pos); }
  113|       |
  114|       |    /// Run all functions in the FunctionSet
  115|      2|    void Run(ARGS... args) const {
  116|      7|      for (const std::function<void(ARGS...)> & cur_fun : *this) {
  117|      7|        cur_fun(args...);
  118|      7|      }
  119|      2|    }
  120|       |  };
  121|       |
  122|       |}
  123|       |
  124|       |#endif
  125|       |

/home/emily/repos/Empirical_Tests/source/tools/GenericFunction.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2017
    5|       | *
    6|       | *  @file  GenericFunction.h
    7|       | *  @brief Based on std::function, but with a common base class.
    8|       | *  @note Status: ALPHA
    9|       | *
   10|       | *  @todo Need to setup Call on emp::GenericFunction to just take a function signature as a
   11|       | *    template argument, rather than listing all types.
   12|       | */
   13|       |
   14|       |
   15|       |#ifndef EMP_GENERIC_FUNCTION_H
   16|       |#define EMP_GENERIC_FUNCTION_H
   17|       |
   18|       |#include <functional>
   19|       |#include "../base/assert.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  ///  The emp::Function templated class behaves almost identically to std::function, but can be
   24|       |  ///  reduced to the emp::GenericFunction base class which is NOT templated.
   25|       |  ///
   26|       |  ///  An emp::GenericFunction object can be converted back into the derived type with the
   27|       |  ///  .Convert<return(args...)>() member function.
   28|       |
   29|       |  class GenericFunction {
   30|       |  protected:
   31|       |  public:
   32|      3|    virtual ~GenericFunction() { ; }
   33|       |
   34|       |    /// A generic form of the function call operator; use arg types to determine derived form.
   35|       |    template <typename RETURN, typename... Ts> auto Call(Ts &&... args);
   36|       |
   37|       |    /// A generic form of the function call operator; use arg types to determine derived form.
   38|       |    /*_FORCE_COVER_START_*/template <typename RETURN, typename... Ts> auto operator()(Ts &&... args) {
   39|       |      return Call<RETURN, Ts...>( std::forward<Ts>(args)... );
   40|       |    }/*_FORCE_COVER_END_*/
   41|       |
   42|       |    /// Convert this GenericFunction into a derived emp::Function
   43|       |    template <typename T> auto Convert();
   44|       |  };
   45|       |
   46|       |  // Undefined base type for Function, to create an error if a function type is not passed in.
   47|       |  template <typename... Ts> class Function;
   48|       |
   49|       |  // Specialized form for proper function types.
   50|       |  template <typename RETURN, typename... PARAMS>
   51|       |  class Function<RETURN(PARAMS...)> : public GenericFunction {
   52|       |  protected:
   53|       |    std::function<RETURN(PARAMS...)> fun;  /// The std::function to be called.
   54|       |  public:
   55|       |    /// Forward all args to std::function constructor...
   56|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
   57|      3|    Function(Ts &&... args) : fun(std::forward<Ts>(args)...) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8FunctionIJFvPNS_11TrackedTypeES2_EEEC2IJRZNS_11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJiiEEERSD_St8functionIFvDpT_EEEUlS2_S2_E_EEEDpOSH_:
  |   57|      1|    Function(Ts &&... args) : fun(std::forward<Ts>(args)...) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8FunctionIJFvPNS_11TrackedTypeES2_EEEC2IJRZNS_11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJidEEERSD_St8functionIFvDpT_EEEUlS2_S2_E_EEEDpOSH_:
  |   57|      1|    Function(Ts &&... args) : fun(std::forward<Ts>(args)...) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8FunctionIJFvPNS_11TrackedTypeES2_EEEC2IJRZNS_11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJSC_iEEERSD_St8functionIFvDpT_EEEUlS2_S2_E_EEEDpOSH_:
  |   57|      1|    Function(Ts &&... args) : fun(std::forward<Ts>(args)...) { ; }/*_FORCE_COVER_END_*/
  ------------------
   58|       |
   59|       |    /// Forward all args to std::function call.
   60|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
   61|      3|    RETURN Call(Ts &&... args) { return fun(std::forward<Ts>(args)...); }/*_FORCE_COVER_END_*/
   62|       |
   63|       |    /// Forward all args to std::function call.
   64|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
   65|       |    RETURN operator()(Ts &&... args) { return fun(std::forward<Ts>(args)...); }/*_FORCE_COVER_END_*/
   66|       |  };
   67|       |
   68|       |  /*_FORCE_COVER_START_*/template <typename RETURN, typename... Ts>
   69|      3|  auto GenericFunction::Call(Ts &&... args) {
   70|      3|    using fun_t = Function<RETURN(Ts...)>;
   71|      3|
   72|      3|    emp_assert(dynamic_cast<fun_t *>(this));  // Make sure this Call cast is legal.
   73|      3|
   74|      3|    fun_t * fun = (fun_t *) this;
   75|      3|    return fun->Call( std::forward<Ts>(args)... );
   76|      3|  }/*_FORCE_COVER_END_*/
   77|       |
   78|       |  /*_FORCE_COVER_START_*/template <typename T> auto GenericFunction::Convert() {
   79|       |    emp_assert(dynamic_cast<Function<T> *>(this));
   80|       |    return (Function<T> *) this;
   81|       |  }/*_FORCE_COVER_END_*/
   82|       |
   83|       |}
   84|       |
   85|       |#endif
   86|       |

/home/emily/repos/Empirical_Tests/source/tools/Graph.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2017
    5|       | *
    6|       | *  @file  Graph.h
    7|       | *  @brief A simple, fast class for managing verticies (nodes) and edges.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_GRAPH_H
   12|       |#define EMP_GRAPH_H
   13|       |
   14|       |#include <iostream>
   15|       |
   16|       |#include "../base/assert.h"
   17|       |#include "../base/vector.h"
   18|       |
   19|       |#include "BitVector.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  /// A graph class that maintains a set of vertices (nodes) and edges (connecting pairs of nodes)
   24|       |  class Graph {
   25|       |  public:
   26|       |    /// Information about nodes within a graph.
   27|       |    class Node {
   28|       |    private:
   29|       |      BitVector edge_set; /// What other node IDs is this one connected to?
   30|       |    public:
   31|      2|      Node(size_t num_nodes) : edge_set(num_nodes) { ; }
   32|     80|      Node(const Node & in_node) : edge_set(in_node.edge_set) { ; }
   33|     82|      ~Node() { ; }
   34|       |
   35|       |      /// Set this node to have the same connections as another node.
   36|      0|      Node & operator=(const Node & in_node) { edge_set = in_node.edge_set; return *this; }
   37|       |
   38|       |      /// Is this node connect to a specific other node?
   39|      0|      bool HasEdge(size_t to) const { return edge_set[to]; }
   40|       |
   41|       |      /// Add a connection between this node and another.
   42|     68|      void AddEdge(size_t to) { edge_set.Set(to, true); }
   43|       |
   44|       |      /// Add a full set of connections from this node to others.
   45|      0|      void AddEdgeSet(BitVector in_set) { edge_set |= in_set; }
   46|       |
   47|       |      /// Remove the connection (if there is one) between this node and another one.
   48|      0|      void RemoveEdge(size_t to) { edge_set.Set(to, false); }
   49|       |
   50|       |      /// Set whether a connection to another specific node should exist or not.
   51|      0|      void SetEdge(size_t to, bool val) { edge_set.Set(to, val); }
   52|       |
   53|       |      /// Get a BitVector representing which nodes this one is connected to.
   54|      0|      const BitVector & GetEdgeSet() const { return edge_set; }
   55|       |
   56|       |      /// Change the number of potential node connections that we are tracking.
   57|      0|      void Resize(size_t new_size) { edge_set.Resize(new_size); }
   58|       |
   59|       |      /// Remove all edges from this node.
   60|      0|      void Clear() { edge_set.Clear(); }
   61|       |
   62|       |      /// Identify how many other nodes this one is connected to.
   63|      0|      size_t GetDegree() const { return edge_set.CountOnes(); }
   64|       |
   65|       |      /// Identify how many other nodes from a provided set (a BitVector) this one is connected to.
   66|      0|      size_t GetMaskedDegree(const BitVector & mask) const { return (mask & edge_set).CountOnes(); }
   67|       |    };
   68|       |
   69|       |  protected:
   70|       |    emp::vector<Node> nodes;  ///< Set of vertices in this graph.
   71|       |
   72|       |  public:
   73|       |    /// Construct a new graph with the specified number of nodes.
   74|      2|    Graph(size_t num_nodes=0) : nodes(num_nodes, num_nodes) { ; }
   75|       |
   76|       |    Graph(const Graph &) = default;              ///< Copy constructor
   77|      2|    Graph(Graph &&) = default;                   ///< Move constructor
   78|      4|    ~Graph() { ; }
   79|       |
   80|       |    Graph & operator=(const Graph &) = default;  ///< Copy operator
   81|      0|    Graph & operator=(Graph &&) = default;       ///< Move operator
   82|       |
   83|       |    /// Get number of vertices in this graph.
   84|      1|    size_t GetSize() const { return nodes.size(); }
   85|       |
   86|       |    /// Get the total number of edges in this graph.
   87|      0|    size_t GetEdgeCount() const {
   88|      0|      size_t edge_count = 0;
   89|      0|      for (size_t i = 0; i < nodes.size(); i++) edge_count += nodes[i].GetDegree();
   90|      0|      return edge_count;
   91|      0|    }
   92|       |
   93|       |    /// Change the number of vertices in this graph.
   94|      0|    void Resize(size_t new_size) {
   95|      0|      nodes.resize(new_size, new_size);
   96|      0|      for (auto & node : nodes) {
   97|      0|	      node.Resize(new_size);
   98|      0|	      node.Clear();
   99|      0|      }
  100|      0|    }
  101|       |
  102|       |    /// Get the set of nodes that a specified node is connected to.
  103|      0|    const BitVector & GetEdgeSet(size_t id) const {
  104|      0|      emp_assert(id < nodes.size());
  105|      0|      return nodes[id].GetEdgeSet();
  106|      0|    }
  107|       |
  108|       |    /// Get the degree of a specified node.
  109|      0|    size_t GetDegree(size_t id) const {
  110|      0|      emp_assert(id < nodes.size());
  111|      0|      return nodes[id].GetDegree();
  112|      0|    }
  113|       |
  114|       |    /// Get how many of a set of nodes that a specified node is connected to.
  115|      0|    size_t GetMaskedDegree(size_t id, const BitVector & mask) const {
  116|      0|      emp_assert(id < nodes.size());
  117|      0|      return nodes[id].GetMaskedDegree(mask);
  118|      0|    }
  119|       |
  120|       |    /// Determine if a specific edge is included in this graph.
  121|      0|    bool HasEdge(size_t from, size_t to) const {
  122|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  123|      0|      return nodes[from].HasEdge(to);
  124|      0|    }
  125|       |
  126|       |    /// Add a specified edge into this graph.
  127|      0|    void AddEdge(size_t from, size_t to) {
  128|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  129|      0|      nodes[from].AddEdge(to);
  130|      0|    }
  131|       |
  132|       |    /// Remove a specified edge from this graph
  133|      0|    void RemoveEdge(size_t from, size_t to) {
  134|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  135|      0|      nodes[from].RemoveEdge(to);
  136|      0|    }
  137|       |
  138|       |    /// Set the status of a specified edge as to whether or not it should be in the graph.
  139|      0|    void SetEdge(size_t from, size_t to, bool val) {
  140|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  141|      0|      nodes[from].SetEdge(to, val);
  142|      0|    }
  143|       |
  144|       |    /// Determine if edges exist in both directions between a pair of vertices.
  145|      0|    bool HasEdgePair(size_t from, size_t to) const {
  146|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  147|      0|      return nodes[from].HasEdge(to) && nodes[to].HasEdge(from);
  148|      0|    }
  149|       |
  150|       |    /// Add a pair of edges between two vertieces (in both directions)
  151|     34|    void AddEdgePair(size_t from, size_t to) {
  152|     34|      emp_assert(from < nodes.size() && to < nodes.size());
  153|     34|      nodes[from].AddEdge(to);
  154|     34|      nodes[to].AddEdge(from);
  155|     34|    }
  156|       |
  157|       |    /// Remove edges in both directions between a pair of vertices.
  158|      0|    void RemoveEdgePair(size_t from, size_t to) {
  159|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  160|      0|      nodes[from].RemoveEdge(to);
  161|      0|      nodes[to].RemoveEdge(from);
  162|      0|    }
  163|       |
  164|       |    /// Set the status as to whether a pair of edges (in both direction) exist.
  165|      0|    void SetEdgePairs(size_t from, size_t to, bool val) {
  166|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  167|      0|      nodes[from].SetEdge(to, val);
  168|      0|      nodes[to].SetEdge(from, val);
  169|      0|    }
  170|       |
  171|       |    /// Merge a second graph into this one.
  172|      0|    void Merge(const Graph & in_graph) {
  173|      0|      const size_t start_size = nodes.size();
  174|      0|      const size_t new_size = start_size + in_graph.GetSize();
  175|      0|      nodes.resize(new_size, new_size);
  176|      0|      for (auto & node : nodes) {
  177|      0|	      node.Resize(new_size);
  178|      0|      }
  179|      0|
  180|      0|      for (size_t i = 0; i < in_graph.GetSize(); i++) {
  181|      0|        BitVector edge_set = in_graph.nodes[i].GetEdgeSet();
  182|      0|        edge_set.Resize(new_size);
  183|      0|        edge_set <<= start_size;
  184|      0|        nodes[start_size + i].AddEdgeSet(edge_set);
  185|      0|      }
  186|      0|    }
  187|       |
  188|       |    /// Print a symmetric graph to the provided output stream (defaulting to standard out)
  189|      0|    void PrintSym(std::ostream & os=std::cout) {
  190|      0|      os << GetSize() << " " << (GetEdgeCount()/2) << std::endl;
  191|      0|      for (size_t from = 0; from < nodes.size(); from++) {
  192|      0|        for (size_t to=from+1; to < nodes.size(); to++) {
  193|      0|          if (HasEdge(from, to) == false) continue;
  194|      0|	        emp_assert(HasEdge(to, from));              // This must be a symmetric graph!
  195|      0|          os << from << " " << to << std::endl;
  196|      0|        }
  197|      0|      }
  198|      0|    }
  199|       |
  200|       |    /// Print a directed graph to the provided output stream (defaulting to standard out)
  201|      0|    void PrintDirected(std::ostream & os=std::cout) {
  202|      0|      os << GetSize() << " " << GetEdgeCount() << std::endl;
  203|      0|      for (size_t from = 0; from < nodes.size(); from++) {
  204|      0|        for (size_t to = 0; to < nodes.size(); to++) {
  205|      0|          if (HasEdge(from, to) == false) continue;
  206|      0|          os << from << " " << to << std::endl;
  207|      0|        }
  208|      0|      }
  209|      0|    }
  210|       |
  211|       |  };
  212|       |
  213|       |  class WeightedGraph : public Graph {
  214|       |  protected:
  215|       |    emp::vector< emp::vector< double > > weights;
  216|       |
  217|       |  public:
  218|      0|    WeightedGraph(size_t num_nodes=0) : Graph(num_nodes), weights(num_nodes) {
  219|      0|      for (auto & row : weights) row.resize(num_nodes, 0.0);
  220|      0|    }
  221|       |
  222|       |    WeightedGraph(const WeightedGraph &) = default;              ///< Copy constructor
  223|      0|    WeightedGraph(WeightedGraph &&) = default;                   ///< Move constructor
  224|      0|    ~WeightedGraph() { ; }
  225|       |
  226|       |    WeightedGraph & operator=(const WeightedGraph &) = default;  ///< Copy operator
  227|      0|    WeightedGraph & operator=(WeightedGraph &&) = default;       ///< Move operator
  228|       |
  229|      0|    void Resize(size_t new_size) {
  230|      0|      Graph::Resize(new_size);
  231|      0|      weights.resize(new_size);
  232|      0|      for (auto & row : weights) row.resize(new_size,0.0);
  233|      0|    }
  234|       |
  235|       |    /// Determine weight of a specific edge in this graph.
  236|      0|    double GetWeight(size_t from, size_t to) const {
  237|      0|      emp_assert(from < nodes.size() && to < nodes.size());
  238|      0|      return weights[from][to];
  239|      0|    }
  240|       |
  241|       |    /// When Adding an edge, must also provide a weight.
  242|      0|    void AddEdge(size_t from, size_t to, double weight) {
  243|      0|      Graph::AddEdge(from, to);
  244|      0|      weights[from][to] = weight;
  245|      0|    }
  246|       |
  247|       |    /// When Adding an edge pair, must also provide a weight.
  248|      0|    void AddEdgePair(size_t from, size_t to, double weight) {
  249|      0|      Graph::AddEdgePair(from, to);
  250|      0|      weights[from][to] = weight;
  251|      0|      weights[to][from] = weight;
  252|      0|    }
  253|       |
  254|       |    /// Merge two WeightedGraphs into one
  255|      0|    void Merge(const WeightedGraph & in_graph) {
  256|      0|      const size_t start_size = nodes.size();
  257|      0|      Graph::Merge(in_graph);
  258|      0|      weights.resize(nodes.size());
  259|      0|      for (auto & row : weights) row.resize(nodes.size(), 0.0);
  260|      0|
  261|      0|      // Move the weights over.
  262|      0|      for (size_t i = 0; i < in_graph.GetSize(); i++) {
  263|      0|        for (size_t j = 0; j < in_graph.GetSize(); j++) {
  264|      0|          weights[i+start_size][j+start_size] = in_graph.weights[i][j];
  265|      0|        }
  266|      0|      }
  267|      0|    }
  268|       |
  269|       |    /// Print a symmetric graph to the provided output stream (defaulting to standard out)
  270|      0|    void PrintSym(std::ostream & os=std::cout) {
  271|      0|      os << GetSize() << " " << (GetEdgeCount()/2) << std::endl;
  272|      0|      for (size_t from = 0; from < nodes.size(); from++) {
  273|      0|        for (size_t to=from+1; to < nodes.size(); to++) {
  274|      0|          if (HasEdge(from, to) == false) continue;
  275|      0|	        emp_assert(HasEdge(to, from));              // This must be a symmetric graph!
  276|      0|          os << from << " " << to << " " << weights[from][to] << std::endl;
  277|      0|        }
  278|      0|      }
  279|      0|    }
  280|       |
  281|       |    /// Print a directed graph to the provided output stream (defaulting to standard out)
  282|      0|    void PrintDirected(std::ostream & os=std::cout) {
  283|      0|      os << GetSize() << " " << GetEdgeCount() << std::endl;
  284|      0|      for (size_t from = 0; from < nodes.size(); from++) {
  285|      0|        for (size_t to = 0; to < nodes.size(); to++) {
  286|      0|          if (HasEdge(from, to) == false) continue;
  287|      0|          os << from << " " << to << " " << weights[from][to] << std::endl;
  288|      0|        }
  289|      0|      }
  290|      0|    }
  291|       |
  292|       |  };
  293|       |}
  294|       |
  295|       |#endif
  296|       |

/home/emily/repos/Empirical_Tests/source/tools/Lexer.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  Lexer.h
    7|       | *  @brief A general-purpose, fast lexer.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_LEXER_H
   12|       |#define EMP_LEXER_H
   13|       |
   14|       |#include <map>
   15|       |#include <string>
   16|       |
   17|       |#include "../base/vector.h"
   18|       |
   19|       |#include "lexer_utils.h"
   20|       |#include "RegEx.h"
   21|       |
   22|       |namespace emp {
   23|       |
   24|       |  /// Information about an individual token type to be processed within a Lexer.
   25|       |  struct TokenInfo {
   26|       |    std::string name;    ///< Name of this token type.
   27|       |    RegEx regex;         ///< Pattern to describe token type.
   28|       |    size_t id;           ///< Unique id for token.
   29|       |    bool save_lexeme;    ///< Should we preserve the lexeme for this token?
   30|       |
   31|       |    // TokenInfo() : name(""), regex(""), id(-1), save_lexeme(false) { ; }
   32|       |    TokenInfo(const std::string & n, const std::string & r, size_t i, bool s=false)
   33|      7|      : name(n), regex(r), id(i), save_lexeme(s) { ; }
   34|      7|    TokenInfo(const TokenInfo &) = default;
   35|       |    TokenInfo & operator=(const TokenInfo &) = default;
   36|       |
   37|       |    /// Print out the status of this token (for debugging)
   38|      0|    void Print(std::ostream & os=std::cout) const {
   39|      0|      os << "Name:" << name
   40|      0|         << "  RegEx:" << regex.AsString()
   41|      0|         << "  ID:" << id
   42|      0|         << "  save_lexeme:" << save_lexeme
   43|      0|         << std::endl;
   44|      0|    }
   45|       |  };
   46|       |
   47|       |  /// Information about a token instance from an input stream.
   48|       |  struct Token {
   49|       |    size_t token_id;     ///< Which type of token is this?
   50|       |    std::string lexeme;  ///< The specific sequence matched by this token.
   51|       |
   52|     15|    Token(size_t id, const std::string & str="") : token_id(id), lexeme(str) { ; }
   53|       |    Token(const Token &) = default;
   54|       |    Token & operator=(const Token &) = default;
   55|       |
   56|       |    /// Token will automatically convert to its ID if used as an unsigned int.
   57|      3|    operator size_t() { return token_id; }
   58|       |
   59|       |    /// Token will automatically convert to its matched sequence (lexeme) is used as a string.
   60|      0|    operator const std::string &() { return lexeme; }
   61|       |  };
   62|       |
   63|       |  /// A lexer with a set of token types (and associated regular expressions)
   64|       |  class Lexer {
   65|       |  private:
   66|       |    emp::vector<TokenInfo> token_set;     ///< List of all active tokens.
   67|       |    size_t cur_token_id;                  ///< Which ID should the next new token get?
   68|       |    mutable bool generate_lexer;          ///< Do we need to regenerate the lexer?
   69|       |    mutable DFA lexer_dfa;                ///< Table driven lexer implementation.
   70|       |    std::string lexeme;                   ///< Current state of lexeme being generated.
   71|       |
   72|       |  public:
   73|       |    static const size_t MAX_TOKEN_ID = 256;      // How many token IDs are possible?
   74|       |    static const size_t ERROR_ID = MAX_TOKEN_ID; // Code for unknown token ID.
   75|      0|    static inline bool TokenOK(size_t id) { return id < MAX_TOKEN_ID; }
   76|       |
   77|       |    Lexer()
   78|      1|    : token_set(), cur_token_id(MAX_TOKEN_ID), generate_lexer(false), lexer_dfa(), lexeme() { }
   79|      1|    ~Lexer() { ; }
   80|       |
   81|       |    /// How many types of tokens can be identified in this Lexer?
   82|      0|    size_t GetNumTokens() const { return token_set.size(); }
   83|       |
   84|       |    /// Add a new token, specified by a name and the regex used to identify it.
   85|      7|    size_t AddToken(const std::string & in_name, const std::string & in_regex) {
   86|      7|      --cur_token_id;
   87|      7|      generate_lexer = true;
   88|      7|      token_set.emplace_back( in_name, in_regex, cur_token_id );
   89|      7|      return cur_token_id;
   90|      7|    }
   91|       |
   92|       |    /// How many total token types are allowed in this lexer?
   93|      0|    constexpr static size_t MaxTokenID() { return MAX_TOKEN_ID; }
   94|       |
   95|       |    /// Get the ID associated with a token type (you provide the token name)
   96|      0|    size_t GetTokenID(const std::string & name) const {
   97|      0|      for (const auto & t : token_set) {
   98|      0|        if (t.name == name) return t.id;
   99|      0|      }
  100|      0|      return ERROR_ID;
  101|      0|    }
  102|       |
  103|       |    /// Get the name associated with a token type (you provide the ID)
  104|      3|    std::string GetTokenName(size_t id) const {
  105|      3|      if (id >= MAX_TOKEN_ID) return "Error";
  106|      3|      if (id == 0) return "EOF";
  107|      3|      if (id < 128) return emp::to_escaped_string((char) id);  // Individual characters.
  108|     14|      for (const auto & t : token_set) {
  109|     14|        if (t.id == id) return t.name;
  110|     14|      }
  111|      3|      return "Unknown";
  112|      3|    }
  113|       |
  114|       |    /// Get the full information about a token (you provide the name)
  115|      0|    TokenInfo GetTokenInfo(const std::string & name) const {
  116|      0|      for (const auto & t : token_set) {
  117|      0|        if (t.name == name) return t;
  118|      0|      }
  119|      0|      return TokenInfo("", "", ERROR_ID);
  120|      0|    }
  121|       |
  122|       |    /// Create the NFA that will identify the current set of tokens in a sequence.
  123|      1|    void Generate() const {
  124|      1|      NFA lexer_nfa;
  125|      7|      for (const auto & t : token_set) {
  126|      7|        lexer_nfa.Merge( to_NFA(t.regex, t.id) );
  127|      7|      }
  128|      1|      generate_lexer = false; // We just generated it!  Don't again unless another change is made.
  129|      1|      lexer_dfa = to_DFA(lexer_nfa);
  130|      1|    }
  131|       |
  132|       |    /// Get the next token found in an input stream.
  133|     15|    Token Process(std::istream & is) {
  134|     15|      if (generate_lexer) Generate();
  135|     15|      size_t cur_pos = 0;
  136|     15|      size_t best_pos = 0;
  137|     15|      int cur_state = 0;
  138|     15|      int cur_stop = 0;
  139|     15|      int best_stop = -1;
  140|     15|      lexeme.resize(0);
  141|     15|
  142|     15|      // Keep looking as long as:
  143|     15|      // 1: We may still be able to contine the current lexeme.
  144|     15|      // 2: We have not entered an invalid state.
  145|     15|      // 3: Our input stream has more symbols.
  146|     60|      while (cur_stop >= 0 && cur_state >= 0 && is) {
  147|     45|        const char next_char = (char) is.get();
  148|     45|        cur_pos++;
  149|     45|        cur_state = lexer_dfa.Next(cur_state, (size_t) next_char);
  150|     45|        cur_stop = lexer_dfa.GetStop(cur_state);
  151|     45|        if (cur_stop > 0) { best_pos = cur_pos; best_stop = cur_stop; }
  152|     45|        lexeme.push_back( next_char );
  153|     45|      }
  154|     15|
  155|     15|      // If best_pos < cur_pos, we need to rewind the input stream and adjust the lexeme.
  156|     15|      if (best_pos > 0 && best_pos < cur_pos) {
  157|     15|        lexeme.resize(best_pos);
  158|     30|        while (best_pos < cur_pos) { is.unget(); cur_pos--; }
  159|     15|      }
  160|     15|
  161|     15|      // If we are at the end of this input stream (with no token to return) give back a 0.
  162|     15|      if (best_stop < 0) {
  163|      0|        if (!is) return { 0, "" };
  164|      0|        return { ERROR_ID, lexeme };
  165|      0|      }
  166|     15|
  167|     15|      return { (size_t) best_stop, lexeme };
  168|     15|    }
  169|       |
  170|       |    /// Shortcut to process a string rather than a stream.
  171|      0|    Token Process(std::string & in_str) {
  172|      0|      std::stringstream ss;
  173|      0|      ss << in_str;
  174|      0|      auto out_val = Process(ss);
  175|      0|      in_str = ss.str();
  176|      0|      return out_val;
  177|      0|    }
  178|       |
  179|       |    /// Get the lexeme associated with the last token identified.
  180|      0|    const std::string & GetLexeme() { return lexeme; }
  181|       |
  182|       |    /// Print the full information about this lexer (for debugging)
  183|      0|    void Print(std::ostream & os=std::cout) const {
  184|      0|      for (const auto & t : token_set) t.Print(os);
  185|      0|      if (generate_lexer) Generate();               // Do we need to regenerate the lexer?
  186|      0|      lexer_dfa.Print(os);                          // Table driven lexer implementation.
  187|      0|    }
  188|       |  };
  189|       |
  190|       |
  191|       |}
  192|       |
  193|       |#endif
  194|       |

/home/emily/repos/Empirical_Tests/source/tools/NFA.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  NFA.h
    7|       | *  @brief A Non-deterministic Finite Automata simulator
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  To build a standard NFA, use emp::NFA.  If you want to have more symbols or more stop states,
   11|       | *  use emp::tNFA<S,T> where S is the number of symbols and T is the type used for stop.
   12|       | *  (defaults are 128 for ASCII-128 and uint8_t respectively.)
   13|       | *
   14|       | *  The constructor can take as parameters the number of states and the id of the start state (both
   15|       | *  default to 0)
   16|       | *
   17|       | *  @note DFA's use SetTransition(), but NFA's use AddTransition.  This distinction is intentional
   18|       | *        since in a DFA a second SetTransition with the same start state and symbol will override
   19|       | *        first, while in an NFA a second AddTransition will always add a new option.
   20|       |*/
   21|       |
   22|       |
   23|       |#ifndef EMP_NFA_H
   24|       |#define EMP_NFA_H
   25|       |
   26|       |#include <map>
   27|       |#include <set>
   28|       |
   29|       |#include "../base/vector.h"
   30|       |#include "BitSet.h"
   31|       |#include "set_utils.h"
   32|       |
   33|       |namespace emp {
   34|       |
   35|       |  /// A dynamic NFA class, for easily building non-determanistic finite automata.
   36|       |  template <size_t S=128, typename STOP_TYPE=uint8_t>
   37|       |  class tNFA {
   38|       |  public:
   39|       |    static const constexpr size_t NUM_SYMBOLS = S;
   40|       |    using opts_t = BitSet<NUM_SYMBOLS>;
   41|       |    using stop_t = STOP_TYPE;
   42|       |
   43|       |  private:
   44|       |    struct Transition {
   45|       |      opts_t symbols;
   46|     74|      /*_FORCE_COVER_START_*/Transition() : symbols() { }/*_FORCE_COVER_END_*/
   47|       |    };
   48|       |    struct State {
   49|       |      std::map<size_t, Transition> trans;   ///< What symbol transitions are available?
   50|       |      std::set<size_t> free_to;             ///< What other states can you move to for free?
   51|       |      std::set<size_t> free_from;           ///< What other states can move here for free?
   52|    178|      /*_FORCE_COVER_START_*/State() : trans(), free_to(), free_from() { }/*_FORCE_COVER_END_*/
   53|       |    };
   54|       |
   55|       |    emp::vector<State> states;           ///< Information about available states.
   56|       |    size_t start;                        ///< Main start state (others might be reached for free.)
   57|       |    emp::vector< STOP_TYPE > is_stop;    ///< 0=no 1=yes (char instead of bool for speed)
   58|       |
   59|       |  public:
   60|       |    /*_FORCE_COVER_START_*/tNFA(size_t num_states=1, size_t start_state=0)
   61|     21|      : states(num_states), start(start_state), is_stop(num_states, 0) {
   62|     21|        if (num_states > start) states[start].free_to.insert(start);
   63|     21|      }/*_FORCE_COVER_END_*/
   64|     28|    /*_FORCE_COVER_START_*/tNFA(const tNFA<S,STOP_TYPE> &) = default/*_FORCE_COVER_END_*/;
   65|     49|    /*_FORCE_COVER_START_*/~tNFA() { ; }/*_FORCE_COVER_END_*/
   66|       |    /*_FORCE_COVER_START_*/tNFA<S,STOP_TYPE> & operator=(const tNFA<S,STOP_TYPE> &) = default/*_FORCE_COVER_END_*/;
   67|       |
   68|       |    /// Return the current number of states.
   69|    156|    /*_FORCE_COVER_START_*/size_t GetSize() const { return states.size(); }/*_FORCE_COVER_END_*/
   70|       |
   71|       |    /// Return start state and all others reachable through empty transitions.
   72|     23|    /*_FORCE_COVER_START_*/const std::set<size_t> & GetStart() const {
   73|     23|      emp_assert(start < states.size());
   74|     23|      return states[start].free_to;
   75|     23|    }/*_FORCE_COVER_END_*/
   76|       |
   77|       |    /// Return the states reachable from the current state given the provided symbol.
   78|       |    /*_FORCE_COVER_START_*/std::set<size_t> GetNext(size_t sym, size_t from_id=0) const {
   79|       |      std::set<size_t> to_set;
   80|       |      for (auto & t : states[from_id].trans) {
   81|       |        if (t.second.symbols[sym]) {
   82|       |          to_set.insert(t.first);
   83|       |          insert(to_set, states[t.first].free_to);
   84|       |        }
   85|       |      }
   86|       |      return to_set;
   87|       |    }/*_FORCE_COVER_END_*/
   88|       |
   89|       |    /// return the states reachable from the current set of states given the provided symbol.
   90|  7.35k|    /*_FORCE_COVER_START_*/std::set<size_t> GetNext(size_t sym, const std::set<size_t> from_set) const {
   91|  7.35k|      std::set<size_t> to_set;
   92|  16.5k|      for (size_t from_id : from_set) {
   93|  16.5k|        for (auto & t : states[from_id].trans) {
   94|  11.5k|          if (t.second.symbols[sym]) {
   95|  1.82k|            to_set.insert(t.first);
   96|  1.82k|            insert(to_set, states[t.first].free_to);
   97|  1.82k|          }
   98|  11.5k|        }
   99|  16.5k|      }
  100|  7.35k|      return to_set;
  101|  7.35k|    }/*_FORCE_COVER_END_*/
  102|       |
  103|       |    /// Does the provided state have free transitions?
  104|       |    /*_FORCE_COVER_START_*/bool HasFreeTransitions(size_t id) const { return states[id].free_to.size(); }/*_FORCE_COVER_END_*/
  105|       |
  106|       |    /// Does the provided state have symbol-transitions?
  107|  6.14k|    /*_FORCE_COVER_START_*/bool HasSymTransitions(size_t id) const { return states[id].trans.size(); }/*_FORCE_COVER_END_*/
  108|       |
  109|       |    /// Return an emp::BitSet indicating the symbols available from the provided set of states.
  110|       |    /*_FORCE_COVER_START_*/opts_t GetSymbolOptions(const std::set<size_t> & test_set) const {
  111|       |      opts_t options;
  112|       |      for (size_t id : test_set) {
  113|       |        for (const auto & t : states[id].trans) {
  114|       |          options |= t.second.symbols;
  115|       |        }
  116|       |      }
  117|       |      return options;
  118|       |    }/*_FORCE_COVER_END_*/
  119|       |
  120|       |    /// Change the number of available states.
  121|     88|    /*_FORCE_COVER_START_*/void Resize(size_t new_size) {
  122|     88|      states.resize(new_size);
  123|     88|      is_stop.resize(new_size, 0);
  124|     88|      if (new_size > start) states[start].free_to.insert(start);
  125|     88|    }/*_FORCE_COVER_END_*/
  126|       |
  127|       |    /// Add a new state into the NFA and return its id.
  128|     79|    /*_FORCE_COVER_START_*/size_t AddNewState() { size_t new_state = GetSize(); Resize(new_state+1); return new_state; }/*_FORCE_COVER_END_*/
  129|       |
  130|       |    /// Add a transition between states 'from' and 'to' that can be taken with the provided symbol.
  131|    660|    /*_FORCE_COVER_START_*/void AddTransition(size_t from, size_t to, size_t sym) {
  132|    660|      emp_assert(from < states.size(), from, states.size());
  133|    660|      emp_assert(to < states.size(), to, states.size());
  134|    660|
  135|    660|      states[from].trans[to].symbols[sym] = true;
  136|    660|    }/*_FORCE_COVER_END_*/
  137|       |
  138|       |    /// Add a transition between states 'from' and 'to' that can be taken with the provided symbols.
  139|      5|    /*_FORCE_COVER_START_*/void AddTransition(size_t from, size_t to, const std::string & sym_set) {
  140|      8|      for (char x : sym_set) AddTransition(from, to, (size_t) x);
  141|      5|    }/*_FORCE_COVER_END_*/
  142|       |
  143|       |    /// Add a transition between states 'from' and 'to' that can be taken with the provided symbols.
  144|     12|    /*_FORCE_COVER_START_*/void AddTransition(size_t from, size_t to, const BitSet<NUM_SYMBOLS> & sym_set) {
  145|     12|      emp_assert(from < states.size(), from, states.size());
  146|     12|      emp_assert(to < states.size(), to, states.size());
  147|     12|
  148|     12|      states[from].trans[to].symbols |= sym_set;
  149|     12|    }/*_FORCE_COVER_END_*/
  150|       |
  151|       |    /// Create a free transition between 'from' and 'to'.
  152|    146|    /*_FORCE_COVER_START_*/void AddFreeTransition(size_t from, size_t to) {
  153|    146|      emp_assert(from < states.size(), from, states.size());
  154|    146|      emp_assert(to < states.size(), to, states.size());
  155|    146|
  156|    146|      // Keep track of where free transitions could have come from and can continue to.
  157|    146|      auto extend_to = states[to].free_to;
  158|    146|      auto extend_from = states[from].free_from;
  159|    146|      extend_to.insert(to);
  160|    146|      extend_from.insert(from);
  161|    146|
  162|    146|      // Insert all combinations of where new moves can be coming from or going to.
  163|    205|      for (auto x : extend_from) {
  164|    268|        for (auto y : extend_to) {
  165|    268|          states[x].free_to.insert(y);
  166|    268|          states[y].free_from.insert(x);
  167|    268|        }
  168|    205|      }
  169|    146|
  170|    146|    }/*_FORCE_COVER_END_*/
  171|       |
  172|       |    /// Set the specified state to be a stop state (with an optional stop value.)
  173|       |    /*_FORCE_COVER_START_*/template <typename T=stop_t>
  174|     59|    /*_FORCE_COVER_START_*/void SetStop(size_t state, T stop_val=1) { is_stop[state] = (stop_t) stop_val; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4tNFAILm128EhE7SetStopImEEvmT_:
  |  174|     18|    /*_FORCE_COVER_START_*/void SetStop(size_t state, T stop_val=1) { is_stop[state] = (stop_t) stop_val; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4tNFAILm128EhE7SetStopIhEEvmT_:
  |  174|     41|    /*_FORCE_COVER_START_*/void SetStop(size_t state, T stop_val=1) { is_stop[state] = (stop_t) stop_val; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  175|       |
  176|       |    /// Get any stop value associated with the provided state.
  177|    128|    /*_FORCE_COVER_START_*/stop_t GetStop(size_t state) const { return is_stop[state]; }/*_FORCE_COVER_END_*/
  178|       |
  179|       |    /// Test if NFA begins at provided state (may have free transitions to other states)
  180|       |    /*_FORCE_COVER_START_*/bool IsStart(size_t state) const { return state == start; }/*_FORCE_COVER_END_*/
  181|       |
  182|       |    ///  Test if this state is a legal endpoint for the NFA.
  183|  3.92k|    /*_FORCE_COVER_START_*/bool IsStop(size_t state) const { return is_stop[state]; }/*_FORCE_COVER_END_*/
  184|       |
  185|       |    ///  Test if this state has only empty transitions from it, and not stop state.
  186|  6.14k|    /*_FORCE_COVER_START_*/bool IsEmpty(size_t state) const { return !HasSymTransitions(state) && !IsStop(state); }/*_FORCE_COVER_END_*/
  187|       |
  188|       |    /// Merge another NFA into this one.
  189|      9|    /*_FORCE_COVER_START_*/void Merge(const tNFA<NUM_SYMBOLS,STOP_TYPE> & nfa2) {
  190|      9|      const size_t offset = GetSize();                  // How far should we offset new NFA states?
  191|      9|      const size_t new_start = offset + nfa2.GetSize(); // Locate the new start node.
  192|      9|      Resize(offset + nfa2.GetSize() + 1);              // Make room for new NFA states + new start.
  193|      9|      AddFreeTransition(new_start, start);              // Free transition from new start to
  194|      9|      AddFreeTransition(new_start, nfa2.start+offset);  //    starts of both original NFAs.
  195|      9|      start = new_start;                                // Set the new start node.
  196|      9|
  197|      9|      // Loop through new states and add them in.
  198|     49|      for (size_t i = 0; i < nfa2.GetSize(); i++) {
  199|     40|        // Move transitions.
  200|     40|        for (const auto & t : nfa2.states[i].trans) {
  201|     12|          AddTransition(i+offset, t.first+offset, t.second.symbols);
  202|     12|        }
  203|     45|        for (auto to : nfa2.states[i].free_to) {
  204|     45|          AddFreeTransition(i+offset, to+offset);
  205|     45|        }
  206|     40|        SetStop(i+offset, nfa2.is_stop[i]);   // Maintain the stop value for this state.
  207|     40|      }
  208|      9|    }/*_FORCE_COVER_END_*/
  209|       |
  210|       |    /// Print information about this NFA (for debugging)
  211|       |    /*_FORCE_COVER_START_*/void Print() const {
  212|       |      std::cout << states.size() << " States:" << std::endl;
  213|       |      for (size_t i = 0; i < states.size(); i++) {
  214|       |        std::cout << " state " << i << " - ";
  215|       |        for (const auto & t : states[i].trans) {
  216|       |          std::cout << "(";
  217|       |          for (size_t s = 0; s < NUM_SYMBOLS; s++) if (t.second.symbols[s]) std::cout << ((char) s);
  218|       |          std::cout << "):" << t.first << " ";
  219|       |        }
  220|       |        if (states[i].free_to.size()) {
  221|       |          std::cout << "free to:";
  222|       |          for (auto f : states[i].free_to) std::cout << " " << f;
  223|       |        }
  224|       |        if (IsStop(i)) std::cout << " STOP(" << (int) GetStop(i) << ")";
  225|       |        std::cout << std::endl;
  226|       |      }
  227|       |    }/*_FORCE_COVER_END_*/
  228|       |
  229|       |    /// Identify free moves in NFA (for debugging)
  230|       |    /*_FORCE_COVER_START_*/void PrintFreeMoves() {
  231|       |      for (int i = 0; i < states.size(); i++) {
  232|       |        std::cout << "Free from ( ";
  233|       |        for (auto x : states[i].free_from) std::cout << x << " ";
  234|       |        std::cout << ") to " << i << std::endl;
  235|       |        std::cout << "Free from " << i << " to ( ";
  236|       |        for (auto x : states[i].free_to) std::cout << x << " ";
  237|       |        std::cout << ")" << std::endl;
  238|       |      }
  239|       |    }/*_FORCE_COVER_END_*/
  240|       |  };
  241|       |
  242|       |  /// Information about the current full state (i.e., set of legal states) of an NFA.
  243|       |  template <size_t NUM_SYMBOLS=128, typename STOP_TYPE=uint8_t>
  244|       |  class tNFA_State {
  245|       |  private:
  246|       |    const tNFA<NUM_SYMBOLS,STOP_TYPE> & nfa;  ///< Which NFA is this state set associated with?
  247|       |    std::set<size_t> state_set;               ///< Which states are currently legal?
  248|       |  public:
  249|      3|    /*_FORCE_COVER_START_*/tNFA_State(const tNFA<NUM_SYMBOLS,STOP_TYPE> & _nfa) : nfa(_nfa), state_set() {
  250|      3|      state_set = nfa.GetStart();
  251|      3|    }/*_FORCE_COVER_END_*/
  252|      3|    /*_FORCE_COVER_START_*/~tNFA_State() { ; }/*_FORCE_COVER_END_*/
  253|       |
  254|       |    /// Get the NFA associated with this state.
  255|       |    /*_FORCE_COVER_START_*/const tNFA<NUM_SYMBOLS,STOP_TYPE> & GetNFA() const { return nfa; }/*_FORCE_COVER_END_*/
  256|       |
  257|       |    /// Get a set of states that are currently active.
  258|       |    /*_FORCE_COVER_START_*/const std::set<size_t> & GetStateSet() const { return state_set; }/*_FORCE_COVER_END_*/
  259|       |
  260|       |    /// Are there currently any legal NFA states?
  261|      7|    /*_FORCE_COVER_START_*/bool IsActive() const { return state_set.size(); }/*_FORCE_COVER_END_*/
  262|       |
  263|       |    /// Can we legally stop in any of the current states?
  264|       |    /*_FORCE_COVER_START_*/bool IsStop() const {
  265|       |      for (auto s : state_set) if (nfa.IsStop(s)) return true;
  266|       |      return false;
  267|       |    }/*_FORCE_COVER_END_*/
  268|       |
  269|       |    /// Is a particular NFA state currently included?
  270|       |    /*_FORCE_COVER_START_*/bool HasState(size_t id) { return state_set.count(id); }/*_FORCE_COVER_END_*/
  271|       |
  272|       |    /// How many states are currently included?
  273|      5|    /*_FORCE_COVER_START_*/size_t GetSize() { return state_set.size(); }/*_FORCE_COVER_END_*/
  274|       |
  275|       |    /// Set the current states.
  276|       |    /*_FORCE_COVER_START_*/void SetStateSet(const std::set<size_t> & in) { state_set = in; }/*_FORCE_COVER_END_*/
  277|       |
  278|       |    /// Change current states to start + free transitions from start.
  279|      7|    /*_FORCE_COVER_START_*/void Reset() { state_set = nfa.GetStart(); }/*_FORCE_COVER_END_*/
  280|       |
  281|       |    /// Update states given a new input symbol.
  282|     63|    /*_FORCE_COVER_START_*/void Next(size_t sym) {
  283|     63|      state_set = nfa.GetNext(sym, state_set);
  284|     63|    }/*_FORCE_COVER_END_*/
  285|       |
  286|       |    /// Update states given a new series of input symbols (as a string)
  287|      8|    /*_FORCE_COVER_START_*/void Next(const std::string & sym_set) {
  288|     61|      for (char x : sym_set) Next((size_t) x);
  289|      8|    }/*_FORCE_COVER_END_*/
  290|       |
  291|       |    /// Print out current information about this NFA State (for debugging)
  292|       |    /*_FORCE_COVER_START_*/void Print() {
  293|       |      std::cout << "cur states:";
  294|       |      for (auto s : state_set) {
  295|       |        std::cout << " " << s;
  296|       |      }
  297|       |      std::cout << std::endl;
  298|       |    }/*_FORCE_COVER_END_*/
  299|       |  };
  300|       |
  301|       |  /// NFA is the most standard tNFA setup.
  302|       |  using NFA = tNFA<128, uint8_t>;
  303|       |
  304|       |  /// NFA_State is the most standard tNFA_State setup.
  305|       |  using NFA_State = tNFA_State<128, uint8_t>;
  306|       |}
  307|       |
  308|       |#endif
  309|       |

/home/emily/repos/Empirical_Tests/source/tools/Random.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2015-2018
    5|       | *
    6|       | *  @file  Random.h
    7|       | *  @brief A versatile and non-patterned pseudo-random-number generator.
    8|       | *  @note Status: RELEASE
    9|       | */
   10|       |
   11|       |#ifndef EMP_RANDOM_H
   12|       |#define EMP_RANDOM_H
   13|       |
   14|       |#include <ctime>
   15|       |#include <climits>
   16|       |#include <cmath>
   17|       |#include <iterator>
   18|       |
   19|       |#include "../base/assert.h"
   20|       |#include "Range.h"
   21|       |
   22|       |namespace emp {
   23|       |
   24|       |  ///  A versatile and non-patterned pseudo-random-number generator (Mersenne Twister).
   25|       |  class Random {
   26|       |  protected:
   27|       |    int seed;           ///< Current random number seed.
   28|       |    int original_seed;  ///< Orignal random number seed when object was first created.
   29|       |    int inext;          ///< First position in use in internal state.
   30|       |    int inextp;         ///< Second position in use in internal state.
   31|       |    int ma[56];         ///< Internal state of RNG
   32|       |
   33|       |    // Members & functions for stat functions
   34|       |    double expRV; // Exponential Random Variable for the randNormal function
   35|       |
   36|       |    // Constants ////////////////////////////////////////////////////////////////
   37|       |    // Statistical Approximation
   38|       |    static const int32_t _BINOMIAL_TO_NORMAL = 50;     // if < n*p*(1-p)
   39|       |    static const int32_t _BINOMIAL_TO_POISSON = 1000;  // if < n && !Normal approx Engine
   40|       |
   41|       |    // Engine
   42|       |    static const int32_t _RAND_MBIG = 1000000000;
   43|       |    static const int32_t _RAND_MSEED = 161803398;
   44|       |
   45|       |    // Internal functions
   46|       |
   47|       |    // Setup, called on initialization and seed reset.
   48|       |    void init()
   49|      2|    {
   50|      2|      // Clear variables
   51|    114|      for (int i = 0; i < 56; ++i) ma[i] = 0;
   52|      2|
   53|      2|      int32_t mj = (_RAND_MSEED - seed) % _RAND_MBIG;
   54|      2|      ma[55] = mj;
   55|      2|      int32_t mk = 1;
   56|      2|
   57|    110|      for (int32_t i = 1; i < 55; ++i) {
   58|    108|        int32_t ii = (21 * i) % 55;
   59|    108|        ma[ii] = mk;
   60|    108|        mk = mj - mk;
   61|    108|        if (mk < 0) mk += _RAND_MBIG;
   62|    108|        mj = ma[ii];
   63|    108|      }
   64|      2|
   65|     10|      for (int32_t k = 0; k < 4; ++k) {
   66|    440|        for (int32_t j = 1; j < 55; ++j) {
   67|    432|          ma[j] -= ma[1 + (j + 30) % 55];
   68|    432|          if (ma[j] < 0) ma[j] += _RAND_MBIG;
   69|    432|        }
   70|      8|      }
   71|      2|
   72|      2|      inext = 0;
   73|      2|      inextp = 31;
   74|      2|
   75|      2|      // Setup variables used by Statistical Distribution functions
   76|      2|      expRV = -log(Random::Get() / (double) _RAND_MBIG);
   77|      2|    }
   78|       |
   79|       |    // Basic Random number
   80|       |    // Returns a random number [0,_RAND_MBIG)
   81|   300k|    int32_t Get() {
   82|   300k|      if (++inext == 56) inext = 0;
   83|   300k|      if (++inextp == 56) inextp = 0;
   84|   300k|      int mj = ma[inext] - ma[inextp];
   85|   300k|      if (mj < 0) mj += _RAND_MBIG;
   86|   300k|      ma[inext] = mj;
   87|   300k|
   88|   300k|      return mj;
   89|   300k|    }
   90|       |
   91|       |  public:
   92|       |    /**
   93|       |     * Set up the random generator object.
   94|       |     * @param _seed The seed of the random number generator.  A negative seed means that the
   95|       |     * random number generator gets its seed from a combination of the actual system time and
   96|       |     * the memory position of the random number generator.
   97|       |     **/
   98|      2|    Random(const int _seed = -1) : seed(0), original_seed(0), inext(0), inextp(0), expRV(0) {
   99|    114|      for (int i = 0; i < 56; ++i) ma[i] = 0;
  100|      2|      ResetSeed(_seed);  // Calls init()
  101|      2|    }
  102|       |
  103|      2|    ~Random() { ; }
  104|       |
  105|       |
  106|       |    /**
  107|       |     * @return The seed that was actually used to start the random sequence.
  108|       |     **/
  109|      0|    inline int GetSeed() const { return seed; }
  110|       |
  111|       |    /**
  112|       |     * @return The seed that was originally provided by the user.
  113|       |     **/
  114|      0|    inline int GetOriginalSeed() const { return original_seed; }
  115|       |
  116|       |    /**
  117|       |     * Starts a new sequence of pseudo random numbers.
  118|       |     *
  119|       |     * @param new_seed The seed for the new sequence.
  120|       |     * A negative seed means that the random number generator gets its
  121|       |     * seed from the actual system time and the process ID.
  122|       |     **/
  123|      2|    inline void ResetSeed(const int _seed) {
  124|      2|      original_seed = _seed;
  125|      2|
  126|      2|      if (_seed <= 0) {
  127|      2|        int seed_time = (int) time(NULL);
  128|      2|        int seed_mem = (int) ((uint64_t) this);
  129|      2|        seed = seed_time ^ seed_mem;
  130|      2|      } else {
  131|      0|        seed = _seed;
  132|      0|      }
  133|      2|
  134|      2|      if (seed < 0) seed *= -1;
  135|      2|      seed %= _RAND_MSEED;
  136|      2|
  137|      2|      init();
  138|      2|    }
  139|       |
  140|       |
  141|       |    // Random Number Generation /////////////////////////////////////////////////
  142|       |
  143|       |    /**
  144|       |     * Generate a double between 0.0 and 1.0
  145|       |     *
  146|       |     * @return The pseudo random number.
  147|       |     **/
  148|   200k|    inline double GetDouble() { return Get() / (double) _RAND_MBIG; }
  149|       |
  150|       |    /**
  151|       |     * Generate a double between 0 and a given number.
  152|       |     *
  153|       |     * @return The pseudo random number.
  154|       |     * @param max The upper bound for the random numbers (will never be returned).
  155|       |     **/
  156|      0|    inline double GetDouble(const double max) {
  157|      0|      // emp_assert(max <= (double) _RAND_MBIG, max, (double) _RAND_MBIG);  // Precision will be too low past this point...
  158|      0|      return GetDouble() * max;
  159|      0|    }
  160|       |
  161|       |    /**
  162|       |     * Generate a double out of a given interval.
  163|       |     *
  164|       |     * @return The pseudo random number.
  165|       |     * @param min The lower bound for the random numbers.
  166|       |     * @param max The upper bound for the random numbers (will never be returned).
  167|       |     **/
  168|   100k|    inline double GetDouble(const double min, const double max) {
  169|   100k|      emp_assert((max-min) <= (double) _RAND_MBIG, min, max);  // Precision will be too low past this point...
  170|   100k|      return GetDouble() * (max - min) + min;
  171|   100k|    }
  172|       |
  173|       |    /**
  174|       |     * Generate a double out of a given interval.
  175|       |     *
  176|       |     * @return The pseudo random number.
  177|       |     * @param range The upper and lower bounds for the random numbers [lower, upper)
  178|       |     **/
  179|      0|    inline double GetDouble(const Range<double> range) {
  180|      0|      return GetDouble(range.GetLower(), range.GetUpper());
  181|      0|     }
  182|       |
  183|       |    /**
  184|       |     * Generate an uint32_t.
  185|       |     *
  186|       |     * @return The pseudo random number.
  187|       |     * @param max The upper bound for the random numbers (will never be returned).
  188|       |     **/
  189|       |    /*_FORCE_COVER_START_*/template <typename T>
  190|   100k|    inline uint32_t GetUInt(const T max) {
  191|   100k|      emp_assert(max <= (T) _RAND_MBIG, max);  // Precision will be too low past this point...
  192|   100k|      return static_cast<uint32_t>(GetDouble() * static_cast<double>(max));
  193|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6Random7GetUIntIjEEjT_:
  |  190|   100k|    inline uint32_t GetUInt(const T max) {
  |  191|   100k|      emp_assert(max <= (T) _RAND_MBIG, max);  // Precision will be too low past this point...
  |  192|   100k|      return static_cast<uint32_t>(GetDouble() * static_cast<double>(max));
  |  193|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp6Random7GetUIntImEEjT_
  ------------------
  194|       |
  195|       |    /**
  196|       |     * Generate an uint64_t.
  197|       |     *
  198|       |     * @return The pseudo random number.
  199|       |     * @param max The upper bound for the random numbers (will never be returned).
  200|       |     * @todo this function needs to be tested and refined.
  201|       |     **/
  202|       |    /*_FORCE_COVER_START_*/template <typename T>
  203|       |    inline uint64_t GetUInt64(const T max) {
  204|       |      if (max <= (T) _RAND_MBIG) return (uint64_t) GetUInt(max);  // Don't need extra precision.
  205|       |      const double max2 = ((double) max) / (double) _RAND_MBIG;
  206|       |      emp_assert(max2 <= (T) _RAND_MBIG, max);  // Precision will be too low past this point...
  207|       |
  208|       |      return static_cast<uint64_t>(GetDouble() * static_cast<double>(max))
  209|       |           + static_cast<uint64_t>(GetDouble() * static_cast<double>(max2) * _RAND_MBIG);
  210|       |    }/*_FORCE_COVER_END_*/
  211|       |
  212|       |
  213|       |    /**
  214|       |     * Generate an uint32_t out of an interval.
  215|       |     *
  216|       |     * @return The pseudo random number.
  217|       |     * @param min The lower bound for the random numbers.
  218|       |     * @param max The upper bound for the random numbers (will never be returned).
  219|       |     **/
  220|       |    /*_FORCE_COVER_START_*/template <typename T1, typename T2>
  221|   100k|    inline uint32_t GetUInt(const T1 min, const T2 max) {
  222|   100k|      return GetUInt<uint32_t>((uint32_t) max - (uint32_t) min) + (uint32_t) min;
  223|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6Random7GetUIntIddEEjT_T0_:
  |  221|   100k|    inline uint32_t GetUInt(const T1 min, const T2 max) {
  |  222|   100k|      return GetUInt<uint32_t>((uint32_t) max - (uint32_t) min) + (uint32_t) min;
  |  223|   100k|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp6Random7GetUIntImmEEjT_T0_:
  |  221|     21|    inline uint32_t GetUInt(const T1 min, const T2 max) {
  |  222|     21|      return GetUInt<uint32_t>((uint32_t) max - (uint32_t) min) + (uint32_t) min;
  |  223|     21|    }/*_FORCE_COVER_END_*/
  ------------------
  224|       |
  225|       |    /**
  226|       |     * Generate a uint32_t out of a given interval.
  227|       |     *
  228|       |     * @return The pseudo random number.
  229|       |     * @param range The upper and lower bounds for the random numbers [lower, upper)
  230|       |     **/
  231|       |    /*_FORCE_COVER_START_*/template <typename T>
  232|       |    inline uint32_t GetUInt(const Range<T> range) {
  233|       |      return GetUInt(range.GetLower(), range.GetUpper());
  234|       |    }/*_FORCE_COVER_END_*/
  235|       |
  236|       |    /**
  237|       |     * Generate an int out of an interval.
  238|       |     *
  239|       |     * @return The pseudo random number.
  240|       |     * @param min The lower bound for the random numbers.
  241|       |     * @param max The upper bound for the random numbers (will never be returned).
  242|       |     **/
  243|      0|    inline int GetInt(const int max) { return static_cast<int>(GetUInt((uint32_t) max)); }
  244|      0|    inline int GetInt(const int min, const int max) { return GetInt(max - min) + min; }
  245|      0|    inline int GetInt(const Range<int> range) { return GetInt(range.GetLower(), range.GetUpper()); }
  246|       |
  247|       |
  248|       |    // Random Event Generation //////////////////////////////////////////////////
  249|       |
  250|       |    /// Tests a random value [0,1) against a given probability p, and returns true of false.
  251|       |    /// @param p The probability of the result being "true".
  252|   100k|    inline bool P(const double p) {
  253|   100k|      emp_assert(p >= 0.0 && p <= 1.0, p);
  254|   100k|      return (Get() < (p * _RAND_MBIG));
  255|   100k|    }
  256|       |
  257|       |
  258|       |    // Statistical functions ////////////////////////////////////////////////////
  259|       |
  260|       |    // Distributions //
  261|       |
  262|       |    /**
  263|       |     * Generate a random variable drawn from a unit normal distribution.
  264|       |     **/
  265|      0|    inline double GetRandNormal() {
  266|      0|      // Draw from a Unit Normal Dist
  267|      0|      // Using Rejection Method and saving of initial exponential random variable
  268|      0|      double expRV2;
  269|      0|      while (1) {
  270|      0|        expRV2 = -log(GetDouble());
  271|      0|        expRV -= (expRV2-1)*(expRV2-1)/2;
  272|      0|        if (expRV > 0) break;
  273|      0|        expRV = -log(GetDouble());
  274|      0|      }
  275|      0|      if (P(.5)) return expRV2;
  276|      0|      return -expRV2;
  277|      0|    }
  278|       |
  279|       |    /**
  280|       |     * Generate a random variable drawn from a distribution with given
  281|       |     * mean and standard deviation.
  282|       |     **/
  283|      0|    inline double GetRandNormal(const double mean, const double std) { return mean + GetRandNormal() * std; }
  284|       |
  285|       |    /**
  286|       |     * Generate a random variable drawn from a Poisson distribution.
  287|       |     **/
  288|      0|    inline uint32_t GetRandPoisson(const double n, double p) {
  289|      0|      emp_assert(p >= 0.0 && p <= 1.0, p);
  290|      0|      // Optimizes for speed and calculability using symetry of the distribution
  291|      0|      if (p > .5) return (uint32_t)n - GetRandPoisson(n * (1 - p));
  292|      0|      else return GetRandPoisson(n * p);
  293|      0|    }
  294|       |
  295|       |    /**
  296|       |     * Generate a random variable drawn from a Poisson distribution.
  297|       |     *
  298|       |     * @param mean The mean of the distribution.
  299|       |     **/
  300|      0|    inline uint32_t GetRandPoisson(const double mean) {
  301|      0|      // Draw from a Poisson Dist with mean; if cannot calculate, return UINT_MAX.
  302|      0|      // Uses Rejection Method
  303|      0|      const double a = exp(-mean);
  304|      0|      if (a <= 0) return UINT_MAX; // cannot calculate, so return UINT_MAX
  305|      0|      uint32_t k = 0;
  306|      0|      double u = GetDouble();
  307|      0|      while (u >= a) {
  308|      0|        u *= GetDouble();
  309|      0|        ++k;
  310|      0|      }
  311|      0|      return k;
  312|      0|    }
  313|       |
  314|       |    /**
  315|       |     * Generate a random variable drawn from a Binomial distribution.
  316|       |     *
  317|       |     * This function is exact, but slow.
  318|       |     * @see Random::GetRandBinomial
  319|       |     **/
  320|      0|    inline uint32_t GetFullRandBinomial(const double n, const double p) { // Exact
  321|      0|      emp_assert(p >= 0.0 && p <= 1.0, p);
  322|      0|      // Actually try n Bernoulli events with probability p
  323|      0|      uint32_t k = 0;
  324|      0|      for (uint32_t i = 0; i < n; ++i) if (P(p)) k++;
  325|      0|      return k;
  326|      0|    }
  327|       |
  328|       |    /**
  329|       |     * Generate a random variable drawn from a Binomial distribution.
  330|       |     *
  331|       |     * This function is faster than @ref Random::GetFullRandBinomial(), but
  332|       |     * uses some approximations.
  333|       |     *
  334|       |     * @see Random::GetFullRandBinomial
  335|       |     **/
  336|      0|    inline uint32_t GetRandBinomial(const double n, const double p) { // Approx
  337|      0|      emp_assert(p >= 0.0 && p <= 1.0, p);
  338|      0|      emp_assert(n >= 0.0, n);
  339|      0|      // Approximate Binomial if appropriate
  340|      0|      // if np(1-p) is large, use a Normal approx
  341|      0|      if (n * p * (1 - p) >= _BINOMIAL_TO_NORMAL) {
  342|      0|        return static_cast<uint32_t>(GetRandNormal(n * p, n * p * (1 - p)) + 0.5);
  343|      0|      }
  344|      0|      // elseif n is large, use a Poisson approx
  345|      0|      if (n >= _BINOMIAL_TO_POISSON) {
  346|      0|        uint32_t k = GetRandPoisson(n, p);
  347|      0|        if (k < UINT_MAX) return k; // if approx worked
  348|      0|      }
  349|      0|      // otherwise, actually generate the randBinomial
  350|      0|      return GetFullRandBinomial(n, p);
  351|      0|    }
  352|       |  };
  353|       |
  354|       |
  355|       |  /// This is an adaptor to make Random behave like a proper STL random number generator.
  356|       |  struct RandomStdAdaptor {
  357|       |    typedef int argument_type;
  358|       |    typedef int result_type;
  359|       |
  360|      0|    RandomStdAdaptor(Random& rng) : _rng(rng) { }
  361|      0|    int operator()(int n) { return _rng.GetInt(n); }
  362|       |
  363|       |    Random& _rng;
  364|       |  };
  365|       |
  366|       |
  367|       |  /// Draw a sample (with replacement) from an input range, copying to the output range.
  368|       |  /*_FORCE_COVER_START_*/template <typename ForwardIterator, typename OutputIterator, typename RNG>
  369|       |  void sample_with_replacement(ForwardIterator first, ForwardIterator last, OutputIterator ofirst, OutputIterator olast, RNG rng) {
  370|       |    std::size_t range = std::distance(first, last);
  371|       |    while(ofirst != olast) {
  372|       |      *ofirst = *(first+rng(range));
  373|       |      ++ofirst;
  374|       |    }
  375|       |  }/*_FORCE_COVER_END_*/
  376|       |
  377|       |
  378|       |} // END emp namespace
  379|       |
  380|       |#endif
  381|       |

/home/emily/repos/Empirical_Tests/source/tools/Range.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  Range.h
    7|       | *  @brief A simple way to track value ranges
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_RANGE_H
   12|       |#define EMP_RANGE_H
   13|       |
   14|       |#include <limits>
   15|       |
   16|       |#include "../base/assert.h"
   17|       |#include "../base/vector.h"
   18|       |
   19|       |namespace emp {
   20|       |
   21|       |  /// A range of values from a lower limit to and upper limit, of any provided type.
   22|       |  template <typename T>
   23|       |  class Range {
   24|       |  private:
   25|       |    T lower;  ///< Beginning of range, inclusive.
   26|       |    T upper;  ///< End of range, inclusive.
   27|       |
   28|       |  public:
   29|       |    /*_FORCE_COVER_START_*/Range() : lower(std::numeric_limits<T>::min()), upper(std::numeric_limits<T>::max()) { ; }/*_FORCE_COVER_END_*/
   30|       |    /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/Range(T _l, T _u) : lower(_l), upper(_u) { emp_assert(_l < _u); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   31|       |
   32|      0|    /*_FORCE_COVER_START_*/T GetLower() const { return lower; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp5RangeIdE8GetLowerEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp5RangeIiE8GetLowerEv
  ------------------
   33|      0|    /*_FORCE_COVER_START_*/T GetUpper() const { return upper; }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZNK3emp5RangeIdE8GetUpperEv
  ------------------
  | Unexecuted instantiation: _ZNK3emp5RangeIiE8GetUpperEv
  ------------------
   34|       |
   35|       |    /*_FORCE_COVER_START_*/size_t CalcBin(T value, size_t num_bins) const {
   36|       |      return (size_t) (((double) (value - lower)) / ((double) (upper - lower)) * (double) num_bins);
   37|       |    }/*_FORCE_COVER_END_*/
   38|       |
   39|       |    /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/Range & operator=(const Range&) = default/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
   40|       |    /*_FORCE_COVER_START_*/bool operator==(const Range& _in) const { return lower==_in.lower && upper==_in.upper; }/*_FORCE_COVER_END_*/
   41|       |    /*_FORCE_COVER_START_*/bool operator!=(const Range& _in) const { return lower!=_in.lower || upper!=_in.upper; }/*_FORCE_COVER_END_*/
   42|       |
   43|       |    /*_FORCE_COVER_START_*/void SetLower(T l) { lower = l; }/*_FORCE_COVER_END_*/
   44|       |    /*_FORCE_COVER_START_*/void SetUpper(T u) { upper = u; }/*_FORCE_COVER_END_*/
   45|       |    /*_FORCE_COVER_START_*/void Set(T _l, T _u) { emp_assert(_l < _u); lower = _l; upper = _u; }/*_FORCE_COVER_END_*/
   46|       |
   47|       |    /*_FORCE_COVER_START_*/void SetMaxLower() { lower = std::numeric_limits<T>::min(); }/*_FORCE_COVER_END_*/
   48|       |    /*_FORCE_COVER_START_*/void SetMaxUpper() { upper = std::numeric_limits<T>::max(); }/*_FORCE_COVER_END_*/
   49|       |
   50|       |    /// Determine if a provided value is in the range.
   51|       |    /*_FORCE_COVER_START_*/bool Valid(T value) const { return value >= lower && value <= upper; }/*_FORCE_COVER_END_*/
   52|       |
   53|       |    /// Force a value into range
   54|       |    /*_FORCE_COVER_START_*/T Limit(T _in) const { return (_in < lower) ? lower : ((_in > upper) ? upper : _in); }/*_FORCE_COVER_END_*/
   55|       |
   56|       |    /// Produce a vector that spreads values evenly across the range.
   57|       |    /*_FORCE_COVER_START_*/emp::vector<T> Spread(size_t s) const {
   58|       |      emp_assert(s >= 1);
   59|       |      emp::vector<T> out(s);
   60|       |      out[0] = lower;
   61|       |      if (s > 1) {
   62|       |        T range = upper - lower;
   63|       |        for (size_t i = 1; i < s; i++) {
   64|       |          out[i] = lower + (T) ((((double) i) / (double)(s-1)) * range);
   65|       |        }
   66|       |      }
   67|       |      return out;
   68|       |    }/*_FORCE_COVER_END_*/
   69|       |  };
   70|       |
   71|       |  /// Build a new range with auto-detected type.
   72|       |  /*_FORCE_COVER_START_*/template <typename T> Range<T> MakeRange(T _l, T _u) { return Range<T>(_l,_u); }/*_FORCE_COVER_END_*/
   73|       |
   74|       |  /// Build a new range of type int.
   75|      0|  inline Range<int> IntRange(int _l, int _u) { return Range<int>(_l,_u); }
   76|       |
   77|       |  /// Build a new range of type double.
   78|      0|  inline Range<double> DRange(double _l, double _u) { return Range<double>(_l,_u); }
   79|       |}
   80|       |
   81|       |#endif
   82|       |

/home/emily/repos/Empirical_Tests/source/tools/RegEx.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  RegEx.h
    7|       | *  @brief Basic regular expression handler.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  A fully (well, mostly) functional regular expression processor.
   11|       | *
   12|       | *  Special chars:
   13|       | *   '|'          - or
   14|       | *   '*'          - zero or more of previous
   15|       | *   '+'          - one or more of previous
   16|       | *   '?'          - previous is optional
   17|       | *   '.'          - Match any character except \n
   18|       | *
   19|       | *  Pluse the following group contents (and change may translation rules)
   20|       | *   '(' and ')'  - group contents
   21|       | *   '"'          - Ignore special characters in contents (quotes still need to be escaped)
   22|       | *   '[' and ']'  - character set -- choose ONE character
   23|       | *                  ^ as first char negates contents ; - indicates range UNLESS first or last.
   24|       | *
   25|       | *  Additional overloads for functions in lexer_utils.h:
   26|       | *
   27|       | *    static NFA to_NFA(const RegEx & regex, int stop_id=1);
   28|       | *    static DFA to_DFA(const RegEx & regex);
   29|       | *
   30|       | *
   31|       | *  @todo Need to implement  ^ and $ (beginning and end of line)
   32|       | *  @todo Need to implement {n}, {n,} and {n,m} (exactly n, at least n, and n-m copies, respecitvely)
   33|       |*/
   34|       |
   35|       |#ifndef EMP_REGEX_H
   36|       |#define EMP_REGEX_H
   37|       |
   38|       |
   39|       |#include <ostream>
   40|       |#include <sstream>
   41|       |#include <string>
   42|       |
   43|       |#include "../base/vector.h"
   44|       |#include "../base/Ptr.h"
   45|       |
   46|       |#include "BitSet.h"
   47|       |#include "lexer_utils.h"
   48|       |#include "NFA.h"
   49|       |#include "string_utils.h"
   50|       |
   51|       |
   52|       |namespace emp {
   53|       |
   54|       |  /// A basic regular expression handler.
   55|       |  class RegEx {
   56|       |  private:
   57|       |    constexpr static size_t NUM_SYMBOLS = 128; ///< Maximum number of symbol the RegEx can handle.
   58|       |    using opts_t = BitSet<NUM_SYMBOLS>;
   59|       |    std::string regex;                         ///< Original string to define this RegEx.
   60|       |    emp::vector<std::string> notes;            ///< Any warnings or errors would be provided here.
   61|       |    bool valid;                                ///< Set to false if regex cannot be processed.
   62|       |    size_t pos;                                ///< Position being read in regex.
   63|       |
   64|       |    mutable DFA dfa;                           ///< DFA that this RegEx translates to.
   65|       |    mutable bool dfa_ready;                    ///< Is the dfa ready? (or does it need to be generated?)
   66|       |
   67|       |    /*_FORCE_COVER_START_*/template <typename... T>
   68|      0|    void Error(T &&... args) {
   69|      0|      notes.push_back(emp::to_string(std::forward<T>(args)...));
   70|      0|      valid = false;
   71|      0|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA10_KcRcRA13_S2_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA10_KcRcRA14_S2_RmRA9_S2_S5_RA2_S2_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA25_KcRccS5_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA38_KcRcRA3_S2_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA43_KcRcRA3_S2_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA34_KcRcRA3_S2_EEEvDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp5RegEx5ErrorIJRA33_KcRcRA15_S2_RmRA2_S2_EEEvDpOT_
  ------------------
   72|       |
   73|       |    // Pre-declarations
   74|       |    struct re_block;
   75|       |    struct re_charset;
   76|       |    struct re_parent;
   77|       |    struct re_string;
   78|       |
   79|       |    /// Internal base representation of a portion of a regex
   80|       |    struct re_base {                     // Also used for empty regex
   81|    140|      virtual ~re_base() { ; }
   82|      0|      virtual void Print(std::ostream & os) const { os << "[]"; }
   83|    205|      virtual Ptr<re_block> AsBlock() { return nullptr; }
   84|     80|      virtual Ptr<re_charset> AsCharSet() { return nullptr; }
   85|      0|      virtual Ptr<re_parent> AsParent() { return nullptr; }
   86|     37|      virtual Ptr<re_string> AsString() { return nullptr; }
   87|      0|      virtual size_t GetSize() const { return 0; }
   88|     78|      virtual bool Simplify() { return false; }
   89|      0|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const { nfa.AddFreeTransition(start, stop); }
   90|       |    };
   91|       |
   92|       |    /// Representation of strings stored in a RegEx.
   93|       |    struct re_string : public re_base {  // Series of specific chars
   94|       |      std::string str;
   95|      0|      re_string() : str() { ; }
   96|     29|      re_string(char c) : str() { str.push_back(c); }
   97|      0|      re_string(const std::string & s) : str(s) { ; }
   98|      0|      void Print(std::ostream & os) const override { os << "STR[" << to_escaped_string(str) << "]"; }
   99|     47|      Ptr<re_string> AsString() override { return ToPtr(this); }
  100|      0|      size_t GetSize() const override { return str.size(); }
  101|     15|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  102|     15|        size_t prev_id = start;
  103|     23|        for (char x : str) {
  104|     23|          size_t next_id = nfa.AddNewState();
  105|     23|          nfa.AddTransition(prev_id, next_id, (size_t) x);
  106|     23|          prev_id = next_id;
  107|     23|        }
  108|     15|        nfa.AddFreeTransition(prev_id, stop);
  109|     15|      }
  110|       |    };
  111|       |
  112|       |    /// Representation of a character set e.g., [abc]
  113|       |    struct re_charset : public re_base { // Any char from set.
  114|       |      opts_t char_set;
  115|     34|      re_charset() : char_set() { ; }
  116|      3|      re_charset(char x, bool neg=false) : char_set() {
  117|      3|        char_set[(size_t)x]=true;
  118|      3|        if (neg) char_set.NOT_SELF();
  119|      3|      }
  120|      0|      re_charset(const std::string & s, bool neg=false) : char_set() {
  121|      0|        for (char x : s) char_set[(size_t)x]=true;
  122|      0|        if (neg) char_set.NOT_SELF();
  123|      0|      }
  124|      0|      void Print(std::ostream & os) const override {
  125|      0|        auto chars = char_set.GetOnes();
  126|      0|        bool use_not = false;
  127|      0|        if (chars.size() > 64) { chars = (~char_set).GetOnes(); use_not = true; }
  128|      0|        os << "SET[";
  129|      0|        if (use_not) os << "NOT ";
  130|      0|        for (auto c : chars) os << to_escaped_string((char) c);
  131|      0|        os << "]";
  132|      0|      }
  133|     12|      Ptr<re_charset> AsCharSet() override { return ToPtr(this); }
  134|     10|      size_t GetSize() const override { return char_set.CountOnes(); }
  135|      2|      char First() const { return (char) char_set.FindBit(); }
  136|     22|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  137|  2.83k|        for (size_t i = 0; i < NUM_SYMBOLS; i++) if (char_set[i]) nfa.AddTransition(start, stop, i);
  138|     22|      }
  139|       |    };
  140|       |
  141|       |    /// Intermediate base class for RegEx components that have children (such as "and" and "or")
  142|       |    struct re_parent : public re_base {
  143|       |    protected:
  144|       |      emp::vector<Ptr<re_base>> nodes;
  145|       |    public:
  146|     74|      re_parent() : nodes() { }
  147|     94|      ~re_parent() { for (auto x : nodes) x.Delete(); }
  148|      0|      void Clear() { for (auto x : nodes) x.Delete(); nodes.resize(0); }
  149|    146|      virtual void push(Ptr<re_base> x) { emp_assert(x != nullptr); nodes.push_back(x); }
  150|     36|      Ptr<re_base> pop() { auto out = nodes.back(); nodes.pop_back(); return out; }
  151|     10|      size_t GetSize() const override { return nodes.size(); }
  152|     12|      Ptr<re_parent> AsParent() override { return ToPtr(this); }
  153|     91|      bool Simplify() override {
  154|     91|        bool m=false;
  155|    135|        for (auto & x : nodes) {
  156|    135|          // Recursively simplify children.
  157|    135|          m |= x->Simplify();
  158|    135|          // A block with one child can be replaced by child.
  159|    135|          if (x->AsBlock() && x->GetSize() == 1) {
  160|      6|            auto child = x->AsParent()->nodes[0];
  161|      6|            x->AsParent()->nodes.resize(0);
  162|      6|            x.Delete();
  163|      6|            x = child;
  164|      6|            m = true;
  165|      6|          }
  166|    135|        }
  167|     91|        return m;
  168|     91|      }
  169|       |    };
  170|       |
  171|       |    /// Representation of a series of components...
  172|       |    struct re_block : public re_parent {   // Series of re's
  173|      0|      void Print(std::ostream & os) const override {
  174|      0|        os << "BLOCK["; for (auto x : nodes) x->Print(os); os << "]";
  175|      0|      }
  176|     14|      Ptr<re_block> AsBlock() override { return ToPtr(this); }
  177|     44|      bool Simplify() override {
  178|     44|        bool modify = false;
  179|     44|        // Loop through block elements, simplifying when possible.
  180|    134|        for (size_t i = 0; i < nodes.size(); i++) {
  181|     90|          // If node is a charset with one option, replace it with a string.
  182|     90|          if (nodes[i]->AsCharSet() && nodes[i]->GetSize() == 1) {
  183|      2|            auto new_node = NewPtr<re_string>(nodes[i]->AsCharSet()->First());
  184|      2|            nodes[i].Delete();
  185|      2|            nodes[i] = new_node;
  186|      2|            modify = true;
  187|      2|          }
  188|     90|          // If two neighboring nodes are strings, merge them.
  189|     90|          if (i > 0 && nodes[i]->AsString() && nodes[i-1]->AsString()) {
  190|      8|            nodes[i-1]->AsString()->str += nodes[i]->AsString()->str;
  191|      8|            nodes[i].Delete();
  192|      8|            nodes.erase(nodes.begin() + (int) i);
  193|      8|            i--;
  194|      8|            modify = true;
  195|      8|            continue;
  196|      8|          }
  197|     82|
  198|     82|          // If blocks are nested, merge them into a single block.
  199|     82|          if (nodes[i]->AsBlock()) {
  200|      2|            auto old_node = nodes[i]->AsBlock();    // Save the old node for merging.
  201|      2|            nodes.erase(nodes.begin() + (int) i);  // Remove block from nodes.
  202|      2|            nodes.insert(nodes.begin() + (int) i, old_node->nodes.begin(), old_node->nodes.end());
  203|      2|            old_node->nodes.resize(0);  // Don't recurse delete since nodes were moved!
  204|      2|            old_node.Delete();
  205|      2|            i--;
  206|      2|            modify = true;
  207|      2|            continue;
  208|      2|          }
  209|     82|        }
  210|     44|
  211|     44|        // Also run the default Simplify on nodes.
  212|     44|        modify |= re_parent::Simplify();
  213|     44|
  214|     44|        return modify;
  215|     44|      }
  216|     19|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  217|     19|        size_t prev_id = start;
  218|     35|        for (auto x : nodes) {
  219|     35|          size_t next_id = nfa.AddNewState();
  220|     35|          x->AddToNFA(nfa, prev_id, next_id);
  221|     35|          prev_id = next_id;
  222|     35|        }
  223|     19|        nfa.AddFreeTransition(prev_id, stop);
  224|     19|      }
  225|       |    };
  226|       |
  227|       |    /// Representation of two options in a regex, e.g., a|b
  228|       |    struct re_or : public re_parent {      // lhs -or- rhs
  229|      4|      re_or(Ptr<re_base> l, Ptr<re_base> r) { push(l); push(r); }
  230|      0|      void Print(std::ostream & os) const override {
  231|      0|        os << "|[";
  232|      0|        nodes[0]->Print(os);
  233|      0|        nodes[1]->Print(os);
  234|      0|        os << "]";
  235|      0|      }
  236|      3|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  237|      3|        nodes[0]->AddToNFA(nfa, start, stop);
  238|      3|        nodes[1]->AddToNFA(nfa, start, stop);
  239|      3|      }
  240|       |    };
  241|       |
  242|       |    /// Representations of zero-or-more instances of a component.  e.g., a*
  243|       |    struct re_star : public re_parent {    // zero-or-more
  244|     10|      re_star(Ptr<re_base> c) { push(c); }
  245|      0|      void Print(std::ostream & os) const override { os << "*["; nodes[0]->Print(os); os << "]"; }
  246|       |
  247|      7|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  248|      7|        const size_t target = nfa.AddNewState();
  249|      7|        nodes[0]->AddToNFA(nfa, start, target);
  250|      7|        nfa.AddFreeTransition(target, start);
  251|      7|        nfa.AddFreeTransition(start, stop);
  252|      7|      }
  253|       |    };
  254|       |
  255|       |    /// Representations of one-or-more instances of a component.  e.g., a+
  256|       |    struct re_plus : public re_parent {    // one-or-more
  257|     21|      re_plus(Ptr<re_base> c) { push(c); }
  258|      0|      void Print(std::ostream & os) const override { os << "+["; nodes[0]->Print(os); os << "]"; }
  259|     14|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  260|     14|        const size_t target = nfa.AddNewState();
  261|     14|        nodes[0]->AddToNFA(nfa, start, target);
  262|     14|        // From the target, can either go back to start and repeat, or straight to stop.
  263|     14|        nfa.AddFreeTransition(target, start);
  264|     14|        nfa.AddFreeTransition(target, stop);
  265|     14|      }
  266|       |    };
  267|       |
  268|       |    /// Representations of zero-or-one instances of a component.  e.g., a?
  269|       |    struct re_qm : public re_parent {      // zero-or-one
  270|      1|      re_qm(Ptr<re_base> c) { push(c); }
  271|      0|      void Print(std::ostream & os) const override { os << "?["; nodes[0]->Print(os); os << "]"; }
  272|      1|      virtual void AddToNFA(NFA & nfa, size_t start, size_t stop) const override {
  273|      1|        nodes[0]->AddToNFA(nfa, start, stop);
  274|      1|        nfa.AddFreeTransition(start, stop);
  275|      1|      }
  276|       |    };
  277|       |
  278|       |    re_block head;
  279|       |
  280|       |    /// Make sure that there is another element in the RegEx (e.g., after an '|') or else
  281|       |    /// trigger and error to report the problem.
  282|     40|    bool EnsureNext(char x) {
  283|     40|      if (pos >= regex.size()) Error("Expected ", x, " before end.");
  284|     40|      else if (regex[pos] != x) Error("Expected ", x, " at position ", pos,
  285|      0|                                      "; found ", regex[pos], ".");
  286|     40|      ++pos;               // We have what we were expecting!  Move on...
  287|     40|      return valid;
  288|     40|    }
  289|       |
  290|       |    /// Construct a character range.
  291|     34|    Ptr<re_charset> ConstructSet() {
  292|     34|      char c = regex[pos++];
  293|     34|      bool neg = false;
  294|     34|      if (c == '^') { neg = true; c = regex[pos++]; }
  295|     34|      auto out = NewPtr<re_charset>();
  296|     34|      char prev_c = -1;
  297|    124|      while (c != ']' && pos < regex.size()) {
  298|     90|        if (c == '-' && prev_c != -1) {
  299|     26|          c = regex[pos++];
  300|     26|          if (c < prev_c) { Error("Invalid character range ", prev_c, '-', c); continue; }
  301|    478|          for (char x = prev_c; x <= c; x++) {
  302|    452|            out->char_set[(size_t)x] = true;
  303|    452|          }
  304|     26|          prev_c = -1;
  305|     26|          c = regex[pos++];
  306|     26|          continue;
  307|     26|        }
  308|     64|        else if (c == '\\') {
  309|      2|          c = regex[pos++];  // Identify the specific escape char.
  310|      2|          switch(c) {
  311|      2|            case 'n': c = '\n'; break;
  312|      2|            case 'r': c = '\r'; break;
  313|      2|            case 't': c = '\t'; break;
  314|      2|            // Any of these characters should just be themselves!
  315|      2|            case '-':
  316|      2|            case '\\':
  317|      2|            case ']':
  318|      2|            case '[':
  319|      2|            case '^':
  320|      2|              break;
  321|      2|            default:
  322|      0|              Error("Unknown escape char for char sets: '\\", c, "'.");
  323|      2|          }
  324|      2|        }
  325|     90|        out->char_set[(size_t)c] = true;
  326|     64|        prev_c = c;
  327|     64|        c = regex[pos++];
  328|     64|      }
  329|     34|      if (neg) out->char_set.NOT_SELF();
  330|     34|      if (c == ']') --pos;
  331|     34|      return out;
  332|     34|    }
  333|       |
  334|       |    /// Construct a string, loading everything needed.
  335|      0|    Ptr<re_string> ConstructString() {
  336|      0|      char c = regex[pos++];
  337|      0|      auto out = NewPtr<re_string>();
  338|      0|      while (c != '\"' && pos < regex.size()) {
  339|      0|        // @CAO Error if we run out of chars before close '"'
  340|      0|        if (c == '\\') {
  341|      0|          c = regex[pos++];  // Identify the specific escape char.
  342|      0|          switch(c) {
  343|      0|            case 'n': c = '\n'; break;
  344|      0|            case 'r': c = '\r'; break;
  345|      0|            case 't': c = '\t'; break;
  346|      0|            // Any of these characters should just be themselves!
  347|      0|            case '\"':
  348|      0|            case '\\':
  349|      0|              break;
  350|      0|            default:
  351|      0|              Error("Unknown escape char for literal string: '\\", c, "'.");
  352|      0|          }
  353|      0|        }
  354|      0|        out->str.push_back(c);
  355|      0|        c = regex[pos++];
  356|      0|      }
  357|      0|      if (c == '\"') --pos;
  358|      0|
  359|      0|      return out;
  360|      0|    }
  361|       |
  362|       |    /// Should only be called when we know we have a single unit to produce.  Build and return it.
  363|     70|    Ptr<re_base> ConstructSegment() {
  364|     70|      Ptr<re_base> result;
  365|     70|      char c = regex[pos++];  // Grab the current character and move pos to next.
  366|     70|      switch (c) {
  367|     70|        case '.':
  368|      3|          result = NewPtr<re_charset>('\n', true);  // Anything except newline.
  369|      3|          break;
  370|     70|        case '(':
  371|      6|          result = Process();         // Process the internal contents of parens.
  372|      6|          EnsureNext(')');            // Make sure last char is a paren and advance.
  373|      6|          break;
  374|     70|        case '[':
  375|     34|          result = ConstructSet();    // Build the inside of the set.
  376|     34|          EnsureNext(']');            // Make sure last char is a close-bracket and advance.
  377|     34|          break;
  378|     70|        case '"':
  379|      0|          result = ConstructString(); // Build the inside of the string.
  380|      0|          EnsureNext('"');            // Make sure last char is a quote and advance.
  381|      0|          break;
  382|     70|        case '\\':
  383|      6|          c = regex[pos++];  // Identify the specific escape char.
  384|      6|          switch(c) {
  385|      6|            case 'n': c = '\n'; break;
  386|      6|            case 'r': c = '\r'; break;
  387|      6|            case 't': c = '\t'; break;
  388|      6|            // Any of these characters should just be themselves!
  389|      6|            case '\\':
  390|      6|            case '\"':
  391|      6|            case '*':
  392|      6|            case '+':
  393|      6|            case '?':
  394|      6|            case '.':
  395|      6|            case '|':
  396|      6|            case '(':
  397|      6|            case ')':
  398|      6|            case '[':
  399|      6|            case ']':
  400|      6|              break;
  401|      6|            default:
  402|      0|              Error("Unknown escape char for regex: '\\", c, "'.");
  403|      6|          }
  404|      6|          result = NewPtr<re_string>(c);
  405|      6|          break;
  406|      6|
  407|      6|        // Error cases
  408|      6|        case '|':
  409|      0|        case '*':
  410|      0|        case '+':
  411|      0|        case '?':
  412|      0|        case ')':
  413|      0|          Error("Expected regex segment but got '", c, "' at position ", pos, ".");
  414|      0|          result = NewPtr<re_string>(c);
  415|      0|          break;
  416|      0|
  417|     21|        default:
  418|     21|          // Take this char directly.
  419|     21|          result = NewPtr<re_string>(c);
  420|     70|      }
  421|     70|
  422|     70|      emp_assert(result != nullptr);
  423|     70|      return result;
  424|     70|    }
  425|       |
  426|       |    /// Process the input regex into a tree representaion.
  427|     38|    Ptr<re_block> Process(Ptr<re_block> cur_block=nullptr) {
  428|     38|      emp_assert(pos >= 0 && pos < regex.size(), pos, regex.size());
  429|     38|
  430|     38|      // If caller does not provide current block, create one (and return it.)
  431|     38|      if (cur_block==nullptr) cur_block = NewPtr<re_block>();
  432|     38|
  433|     38|      // All blocks need to start with a single token.
  434|     38|      cur_block->push( ConstructSegment() );
  435|     38|
  436|    106|      while (pos < regex.size()) {
  437|     77|        const char c = regex[pos++];
  438|     77|        switch (c) {
  439|     77|          // case '|': cur_block->push( new re_or( cur_block->pop(), ConstructSegment() ) ); break;
  440|     77|          case '|': cur_block->push( NewPtr<re_or>( cur_block->pop(), Process() ) ); break;
  441|     77|          case '*': cur_block->push( NewPtr<re_star>( cur_block->pop() ) ); break;
  442|     77|          case '+': cur_block->push( NewPtr<re_plus>( cur_block->pop() ) ); break;
  443|     77|          case '?': cur_block->push( NewPtr<re_qm>( cur_block->pop() ) ); break;
  444|     77|          case ')': pos--; return cur_block;  // Must be ending segment (restore pos to check on return)
  445|     77|
  446|     77|          default:     // Must be a regular "segment"
  447|     32|            pos--;     // Restore to previous char to construct the next seqment.
  448|     32|            cur_block->push( ConstructSegment() );
  449|     77|        }
  450|     77|      }
  451|     38|
  452|     38|      return cur_block;
  453|     38|    }
  454|       |
  455|       |  public:
  456|       |    RegEx() = delete;
  457|       |    RegEx(const std::string & r)
  458|     21|    : regex(r), notes(), valid(true), pos(0), dfa(), dfa_ready(false), head() {
  459|     21|      Process(ToPtr(&head));
  460|     27|      while(head.Simplify());
  461|     21|    }
  462|       |    RegEx(const RegEx & r)
  463|      7|    : regex(r.regex), notes(), valid(true), pos(0), dfa(), dfa_ready(false), head() {
  464|      7|      Process(ToPtr(&head));
  465|      7|      while(head.Simplify());
  466|      7|    }
  467|     28|    ~RegEx() { ; }
  468|       |
  469|       |    /// Set this RegEx equal to another.
  470|      0|    RegEx & operator=(const RegEx & r) {
  471|      0|      regex = r.regex;
  472|      0|      notes.resize(0);
  473|      0|      valid = true;
  474|      0|      pos = 0;
  475|      0|      head.Clear();
  476|      0|      Process(ToPtr(&head));
  477|      0|      while (head.Simplify());
  478|      0|      return *this;
  479|      0|    }
  480|       |
  481|       |    /// Convert the RegEx to an standard string, readable from outsite this class.
  482|      0|    std::string AsString() const { return to_literal(regex); }
  483|       |
  484|       |    /// Add this regex to an NFA being built.
  485|     18|    void AddToNFA(NFA & nfa, size_t start, size_t stop) const { head.AddToNFA(nfa, start, stop); }
  486|       |
  487|       |    /// Assume the RegEx is ready and setup processing for it.
  488|       |    void Generate() const;
  489|       |
  490|       |    /// Test if a string statisfies this regex.
  491|     23|    bool Test(const std::string & str) const {
  492|     23|      if (!dfa_ready) Generate();
  493|     23|      return dfa.Test(str);
  494|     23|    }
  495|       |
  496|       |    /// For debugging: print the internal representation of the regex.
  497|      0|    void PrintInternal() { head.Print(std::cout); std::cout << std::endl; }
  498|       |
  499|       |    /// For debugging: print any internal notes generated about this regex.
  500|      0|    void PrintNotes() {
  501|      0|      for (const std::string & n : notes) {
  502|      0|        std::cout << n << std::endl;
  503|      0|      }
  504|      0|    }
  505|       |
  506|       |    /// Print general debuging information about this regex.
  507|      0|    void PrintDebug() {
  508|      0|      if (notes.size()) {
  509|      0|        std::cout << "NOTES:" << std::endl;
  510|      0|        PrintNotes();
  511|      0|      }
  512|      0|      std::cout << "RegEx: " << to_escaped_string(regex) << std::endl;
  513|      0|      std::cout << "INTERNAL: ";
  514|      0|      PrintInternal();
  515|      0|    }
  516|       |  };
  517|       |
  518|       |
  519|       |  /// Simple conversion of RegEx to NFA (mostly implemented in RegEx)
  520|     18|  static NFA to_NFA(const RegEx & regex, size_t stop_id=1) {
  521|     18|    NFA nfa(2);  // State 0 = start, state 1 = stop.
  522|     18|    nfa.SetStop(1, stop_id);
  523|     18|    regex.AddToNFA(nfa, 0, 1);
  524|     18|    return nfa;
  525|     18|  }
  526|       |
  527|       |  /// Conversion of RegEx to DFA, via NFA intermediate.
  528|      7|  static DFA to_DFA(const RegEx & regex) {
  529|      7|    return to_DFA( to_NFA(regex) );
  530|      7|  }
  531|       |
  532|      7|  void RegEx::Generate() const {
  533|      7|    dfa = to_DFA(*this);
  534|      7|    dfa_ready = true;
  535|      7|  }
  536|       |}
  537|       |
  538|       |#endif
  539|       |

/home/emily/repos/Empirical_Tests/source/tools/SolveState.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file SolveState.h
    7|       | *  @brief Used as part of a branching solver to keep track of the current state.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_SOLVE_STATE_H
   13|       |#define EMP_SOLVE_STATE_H
   14|       |
   15|       |#include "../base/assert.h"
   16|       |
   17|       |#include "BitVector.h"
   18|       |
   19|       |namespace emp {
   20|       |
   21|       |  /// Often in a branch-and-bound algorithm, we need to identify the sub-set of items that
   22|       |  /// maximizes (or minimizes) an optimization metric.  SolveState keeps track of the current
   23|       |  /// state for which items have been locked in as "included" in the current branks, which have
   24|       |  /// been "excluded", and which are still "unknown" (still to be decided upon.)
   25|       |  /// All tracking is performed with BitVectors for high efficiency.
   26|       |
   27|       |  class SolveState {
   28|       |  private:
   29|       |    BitVector in_items;   ///< Items included for sure
   30|       |    BitVector unk_items;  ///< Items yet to be decided on
   31|       |
   32|       |  public:
   33|      0|    SolveState(size_t state_size=0) : in_items(state_size), unk_items(state_size) {
   34|      0|      unk_items.SetAll();
   35|      0|    }
   36|      0|    SolveState(const SolveState & in) : in_items(in.in_items), unk_items(in.unk_items) { ; }
   37|      0|    ~SolveState() { ; }
   38|       |
   39|       |    /// Set this SolveState to be identical to another.
   40|      0|    SolveState & operator=(const SolveState & in) {
   41|      0|      in_items = in.in_items;
   42|      0|      unk_items = in.unk_items;
   43|      0|      return *this;
   44|      0|    }
   45|       |
   46|       |    /// How many items are being considered in the current SolveState?
   47|      0|    size_t GetSize() const { return in_items.GetSize(); }
   48|       |
   49|       |    /// Test if a particular item is going to be included for sure in the current solve state.
   50|       |    /// (If it has been excluded -OR- is yet to be decided upon, false will be returned)
   51|      0|    bool IsIn(size_t id) const { return in_items[id]; }
   52|       |
   53|       |    /// Test if a particular item is yet to be decided upon in the current solve state.
   54|       |    /// (If it has been excluded -OR- is included for sure, false will be returned)
   55|      0|    bool IsUnk(size_t id) const { return unk_items[id]; }
   56|       |
   57|       |    /// Test if a particular item is going to be excluded for sure in the current solve state.
   58|       |    /// (If it has been included -OR- is yet to be decided upon, false will be returned)
   59|      0|    bool IsOut(size_t id) const { return !(IsIn(id) | IsUnk(id)); }
   60|       |
   61|       |    /// Test if all items have been decided upon (none are still in the "unknown" state)
   62|      0|    bool IsFinal() const { return unk_items.None(); }
   63|       |
   64|       |    /// How many items have been included for sure?
   65|      0|    size_t CountIn() const { return in_items.CountOnes(); }
   66|       |
   67|       |    /// How many items have yet to be decided upon (are "unknown")
   68|      0|    size_t CountUnk() const { return unk_items.CountOnes(); }
   69|       |
   70|       |    /// How many items have been excluded for sure.
   71|      0|    size_t CountOut() const { return in_items.GetSize() - CountIn() - CountUnk(); }
   72|       |
   73|       |    /// Get the BitVector associated with which items have been included for sure.
   74|      0|    const BitVector & GetInVector() const { return in_items; }
   75|       |
   76|       |    /// Get the BitVector associated with which items have yet to be decided upon.
   77|      0|    const BitVector & GetUnkVector() const { return unk_items; }
   78|       |
   79|       |    /// Get the BitVector associated with which iterm have been excluded for sure.
   80|      0|    BitVector GetOutVector() const { return ~in_items & ~unk_items; }
   81|       |
   82|       |    /// Get the ID of the next unknown item.
   83|      0|    int GetNextUnk(size_t prev_unk) const {
   84|      0|      return unk_items.FindBit(prev_unk+1);
   85|      0|    }
   86|       |
   87|       |    /// Mark a specific item as to be included.
   88|      0|    void Include(size_t id) {
   89|      0|      emp_assert(id >= 0 && id < in_items.size());
   90|      0|      unk_items.Set(id, false);
   91|      0|      in_items.Set(id, true);
   92|      0|    }
   93|       |
   94|       |    /// Mark a specific item as to be excluded.
   95|      0|    void Exclude(size_t id) {
   96|      0|      emp_assert(id >= 0 && id < in_items.size());
   97|      0|      unk_items.Set(id, false);
   98|      0|    }
   99|       |
  100|       |    /// Change our mind about a potentially included node (Be careful since many algorithms don't
  101|       |    /// requite this type of changes to be made.)
  102|      0|    void ForceExclude(size_t id) {
  103|      0|      unk_items.Set(id, false);
  104|      0|      in_items.Set(id, false);
  105|      0|    }
  106|       |
  107|       |    /// Include ALL of the items specified in the provided BitVector.
  108|      0|    void IncludeSet(const BitVector & inc_set) {
  109|      0|      emp_assert(inc_set.GetSize() == in_items.GetSize());
  110|      0|      in_items |= inc_set;
  111|      0|      unk_items &= ~inc_set;
  112|      0|    }
  113|       |
  114|       |    /// Exclude ALL of the items specified in the provided BitVector.
  115|      0|    void ExcludeSet(const BitVector & inc_set) {
  116|      0|      emp_assert(inc_set.GetSize() == in_items.GetSize());
  117|      0|      unk_items &= ~inc_set;
  118|      0|    }
  119|       |  };
  120|       |
  121|       |}
  122|       |
  123|       |#endif
  124|       |

/home/emily/repos/Empirical_Tests/source/tools/TypeTracker.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file TypeTracker.h
    7|       | *  @brief Track class types abstractly to dynamically call correct function overloads.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  @todo Should use std::is_convertible<X,Y>::value to determine if casting on base type is allowed.
   11|       | *  @todo Functions should be able to have fixed type values mixed in.
   12|       | */
   13|       |
   14|       |#ifndef EMP_TYPE_TRACKER_H
   15|       |#define EMP_TYPE_TRACKER_H
   16|       |
   17|       |#include <unordered_map>
   18|       |
   19|       |#include "../base/array.h"
   20|       |#include "../base/assert.h"
   21|       |#include "../meta/meta.h"
   22|       |
   23|       |#include "functions.h"
   24|       |#include "GenericFunction.h"
   25|       |#include "map_utils.h"
   26|       |
   27|       |namespace emp {
   28|       |
   29|       |  /// The base class of any type to be tracked.
   30|       |  struct TrackedType {
   31|       |    virtual size_t GetTypeTrackerID() const noexcept = 0;
   32|      0|    virtual ~TrackedType() {;}
   33|       |  };
   34|       |
   35|       |  /// The derived classes to be tracked should inherit from TypeTracker_Class<ID>
   36|       |  /// where ID is the position in the type list for TypeTracker.  Note: this value can
   37|       |  /// be obtained dyanmically at compile type by using TypeTracker<...>::GetID<TYPE>()
   38|       |  template <typename REAL_T, size_t ID>
   39|       |  struct TypeTracker_Class : public TrackedType {
   40|       |    using real_t = REAL_T;
   41|       |    REAL_T value;
   42|       |
   43|       |    /*_FORCE_COVER_START_*/TypeTracker_Class(const REAL_T & in) : value(in) { ; }/*_FORCE_COVER_END_*/
   44|      5|    /*_FORCE_COVER_START_*/TypeTracker_Class(REAL_T && in) : value(std::forward<REAL_T>(in)) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17TypeTracker_ClassIiLm0EEC2EOi:
  |   44|      3|    /*_FORCE_COVER_START_*/TypeTracker_Class(REAL_T && in) : value(std::forward<REAL_T>(in)) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17TypeTracker_ClassINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELm1EEC2EOS6_:
  |   44|      1|    /*_FORCE_COVER_START_*/TypeTracker_Class(REAL_T && in) : value(std::forward<REAL_T>(in)) { ; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17TypeTracker_ClassIdLm2EEC2EOd:
  |   44|      1|    /*_FORCE_COVER_START_*/TypeTracker_Class(REAL_T && in) : value(std::forward<REAL_T>(in)) { ; }/*_FORCE_COVER_END_*/
  ------------------
   45|       |    /*_FORCE_COVER_START_*/TypeTracker_Class(const TypeTracker_Class &) = default/*_FORCE_COVER_END_*/;
   46|       |    /*_FORCE_COVER_START_*/TypeTracker_Class(TypeTracker_Class &&) = default/*_FORCE_COVER_END_*/;
   47|       |    /*_FORCE_COVER_START_*/TypeTracker_Class & operator=(const TypeTracker_Class &) = default/*_FORCE_COVER_END_*/;
   48|       |    /*_FORCE_COVER_START_*/TypeTracker_Class & operator=(TypeTracker_Class &&) = default/*_FORCE_COVER_END_*/;
   49|     14|    /*_FORCE_COVER_START_*/virtual size_t GetTypeTrackerID() const noexcept { return ID; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp17TypeTracker_ClassIiLm0EE16GetTypeTrackerIDEv:
  |   49|      7|    /*_FORCE_COVER_START_*/virtual size_t GetTypeTrackerID() const noexcept { return ID; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp17TypeTracker_ClassINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELm1EE16GetTypeTrackerIDEv:
  |   49|      3|    /*_FORCE_COVER_START_*/virtual size_t GetTypeTrackerID() const noexcept { return ID; }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp17TypeTracker_ClassIdLm2EE16GetTypeTrackerIDEv:
  |   49|      4|    /*_FORCE_COVER_START_*/virtual size_t GetTypeTrackerID() const noexcept { return ID; }/*_FORCE_COVER_END_*/
  ------------------
   50|       |  };
   51|       |
   52|       |  /// Dynamic functions that are indexed by parameter types; calls lookup the correct function
   53|       |  /// to forward arguments into.
   54|       |  template <typename... TYPES>
   55|       |  struct TypeTracker {
   56|       |    using this_t = TypeTracker<TYPES...>;
   57|       |    template <typename REAL_T>
   58|       |    using wrap_t = TypeTracker_Class< REAL_T, get_type_index<REAL_T,TYPES...>() >;
   59|       |
   60|       |    /// How many types are we working with?
   61|     20|    /*_FORCE_COVER_START_*/constexpr static size_t GetNumTypes() { return sizeof...(TYPES); }/*_FORCE_COVER_END_*/
   62|       |
   63|       |    /// How many combinations of V types are there?
   64|       |    /*_FORCE_COVER_START_*/constexpr static size_t GetNumCombos(size_t vals=2) {
   65|       |      size_t result = 1;
   66|       |      for (size_t v = 0; v < vals; v++) result *= GetNumTypes();
   67|       |      return result;
   68|       |    }/*_FORCE_COVER_END_*/
   69|       |
   70|       |    /// How many combinations are the of the given number of types OR FEWER?
   71|      6|    /*_FORCE_COVER_START_*/constexpr static size_t GetCumCombos(size_t vals=2) {
   72|      6|      size_t cur_result = 1;
   73|      6|      size_t cum_result = 1;
   74|     14|      for (size_t v = 0; v < vals; v++) {
   75|      8|        cur_result *= GetNumTypes();
   76|      8|        cum_result += cur_result;
   77|      8|      }
   78|      6|      return cum_result;
   79|      6|    }/*_FORCE_COVER_END_*/
   80|       |
   81|       |    /// Each type should have a unique ID.
   82|       |    /*_FORCE_COVER_START_*/template <typename T>
   83|      6|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return get_type_index<T,TYPES...>(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIiEEmv:
  |   83|      2|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return get_type_index<T,TYPES...>(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIS6_EEmv:
  |   83|      2|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return get_type_index<T,TYPES...>(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIdEEmv:
  |   83|      2|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return get_type_index<T,TYPES...>(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
   84|       |
   85|       |    /// Each set of types should have an ID unique within that number of types.
   86|       |    /*_FORCE_COVER_START_*/template <typename T1, typename T2, typename... Ts>
   87|      4|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return GetID<T1>() + GetID<T2,Ts...>() * GetNumTypes(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIiS6_JdEEEmv:
  |   87|      2|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return GetID<T1>() + GetID<T2,Ts...>() * GetNumTypes(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIS6_dJEEEmv:
  |   87|      2|    /*_FORCE_COVER_START_*/constexpr static size_t GetID() { return GetID<T1>() + GetID<T2,Ts...>() * GetNumTypes(); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIiiJEEEmv
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIidJEEEmv
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE5GetIDIS6_iJEEEmv
  ------------------
   88|       |
   89|       |    /// A ComboID should be unique *across* all size combinations.
   90|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
   91|      1|    /*_FORCE_COVER_START_*/constexpr static size_t GetComboID() {
   92|      1|      return GetCumCombos(sizeof...(Ts)-1) + GetID<Ts...>();
   93|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE10GetComboIDIJiS6_dEEEmv:
  |   91|      1|    /*_FORCE_COVER_START_*/constexpr static size_t GetComboID() {
  |   92|      1|      return GetCumCombos(sizeof...(Ts)-1) + GetID<Ts...>();
  |   93|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE10GetComboIDIJiiEEEmv
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE10GetComboIDIJidEEEmv
  ------------------
  | Unexecuted instantiation: _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE10GetComboIDIJS6_iEEEmv
  ------------------
   94|       |
   95|       |    /// A Tracked ID is simply the unique ID of the type being tracked.
   96|       |    /*_FORCE_COVER_START_*/static size_t GetTrackedID(const TrackedType & tt) { return tt.GetTypeTrackerID(); }/*_FORCE_COVER_END_*/
   97|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
   98|       |
   99|       |    /// Or set of types being tracked...
  100|       |    /*_FORCE_COVER_START_*/static size_t GetTrackedID(const TrackedType & tt1, const TrackedType & tt2, const Ts &... ARGS) {
  101|       |      return tt1.GetTypeTrackerID() + GetTrackedID(tt2, ARGS...) * GetNumTypes();
  102|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  103|       |
  104|       |    /// We should also about able to use a pointer to access tracked IDs
  105|      6|    /*_FORCE_COVER_START_*/static size_t GetTrackedID(TrackedType * tt) { return tt->GetTypeTrackerID(); }/*_FORCE_COVER_END_*/
  106|       |
  107|       |    /// A set of pointers to access tracked IDs
  108|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  109|      8|    /*_FORCE_COVER_START_*/static size_t GetTrackedID(TrackedType * tt1, TrackedType * tt2, Ts *... ARGS) {
  110|      8|      return tt1->GetTypeTrackerID() + GetTrackedID(tt2, ARGS...) * GetNumTypes();
  111|      8|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE12GetTrackedIDIJEEEmPNS_11TrackedTypeESA_DpPT_:
  |  109|      6|    /*_FORCE_COVER_START_*/static size_t GetTrackedID(TrackedType * tt1, TrackedType * tt2, Ts *... ARGS) {
  |  110|      6|      return tt1->GetTypeTrackerID() + GetTrackedID(tt2, ARGS...) * GetNumTypes();
  |  111|      6|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE12GetTrackedIDIJNS_11TrackedTypeEEEEmPS9_SA_DpPT_:
  |  109|      2|    /*_FORCE_COVER_START_*/static size_t GetTrackedID(TrackedType * tt1, TrackedType * tt2, Ts *... ARGS) {
  |  110|      2|      return tt1->GetTypeTrackerID() + GetTrackedID(tt2, ARGS...) * GetNumTypes();
  |  111|      2|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  112|       |
  113|       |    /// A tracked COMBO ID, is an ID for this combination of types, unique among all possible type
  114|       |    /// combinations.  Consistent with GetComboID with the same underlying types.
  115|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  116|      5|    /*_FORCE_COVER_START_*/constexpr static size_t GetTrackedComboID(Ts... ARGS) {
  117|      5|      return GetCumCombos(sizeof...(Ts)-1) + GetTrackedID(ARGS...);
  118|      5|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE17GetTrackedComboIDIJPNS_11TrackedTypeESA_EEEmDpT_:
  |  116|      4|    /*_FORCE_COVER_START_*/constexpr static size_t GetTrackedComboID(Ts... ARGS) {
  |  117|      4|      return GetCumCombos(sizeof...(Ts)-1) + GetTrackedID(ARGS...);
  |  118|      4|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE17GetTrackedComboIDIJPNS_11TrackedTypeESA_SA_EEEmDpT_:
  |  116|      1|    /*_FORCE_COVER_START_*/constexpr static size_t GetTrackedComboID(Ts... ARGS) {
  |  117|      1|      return GetCumCombos(sizeof...(Ts)-1) + GetTrackedID(ARGS...);
  |  118|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  119|       |
  120|       |    /// fun_map is a hash table that maps a set of inputs to the appropriate function.
  121|       |    std::unordered_map<size_t, emp::GenericFunction *> fun_map;
  122|       |
  123|       |    // Constructors!
  124|      1|    /*_FORCE_COVER_START_*/TypeTracker() : fun_map() { ; }/*_FORCE_COVER_END_*/
  125|       |    /*_FORCE_COVER_START_*/TypeTracker(const TypeTracker &) = default/*_FORCE_COVER_END_*/;
  126|       |    /*_FORCE_COVER_START_*/TypeTracker(TypeTracker &&) = default/*_FORCE_COVER_END_*/;
  127|       |    /*_FORCE_COVER_START_*/TypeTracker & operator=(const TypeTracker &) = default/*_FORCE_COVER_END_*/;
  128|       |    /*_FORCE_COVER_START_*/TypeTracker & operator=(TypeTracker &&) = default/*_FORCE_COVER_END_*/;
  129|       |
  130|       |    // Destructor!
  131|      1|    /*_FORCE_COVER_START_*/~TypeTracker() {
  132|      3|      for (auto x : fun_map) delete x.second;  // Clear out Functions.
  133|      1|    }/*_FORCE_COVER_END_*/
  134|       |
  135|       |    /// Convert an input value into a TypeTracker_Class maintaining the value (universal version)
  136|       |    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> Wrap(REAL_T && val) {
  137|       |      emp_assert((has_type<REAL_T,TYPES...>()));    // Make sure we're wrapping a legal type.
  138|       |      return wrap_t<REAL_T>(std::forward<REAL_T>(val));
  139|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  140|       |
  141|       |    /// Create an input value in a TypeTracker_Class maintaining the value (reference version)
  142|       |    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> * New(REAL_T & val) {
  143|       |      emp_assert((has_type<REAL_T, TYPES...>()));   // Make sure we're wrapping a legal type.
  144|       |      return new wrap_t<REAL_T>(val);
  145|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  146|       |
  147|       |    /// Create an input value in a TypeTracker_Class maintaining the value (move version)
  148|      5|    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> * New(REAL_T && val) {
  149|      5|      emp_assert((has_type<REAL_T, TYPES...>()));   // Make sure we're wrapping a legal type.
  150|      5|      return new wrap_t<REAL_T>(std::forward<REAL_T>(val));
  151|      5|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE3NewIiEEPNS_17TypeTracker_ClassIT_Xcl14get_type_indexISA_iS6_dEEEEEOSA_:
  |  148|      3|    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> * New(REAL_T && val) {
  |  149|      3|      emp_assert((has_type<REAL_T, TYPES...>()));   // Make sure we're wrapping a legal type.
  |  150|      3|      return new wrap_t<REAL_T>(std::forward<REAL_T>(val));
  |  151|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE3NewIS6_EEPNS_17TypeTracker_ClassIT_Xcl14get_type_indexISA_iS6_dEEEEEOSA_:
  |  148|      1|    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> * New(REAL_T && val) {
  |  149|      1|      emp_assert((has_type<REAL_T, TYPES...>()));   // Make sure we're wrapping a legal type.
  |  150|      1|      return new wrap_t<REAL_T>(std::forward<REAL_T>(val));
  |  151|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE3NewIdEEPNS_17TypeTracker_ClassIT_Xcl14get_type_indexISA_iS6_dEEEEEOSA_:
  |  148|      1|    /*_FORCE_COVER_START_*/template <typename REAL_T> /*_FORCE_COVER_START_*/wrap_t<REAL_T> * New(REAL_T && val) {
  |  149|      1|      emp_assert((has_type<REAL_T, TYPES...>()));   // Make sure we're wrapping a legal type.
  |  150|      1|      return new wrap_t<REAL_T>(std::forward<REAL_T>(val));
  |  151|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  152|       |
  153|       |    /// Test if the tracked type is TEST_T
  154|       |    /*_FORCE_COVER_START_*/template <typename TEST_T>
  155|       |    /*_FORCE_COVER_START_*/bool IsType( TrackedType & tt ) {
  156|       |      return tt.GetTypeTrackerID() == get_type_index<TEST_T,TYPES...>();
  157|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  158|       |
  159|       |    /// Test if the tracked type points to TEST_T
  160|       |    /*_FORCE_COVER_START_*/template <typename TEST_T>
  161|       |    /*_FORCE_COVER_START_*/bool IsType( TrackedType * tt ) { return IsType(*tt); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  162|       |
  163|       |    /// Convert the tracked type back to REAL_T.  Assert that this is type safe!
  164|       |    /*_FORCE_COVER_START_*/template <typename REAL_T>
  165|       |    /*_FORCE_COVER_START_*/REAL_T ToType( TrackedType & tt ) {
  166|       |      emp_assert(IsType<REAL_T>(tt));
  167|       |      return ((wrap_t<REAL_T> *) &tt)->value;
  168|       |    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  169|       |
  170|       |    /// Convert the tracked type pointer back to REAL_T.  Assert that this is type safe!
  171|       |    /*_FORCE_COVER_START_*/template <typename REAL_T>
  172|       |    /*_FORCE_COVER_START_*/REAL_T ToType( TrackedType * tt ) { return ToType(*tt); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  173|       |
  174|       |    /// Cast the tracked type to OUT_T.  Try to do so even if NOT original type!
  175|       |    /*_FORCE_COVER_START_*/template <typename OUT_T>
  176|       |    /*_FORCE_COVER_START_*/OUT_T Cast( TrackedType & tt ) { return ((wrap_t<OUT_T> *) &tt)->value; }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  177|       |
  178|       |    /// Cast the tracked type pointer to OUT_T.  Try to do so even if NOT original type!
  179|       |    /*_FORCE_COVER_START_*/template <typename OUT_T>
  180|       |    /*_FORCE_COVER_START_*/OUT_T Cast( TrackedType * tt ) { return Cast(*tt); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  181|       |
  182|       |    /// Add a new std::function that this TypeTracker should call if the appropriate types are
  183|       |    /// passed in.
  184|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  185|      3|    /*_FORCE_COVER_START_*/this_t & AddFunction( std::function<void(Ts...)> fun ) {
  186|      3|      constexpr size_t ID = GetComboID<Ts...>();
  187|      3|
  188|      3|      // We need to ensure there are the same number of TrackedType parameters in the wrapped
  189|      3|      // function as there were typed parameters in the original.  To accomplish this task, we
  190|      3|      // will expand the original type pack, but use decoys to convert to TrackedType.
  191|      3|
  192|      3|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  193|      3|        // Ensure all types can be cast appropriately
  194|      3|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  195|      3|
  196|      3|        // Now run the function with the correct type conversions
  197|      3|        fun( ((wrap_t<Ts> *) args)->value... );
  198|      3|      };
  ------------------
  | _ZZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJiiEEERS7_St8functionIFvDpT_EEENKUlPNS_11TrackedTypeESG_E_clESG_SG_:
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  ------------------
  | _ZZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJidEEERS7_St8functionIFvDpT_EEENKUlPNS_11TrackedTypeESG_E_clESG_SG_:
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  ------------------
  | _ZZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJS6_iEEERS7_St8functionIFvDpT_EEENKUlPNS_11TrackedTypeESG_E_clESG_SG_:
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  ------------------
  199|      3|
  200|      3|      fun_map[ID] = new Function<void(emp::type_decoy<TrackedType *,Ts>...)>(fun_wrap);
  201|      3|
  202|      3|      return *this;
  203|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJiiEEERS7_St8functionIFvDpT_EE:
  |  185|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( std::function<void(Ts...)> fun ) {
  |  186|      1|      constexpr size_t ID = GetComboID<Ts...>();
  |  187|      1|
  |  188|      1|      // We need to ensure there are the same number of TrackedType parameters in the wrapped
  |  189|      1|      // function as there were typed parameters in the original.  To accomplish this task, we
  |  190|      1|      // will expand the original type pack, but use decoys to convert to TrackedType.
  |  191|      1|
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  |  199|      1|
  |  200|      1|      fun_map[ID] = new Function<void(emp::type_decoy<TrackedType *,Ts>...)>(fun_wrap);
  |  201|      1|
  |  202|      1|      return *this;
  |  203|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJidEEERS7_St8functionIFvDpT_EE:
  |  185|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( std::function<void(Ts...)> fun ) {
  |  186|      1|      constexpr size_t ID = GetComboID<Ts...>();
  |  187|      1|
  |  188|      1|      // We need to ensure there are the same number of TrackedType parameters in the wrapped
  |  189|      1|      // function as there were typed parameters in the original.  To accomplish this task, we
  |  190|      1|      // will expand the original type pack, but use decoys to convert to TrackedType.
  |  191|      1|
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  |  199|      1|
  |  200|      1|      fun_map[ID] = new Function<void(emp::type_decoy<TrackedType *,Ts>...)>(fun_wrap);
  |  201|      1|
  |  202|      1|      return *this;
  |  203|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJS6_iEEERS7_St8functionIFvDpT_EE:
  |  185|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( std::function<void(Ts...)> fun ) {
  |  186|      1|      constexpr size_t ID = GetComboID<Ts...>();
  |  187|      1|
  |  188|      1|      // We need to ensure there are the same number of TrackedType parameters in the wrapped
  |  189|      1|      // function as there were typed parameters in the original.  To accomplish this task, we
  |  190|      1|      // will expand the original type pack, but use decoys to convert to TrackedType.
  |  191|      1|
  |  192|      1|      auto fun_wrap = [fun](emp::type_decoy<TrackedType *,Ts>... args) {
  |  193|      1|        // Ensure all types can be cast appropriately
  |  194|      1|        emp_assert( AllTrue( dynamic_cast<wrap_t<Ts> *>(args)... ) );
  |  195|      1|
  |  196|      1|        // Now run the function with the correct type conversions
  |  197|      1|        fun( ((wrap_t<Ts> *) args)->value... );
  |  198|      1|      };
  |  199|      1|
  |  200|      1|      fun_map[ID] = new Function<void(emp::type_decoy<TrackedType *,Ts>...)>(fun_wrap);
  |  201|      1|
  |  202|      1|      return *this;
  |  203|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  204|       |
  205|       |    /// Add a new function pointer that this TypeTracker should call if the appropriate types are
  206|       |    /// passed in.
  207|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  208|      3|    /*_FORCE_COVER_START_*/this_t & AddFunction( void (*fun)(Ts...) ) {
  209|      3|      return AddFunction( std::function<void(Ts...)>(fun) );
  210|      3|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJiiEEERS7_PFvDpT_E:
  |  208|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( void (*fun)(Ts...) ) {
  |  209|      1|      return AddFunction( std::function<void(Ts...)>(fun) );
  |  210|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJidEEERS7_PFvDpT_E:
  |  208|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( void (*fun)(Ts...) ) {
  |  209|      1|      return AddFunction( std::function<void(Ts...)>(fun) );
  |  210|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11TypeTrackerIJiNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEE11AddFunctionIJS6_iEEERS7_PFvDpT_E:
  |  208|      1|    /*_FORCE_COVER_START_*/this_t & AddFunction( void (*fun)(Ts...) ) {
  |  209|      1|      return AddFunction( std::function<void(Ts...)>(fun) );
  |  210|      1|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  ------------------
  211|       |
  212|       |    /// Run the appropriate function based on the argument types received.
  213|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  214|      4|    /*_FORCE_COVER_START_*/void RunFunction( Ts... args ) {                 // args must all be TrackedType pointers!
  215|      4|      const size_t pos = GetTrackedComboID(args...);
  216|      4|      if (Has(fun_map, pos)) {  // If a redirect exists, use it!
  217|      3|        GenericFunction * gfun = fun_map[pos];
  218|      3|        gfun->Call<void, emp::type_decoy<TrackedType *,Ts>...>(((emp::type_decoy<TrackedType *,Ts>) args)...);
  219|      3|      }
  220|      4|    }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  221|       |
  222|       |    /// Call TypeTracker as a function (refers call to RunFunction)
  223|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  224|       |    /*_FORCE_COVER_START_*/void operator()(Ts... args) { RunFunction(args...); }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  225|       |  };
  226|       |
  227|       |}
  228|       |
  229|       |#endif
  230|       |

/home/emily/repos/Empirical_Tests/source/tools/alert.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2015-2017
    5|       | *
    6|       | *  @file  Alert.h
    7|       | *  @brief Define an Alert function that goes to std::cerr in c++ or to Alert() in Javascript.
    8|       | *  @note Status: RELEASE
    9|       | */
   10|       |
   11|       |#ifndef EMP_ALERT_H
   12|       |#define EMP_ALERT_H
   13|       |
   14|       |#include "string_utils.h"
   15|       |
   16|       |// If we are in emscripten, make sure to include the header.
   17|       |#ifdef EMSCRIPTEN
   18|       |#include <emscripten.h>
   19|       |#endif
   20|       |
   21|       |
   22|       |namespace emp {
   23|       |#ifdef EMSCRIPTEN
   24|       |  void Alert(const std::string & msg) { EM_ASM_ARGS({ msg = Pointer_stringify($0); alert(msg); }, msg.c_str()); }
   25|       |#else
   26|       |  /// Send msg to cerr if in C++, or show msg in an alert box if compiled to Javascript
   27|       |  /// Input can be any number of arguments of any types as long as the can be converted to
   28|       |  /// strings with emp::to_string().
   29|      0|  void Alert(const std::string & msg) { std::cerr << msg << std::endl; }
   30|       |#endif
   31|       |  /// @cond TEMPLATES
   32|       |  /*_FORCE_COVER_START_*/template <typename... TYPE_SET>
   33|       |  void Alert(TYPE_SET... inputs) { Alert(emp::to_string(inputs...)); }/*_FORCE_COVER_END_*/
   34|       |  /// @endcond
   35|       |
   36|       |  /// A version of Alert that will cap how many times it can go off
   37|       |  /*_FORCE_COVER_START_*/template <typename... TYPE_SET>
   38|      0|  static void CappedAlert(size_t cap, TYPE_SET... inputs) {
   39|      0|    static size_t cur_count = 0;
   40|      0|    if (cur_count++ < cap) Alert(emp::to_string(inputs...));
   41|      0|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3empL11CappedAlertIJPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES2_mEEEvmDpT_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3empL11CappedAlertIJPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvmDpT_
  ------------------
   42|       |
   43|       |  /// An object that will automatically output a message during construction or destruction,
   44|       |  /// usually for use in debugging to disentangle timings.
   45|       |  struct AlertObj {
   46|       |    std::string msg;    ///< Message for the alert to print.
   47|       |    bool on_construct;  ///< Should the message print automatically during construction?
   48|       |    bool on_destruct;   ///< Should the message print automatically during destruction?
   49|       |
   50|       |    AlertObj(const std::string & _msg, bool _on_c=true, bool _on_d=false)
   51|      0|    : msg(_msg), on_construct(_on_c), on_destruct(_on_d) { if (on_construct) emp::Alert(msg); }
   52|      0|    ~AlertObj() { if (on_destruct) emp::Alert(msg); }
   53|       |
   54|      0|    void Trigger() { emp::Alert(msg); }
   55|      0|    void SetMessage(const std::string & _msg) { msg = _msg; }
   56|       |  };
   57|       |}
   58|       |
   59|       |
   60|       |#endif
   61|       |

/home/emily/repos/Empirical_Tests/source/tools/attrs.h:
    1|       |#ifndef EMP_PLOT_EMP
    2|       |#define EMP_PLOT_EMP
    3|       |
    4|       |#include <algorithm>
    5|       |#include <iostream>
    6|       |#include <iterator>
    7|       |#include <memory>
    8|       |#include <utility>
    9|       |#include <vector>
   10|       |
   11|       |#include "meta/TypePack.h"
   12|       |#include "meta/type_traits.h"
   13|       |
   14|       |namespace emp {
   15|       |  namespace tools {
   16|       |
   17|       |    struct value_tag {};
   18|       |
   19|       |    template <typename V1, typename V2>
   20|       |    struct is_same_attribute
   21|       |      : std::is_same<typename V1::attribute_t, typename V2::attribute_t> {};
   22|       |
   23|       |    template <typename T>
   24|       |    struct is_attribute_value : std::is_base_of<value_tag, T> {};
   25|       |    template <typename T>
   26|       |    constexpr bool is_attribute_value_v = is_attribute_value<T>::value;
   27|       |
   28|       |    template <typename...>
   29|       |    class Attrs;
   30|       |
   31|       |    template <typename T>
   32|       |    struct is_attributes_pack : std::false_type {};
   33|       |    template <typename... U>
   34|       |    struct is_attributes_pack<Attrs<U...>> : std::true_type {};
   35|       |
   36|       |    template <typename T>
   37|       |    constexpr bool is_attributes_pack_v = is_attributes_pack<T>::value;
   38|       |
   39|       |    namespace __impl_has_attr {
   40|       |      template <typename Pack, typename Attr>
   41|       |      struct has_attribute {
   42|       |        /*_FORCE_COVER_START_*/template <typename T>
   43|       |        /*_FORCE_COVER_START_*/static constexpr std::true_type HasAttr(
   44|       |          const typename Attr::template value_t<T>&) {
   45|       |          return {};
   46|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   47|       |        /*_FORCE_COVER_START_*/static constexpr std::false_type HasAttr(...) { return {}; }/*_FORCE_COVER_END_*/
   48|       |
   49|       |        using type = decltype(HasAttr(std::declval<Pack>()));
   50|       |      };
   51|       |    }  // namespace __impl_has_attr
   52|       |
   53|       |    template <typename Pack, typename Attr>
   54|       |    struct has_attribute : __impl_has_attr::has_attribute<Pack, Attr>::type {};
   55|       |    template <typename Pack, typename Attr>
   56|       |    constexpr bool has_attribute_v = has_attribute<Pack, Attr>::value;
   57|       |
   58|       |    namespace __impl_attr_base {
   59|       |      template <typename Attr, template <typename> class Value>
   60|       |      struct AttrBase {
   61|       |        using attribute_t = Attr;
   62|       |        template <typename T>
   63|       |        using value_t = Value<T>;
   64|       |
   65|       |        static constexpr struct get_attribute_t {
   66|       |          /// Given an attribute pack, GetAttribute will extract just this
   67|       |          /// attribute
   68|       |          /*_FORCE_COVER_START_*/template <class T>
   69|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(value_t<T>& value) const {
   70|       |            return value;
   71|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   72|       |
   73|       |          /*_FORCE_COVER_START_*/template <class T>
   74|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(const value_t<T>& value) const {
   75|       |            return value;
   76|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   77|       |
   78|       |          /*_FORCE_COVER_START_*/template <class T>
   79|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(value_t<T>&& value) const {
   80|       |            return std::move(value);
   81|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   82|       |
   83|       |          /*_FORCE_COVER_START_*/template <class T>
   84|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(const value_t<T>&& value) const {
   85|       |            return std::move(value);
   86|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
   87|       |        } GetAttribute{};
   88|       |
   89|       |        /// Given an attribute pack, Get(pack) will extract the value of this
   90|       |        /// attribute in that pack. It lives in this strange container struct
   91|       |        /// because that allows it to be passed into mapping function functions,
   92|       |        /// so you can do something like:
   93|       |        /// <code>
   94|       |        /// std::vector<SomeAttributePack> packs;
   95|       |        /// std::transform(packs.begin(), packs.end(), MyAttr::Get);
   96|       |        /// </code>
   97|       |        static constexpr struct get_t {
   98|       |          /*_FORCE_COVER_START_*/template <class T>
   99|       |          /*_FORCE_COVER_START_*/constexpr const T& operator()(const value_t<T>& target) const {
  100|       |            return *target;
  101|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  102|       |
  103|       |          /*_FORCE_COVER_START_*/template <class T>
  104|       |          /*_FORCE_COVER_START_*/constexpr T& operator()(value_t<T>& target) const {
  105|       |            return *target;
  106|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  107|       |
  108|       |          /*_FORCE_COVER_START_*/template <class T>
  109|       |          /*_FORCE_COVER_START_*/constexpr T&& operator()(value_t<T>&& target) const {
  110|       |            return *std::move(target);
  111|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  112|       |
  113|       |          /*_FORCE_COVER_START_*/template <class T>
  114|       |          /*_FORCE_COVER_START_*/constexpr const T&& operator()(const value_t<T>&& target) const {
  115|       |            return *std::move(target);
  116|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  117|       |        } Get{};
  118|       |
  119|       |        // -- CallOrGet --
  120|       |        private:
  121|       |        // Handle the case when Get(target) is callable
  122|       |        /*_FORCE_COVER_START_*/template <class T, class... U>
  123|       |        /*_FORCE_COVER_START_*/static constexpr auto __impl_CallOrGetAttribute(
  124|       |          const std::true_type& isCallable, T&& target, U&&... args) {
  125|       |          return Make(Get(std::forward<T>(target))(std::forward<U>(args)...));
  126|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  127|       |
  128|       |        // Handle the case when Get(target) is not callable
  129|       |        /*_FORCE_COVER_START_*/template <class T, class... U>
  130|       |        /*_FORCE_COVER_START_*/static constexpr auto __impl_CallOrGetAttribute(
  131|       |          const std::false_type& isCallable, T&& target, U&&... args) {
  132|       |          return GetAttribute(std::forward<T>(target));
  133|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  134|       |
  135|       |        public:
  136|       |        /// Given an attribute pack, CallOrGetAttribute(pack, args...) will
  137|       |        /// attempt to return Get(pack)(args...). If this fails to compile,
  138|       |        /// because the value of this attribute is not callable in the given
  139|       |        /// pack, then just this attribute will be returned, Get(pack).
  140|       |        static constexpr struct call_or_get_attribute_t {
  141|       |          /*_FORCE_COVER_START_*/template <class V, class... U>
  142|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(V&& target, U&&... args) const {
  143|       |            using ValueOfTargetType = decltype(Get(std::forward<V>(target)));
  144|       |
  145|       |            return __impl_CallOrGetAttribute(
  146|       |              // Check if the target attribute value is invocable
  147|       |              emp::is_invocable<ValueOfTargetType,
  148|       |                                decltype(std::forward<U>(args))...>{},
  149|       |              std::forward<V>(target), std::forward<U>(args)...);
  150|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  151|       |        } CallOrGetAttribute{};
  152|       |
  153|       |        // -- GetOrElse --
  154|       |        private:
  155|       |        /*_FORCE_COVER_START_*/template <typename Pack, typename M, typename D, typename... U>
  156|       |        /*_FORCE_COVER_START_*/static constexpr decltype(auto) __impl_MapOrElse(const std::true_type&,
  157|       |                                                         Pack&& pack, M&& map,
  158|       |                                                         D&&, U&&...) {
  159|       |          return std::forward<M>(map)(GetAttribute(std::forward<Pack>(pack)));
  160|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  161|       |
  162|       |        /*_FORCE_COVER_START_*/template <typename Pack, typename M, typename D, typename... U>
  163|       |        /*_FORCE_COVER_START_*/static constexpr decltype(auto) __impl_MapOrElse(const std::false_type&,
  164|       |                                                         Pack&&, M&&,
  165|       |                                                         D&& defaultFunction,
  166|       |                                                         U&&... args) {
  167|       |          return std::forward<D>(defaultFunction)(std::forward<U>(args)...);
  168|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  169|       |
  170|       |        public:
  171|       |        static constexpr struct map_or_else_t {
  172|       |          /*_FORCE_COVER_START_*/template <typename Pack, typename M, typename D, typename... U>
  173|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Pack&& pack, M&& map,
  174|       |                                              D&& defaultFunction,
  175|       |                                              U&&... args) const {
  176|       |            return __impl_MapOrElse(
  177|       |              has_attribute<std::decay_t<Pack>, attribute_t>{},
  178|       |              std::forward<Pack>(pack), std::forward<M>(map),
  179|       |              std::forward<D>(defaultFunction), std::forward<U>(args)...);
  180|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  181|       |        } MapOrElse{};
  182|       |
  183|       |        static constexpr struct get_attribute_or_else_t {
  184|       |          /*_FORCE_COVER_START_*/template <typename Pack, typename D, typename... U>
  185|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Pack&& pack, D&& defaultFunction,
  186|       |                                              U&&... args) const {
  187|       |            return MapOrElse(std::forward<Pack>(pack), GetAttribute,
  188|       |                             std::forward<D>(defaultFunction),
  189|       |                             std::forward<U>(args)...);
  190|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  191|       |        } GetAttributeOrElse{};
  192|       |
  193|       |        static constexpr struct get_or_else_t {
  194|       |          /*_FORCE_COVER_START_*/template <class Pack, class F, class... U>
  195|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Pack&& pack, F&& defaultFunction,
  196|       |                                              U&&... args) const {
  197|       |            return MapOrElse(std::forward<Pack>(pack), Get,
  198|       |                             std::forward<F>(defaultFunction),
  199|       |                             std::forward<U>(args)...);
  200|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  201|       |        } GetOrElse{};
  202|       |
  203|       |        private:
  204|       |        // Utility class used by GetOr which simply remembers and returns a
  205|       |        // value. @todo: when we switch to c++17, we can replace this with a
  206|       |        // constexpr closure
  207|       |        template <class D>
  208|       |        struct Default {
  209|       |          D value;
  210|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()() const {
  211|       |            return std::forward<D>(value);
  212|       |          }/*_FORCE_COVER_END_*/
  213|       |        };
  214|       |
  215|       |        public:
  216|       |        static constexpr struct get_or_t {
  217|       |          /*_FORCE_COVER_START_*/template <class Pack, class D>
  218|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Pack&& pack,
  219|       |                                              D&& defaultValue) const {
  220|       |            return GetOrElse(std::forward<Pack>(pack),
  221|       |                             Default<D&&>{std::forward<D>(defaultValue)});
  222|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  223|       |        } GetOr{};
  224|       |
  225|       |        private:
  226|       |        // Utility class used by GetOrGetIn which simply remembers a attribute
  227|       |        // pack.
  228|       |        template <typename...>
  229|       |        struct FallbackHandler;
  230|       |
  231|       |        template <typename Fallback>
  232|       |        struct FallbackHandler<Fallback> {
  233|       |          Fallback fallback;
  234|       |          /*_FORCE_COVER_START_*/constexpr FallbackHandler(Fallback fallback)
  235|       |            : fallback(std::forward<Fallback>(fallback)) {}/*_FORCE_COVER_END_*/
  236|       |
  237|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()() const {
  238|       |            return GetAttribute(std::forward<Fallback>(fallback));
  239|       |          }/*_FORCE_COVER_END_*/
  240|       |        };
  241|       |
  242|       |        template <typename Fallback0, typename Fallback1, typename... Fallbacks>
  243|       |        struct FallbackHandler<Fallback0, Fallback1, Fallbacks...> {
  244|       |          Fallback0 fallback;
  245|       |          FallbackHandler<Fallback1, Fallbacks...> fallbacks;
  246|       |          /*_FORCE_COVER_START_*/constexpr FallbackHandler(Fallback0&& fallback0,
  247|       |                                    Fallback1&& fallback1,
  248|       |                                    Fallbacks&&... fallbacks)
  249|       |            : fallback(std::forward<Fallback0>(fallback0)),
  250|       |              fallbacks(std::forward<Fallback1>(fallback1),
  251|       |                        std::forward<Fallbacks>(fallbacks)...) {}/*_FORCE_COVER_END_*/
  252|       |
  253|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()() && {
  254|       |            return GetAttributeOrElse(std::forward<Fallback0>(fallback),
  255|       |                                      std::move(fallbacks));
  256|       |          }/*_FORCE_COVER_END_*/
  257|       |        };
  258|       |
  259|       |        public:
  260|       |        static constexpr struct get_attribute_or_get_attribute_in_t {
  261|       |          /*_FORCE_COVER_START_*/template <class... Fallbacks>
  262|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Fallbacks&&... fallbacks) const {
  263|       |            return FallbackHandler<Fallbacks&&...>{
  264|       |              std::forward<Fallbacks>(fallbacks)...}();
  265|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  266|       |        } GetAttributeOrGetAttributeIn{};
  267|       |
  268|       |        static constexpr struct get_or_get_in_t {
  269|       |          /*_FORCE_COVER_START_*/template <class... Fallbacks>
  270|       |          /*_FORCE_COVER_START_*/constexpr decltype(auto) operator()(Fallbacks&&... fallbacks) const {
  271|       |            return Get(FallbackHandler<Fallbacks&&...>{
  272|       |              std::forward<Fallbacks>(fallbacks)...}());
  273|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  274|       |        } GetOrGetIn{};
  275|       |        static constexpr struct set_t {
  276|       |          /*_FORCE_COVER_START_*/template <class T, class V>
  277|       |          /*_FORCE_COVER_START_*/constexpr void operator()(value_t<T>& target, V&& value) const {
  278|       |            Get(target) = std::forward<V>(value);
  279|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  280|       |        } Set{};
  281|       |
  282|       |        static constexpr struct make_t {
  283|       |          /*_FORCE_COVER_START_*/template <class T>
  284|       |          /*_FORCE_COVER_START_*/constexpr value_t<std::decay_t<T>> operator()(T&& value) const {
  285|       |            return {std::forward<T>(value)};
  286|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  287|       |        } Make{};
  288|       |      };
  289|       |
  290|       |      template <typename Attr, template <typename> class Value>
  291|       |      constexpr typename AttrBase<Attr, Value>::get_attribute_t
  292|       |        AttrBase<Attr, Value>::GetAttribute;
  293|       |
  294|       |      template <typename Attr, template <typename> class Value>
  295|       |      constexpr
  296|       |        typename AttrBase<Attr, Value>::get_t AttrBase<Attr, Value>::Get;
  297|       |
  298|       |      template <typename Attr, template <typename> class Value>
  299|       |      constexpr typename AttrBase<Attr, Value>::call_or_get_attribute_t
  300|       |        AttrBase<Attr, Value>::CallOrGetAttribute;
  301|       |
  302|       |      template <typename Attr, template <typename> class Value>
  303|       |      constexpr typename AttrBase<Attr, Value>::map_or_else_t
  304|       |        AttrBase<Attr, Value>::MapOrElse;
  305|       |
  306|       |      template <typename Attr, template <typename> class Value>
  307|       |      constexpr typename AttrBase<Attr, Value>::get_attribute_or_else_t
  308|       |        AttrBase<Attr, Value>::GetAttributeOrElse;
  309|       |
  310|       |      template <typename Attr, template <typename> class Value>
  311|       |      constexpr typename AttrBase<Attr, Value>::get_or_else_t
  312|       |        AttrBase<Attr, Value>::GetOrElse;
  313|       |
  314|       |      template <typename Attr, template <typename> class Value>
  315|       |      constexpr
  316|       |        typename AttrBase<Attr, Value>::get_or_t AttrBase<Attr, Value>::GetOr;
  317|       |
  318|       |      template <typename Attr, template <typename> class Value>
  319|       |      constexpr
  320|       |        typename AttrBase<Attr, Value>::get_attribute_or_get_attribute_in_t
  321|       |          AttrBase<Attr, Value>::GetAttributeOrGetAttributeIn;
  322|       |
  323|       |      template <typename Attr, template <typename> class Value>
  324|       |      constexpr typename AttrBase<Attr, Value>::get_or_get_in_t
  325|       |        AttrBase<Attr, Value>::GetOrGetIn;
  326|       |
  327|       |      template <typename Attr, template <typename> class Value>
  328|       |      constexpr
  329|       |        typename AttrBase<Attr, Value>::set_t AttrBase<Attr, Value>::Set;
  330|       |
  331|       |      template <typename Attr, template <typename> class Value>
  332|       |      constexpr
  333|       |        typename AttrBase<Attr, Value>::make_t AttrBase<Attr, Value>::Make;
  334|       |
  335|       |    };  // namespace __impl_attr_base
  336|       |
  337|       |#define DEFINE_ATTR(NAME)                                                      \
  338|       |  template <class T>                                                           \
  339|       |  struct NAME##Value;                                                          \
  340|       |  constexpr struct NAME                                                        \
  341|       |    : emp::tools::__impl_attr_base::AttrBase<NAME, NAME##Value> {              \
  342|       |    static constexpr auto name = #NAME;                                        \
  343|       |    template <typename T>                                                      \
  344|       |    constexpr value_t<std::decay_t<T>> operator()(T&& value) const {           \
  345|       |      return {std::forward<T>(value)};                                         \
  346|       |    }                                                                          \
  347|       |  } NAME;                                                                      \
  348|       |  constexpr const char* NAME::name;                                            \
  349|       |  template <class T>                                                           \
  350|       |  struct NAME##Value : emp::tools::value_tag, NAME {                           \
  351|       |    private:                                                                   \
  352|       |    T value;                                                                   \
  353|       |                                                                               \
  354|       |    public:                                                                    \
  355|       |    static constexpr auto name = #NAME;                                        \
  356|       |    using attribute_t = struct NAME;                                           \
  357|       |    using attributes_t = emp::tools::Attrs<NAME##Value<T>>;                    \
  358|       |    using value_t = T;                                                         \
  359|       |    NAME##Value() = delete;                                                    \
  360|       |    constexpr NAME##Value(const T& value) : value(value) {}                    \
  361|       |    constexpr NAME##Value(T&& value) : value(std::move(value)) {}              \
  362|       |    template <typename U = T>                                                  \
  363|       |    constexpr NAME##Value(const NAME##Value<U>& other) : value(*other) {}      \
  364|       |    template <typename U = T>                                                  \
  365|       |    constexpr NAME##Value(NAME##Value<U>&& other)                              \
  366|       |      : value(*std::move(other)) {}                                            \
  367|       |    constexpr NAME##Value& operator=(const T& value) {                         \
  368|       |      /* Don't check for self assignment, and assume that value will handle it \
  369|       |       * correcly */                                                           \
  370|       |      this->value = value;                                                     \
  371|       |      return *this;                                                            \
  372|       |    }                                                                          \
  373|       |    constexpr NAME##Value& operator=(T&& value) {                              \
  374|       |      /* Assume value handles self assigment correctly */                      \
  375|       |      this->value = std::move(value);                                          \
  376|       |      return *this;                                                            \
  377|       |    }                                                                          \
  378|       |    template <typename U = T>                                                  \
  379|       |    constexpr NAME##Value& operator=(const NAME##Value<U>& other) {            \
  380|       |      /* Assume value handles self assigment correctly */                      \
  381|       |      value = *other;                                                          \
  382|       |      return *this;                                                            \
  383|       |    }                                                                          \
  384|       |    template <typename U = T>                                                  \
  385|       |    constexpr NAME##Value& operator=(NAME##Value<U>&& other) {                 \
  386|       |      /* Assume value handles self assigment correctly */                      \
  387|       |      value = *std::move(other);                                               \
  388|       |      return *this;                                                            \
  389|       |    }                                                                          \
  390|       |    constexpr const T& Get##NAME() const & { return value; }                   \
  391|       |    constexpr const T&& Get##NAME() const && { return std::move(value); }      \
  392|       |    constexpr const T& Get() const & { return value; }                         \
  393|       |    constexpr const T&& Get() const && { return std::move(value); }            \
  394|       |    template <typename U = T>                                                  \
  395|       |    constexpr const NAME##Value& Set##NAME(U&& value) {                        \
  396|       |      this->value = std::forward<U>(value);                                    \
  397|       |      return *this;                                                            \
  398|       |    }                                                                          \
  399|       |    template <typename U = T>                                                  \
  400|       |    constexpr const NAME##Value& Set(U&& value) {                              \
  401|       |      return Set##NAME(std::forward<U>(value));                                \
  402|       |    }                                                                          \
  403|       |    template <typename U = T>                                                  \
  404|       |    constexpr const NAME##Value& Set(const NAME##Value<U>& value) {            \
  405|       |      return Set##NAME(*value);                                                \
  406|       |    }                                                                          \
  407|       |    template <typename U = T>                                                  \
  408|       |    constexpr const NAME##Value& Set(NAME##Value<U>&& value) {                 \
  409|       |      return Set##NAME(*std::move(value));                                     \
  410|       |    }                                                                          \
  411|       |    constexpr T& operator*() & { return value; }                               \
  412|       |    constexpr T&& operator*() && { return std::move(value); }                  \
  413|       |    constexpr const T& operator*() const & { return value; }                   \
  414|       |    constexpr const T&& operator*() const && { return std::move(value); }      \
  415|       |    template <typename M>                                                      \
  416|       |    constexpr auto Map(M&& map) & {                                            \
  417|       |      return attribute_t::Make(std::forward<M>(value));                        \
  418|       |    }                                                                          \
  419|       |    template <typename M>                                                      \
  420|       |    constexpr auto Map(M&& map) const & {                                      \
  421|       |      return attribute_t::Make(std::forward<M>(value));                        \
  422|       |    }                                                                          \
  423|       |    template <typename M>                                                      \
  424|       |    constexpr auto Map(M&& map) && {                                           \
  425|       |      return attribute_t::Make(std::forward<M>(std::move(value)));             \
  426|       |    }                                                                          \
  427|       |    template <typename M>                                                      \
  428|       |    constexpr auto Map(M&& map) const && {                                     \
  429|       |      return attribute_t::Make(std::forward<M>(std::move(value)));             \
  430|       |    }                                                                          \
  431|       |  };                                                                           \
  432|       |  template <typename T>                                                        \
  433|       |  constexpr const char* NAME##Value<T>::name;                                  \
  434|       |  template <class A, class B>                                                  \
  435|       |  constexpr bool operator==(const NAME##Value<A>& a,                           \
  436|       |                            const NAME##Value<B>& b) {                         \
  437|       |    return NAME::Get(a) == NAME::Get(b);                                       \
  438|       |  }                                                                            \
  439|       |  template <class T>                                                           \
  440|       |  std::ostream& operator<<(std::ostream& out, const NAME##Value<T>& value) {   \
  441|       |    return out << #NAME "(" << value.Get() << ")";                             \
  442|       |  }
  443|       |
  444|       |    namespace __attrs_impl {
  445|       |
  446|       |      template <class... T>
  447|       |      class AttrsParent : public T... {
  448|       |        protected:
  449|       |        struct args_tag {};
  450|       |        struct copy_tag {};
  451|       |        struct move_tag {};
  452|       |
  453|       |        template <class U>
  454|       |        struct __attrs_impl_constructor_detector {
  455|       |          private:
  456|       |          /*_FORCE_COVER_START_*/template <class... X>
  457|       |          /*_FORCE_COVER_START_*/static copy_tag Detect(const Attrs<X...>&) {
  458|       |            return {};
  459|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
  460|       |
  461|       |          /*_FORCE_COVER_START_*/template <class... X>
  462|       |          /*_FORCE_COVER_START_*/static move_tag Detect(Attrs<X...>&&) {
  463|       |            return {};
  464|       |          }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/;
  465|       |
  466|       |          /*_FORCE_COVER_START_*/static args_tag Detect(...) { return {}; }/*_FORCE_COVER_END_*/
  467|       |
  468|       |          public:
  469|       |          using type = decltype(Detect(std::declval<U>()));
  470|       |        };
  471|       |
  472|       |        template <class U>
  473|       |        using constructor_detector =
  474|       |          typename __attrs_impl_constructor_detector<U>::type;
  475|       |
  476|       |        /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/constexpr AttrsParent() : T{}... {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  477|       |
  478|       |        /*_FORCE_COVER_START_*/template <class... U>
  479|       |        /*_FORCE_COVER_START_*/constexpr AttrsParent(const args_tag&, U&&... args)
  480|       |          : T{std::forward<U>(args)}... {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  481|       |
  482|       |        /*_FORCE_COVER_START_*/template <class... U>
  483|       |        /*_FORCE_COVER_START_*/constexpr AttrsParent(const copy_tag&, const Attrs<U...>& other)
  484|       |          : T{T::attribute_t::Get(other)}... {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  485|       |
  486|       |        /*_FORCE_COVER_START_*/template <class... U>
  487|       |        /*_FORCE_COVER_START_*/constexpr AttrsParent(const move_tag&, Attrs<U...>&& other)
  488|       |          : T{T::attribute_t::Get(std::move(other))}... {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  489|       |      };
  490|       |
  491|       |      // This struct exists so that we can pass around Attrs<U...> without it
  492|       |      // taking up any memory or having any side effects from construction.
  493|       |      template <class>
  494|       |      struct wrapper {};
  495|       |
  496|       |    }  // namespace __attrs_impl
  497|       |
  498|       |    template <typename... T>
  499|       |    constexpr Attrs<std::decay_t<T>...> MakeAttrs(T&&... props);
  500|       |
  501|       |    namespace __impl_attrs_reduce {
  502|       |      template <typename>
  503|       |      struct AttrsIter;
  504|       |
  505|       |      template <>
  506|       |      struct AttrsIter<__impl_variadics_type_traits::pack<>> {
  507|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  508|       |        static constexpr I&& MergeReduce(I&& init, R&& reducer, A&&... attrs) {
  509|       |          return std::forward<I>(init);
  510|       |        }/*_FORCE_COVER_END_*/
  511|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  512|       |        static constexpr I&& Reduce(I&& init, R&& reducer, A&&... attrs) {
  513|       |          return std::forward<I>(init);
  514|       |        }/*_FORCE_COVER_END_*/
  515|       |
  516|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  517|       |        static constexpr void MergeForeach(F&& callback, A&&... attrs) {}/*_FORCE_COVER_END_*/
  518|       |
  519|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  520|       |        static constexpr void Foreach(F&& callback, A&&... attrs) {}/*_FORCE_COVER_END_*/
  521|       |      };
  522|       |
  523|       |      template <typename U>
  524|       |      struct AttrsIter<__impl_variadics_type_traits::pack<U>> {
  525|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  526|       |        static constexpr auto MergeReduce(I&& init, R&& reducer, A&&... attrs) {
  527|       |          return std::forward<R>(reducer)(
  528|       |            std::forward<I>(init), U::attribute_t::GetAttributeOrGetAttributeIn(
  529|       |                                     std::forward<A>(attrs)...));
  530|       |        }/*_FORCE_COVER_END_*/
  531|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  532|       |        static constexpr auto Reduce(I&& init, R&& reducer, A&&... attrs) {
  533|       |          return std::forward<R>(reducer)(
  534|       |            std::forward<I>(init),
  535|       |            U::attribute_t::GetAttribute(std::forward<A>(attrs))...);
  536|       |        }/*_FORCE_COVER_END_*/
  537|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  538|       |        static constexpr void MergeForeach(F&& callback, A&&... attrs) {
  539|       |          std::forward<F>(callback)(
  540|       |            U::attribute_t::GetAttributeOrGetAttributeIn(
  541|       |              std::forward<A>(attrs)...));
  542|       |        }/*_FORCE_COVER_END_*/
  543|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  544|       |        static constexpr void Foreach(F&& callback, A&&... attrs) {
  545|       |          std::forward<F>(callback)(
  546|       |            U::attribute_t::GetAttribute(std::forward<A>(attrs))...);
  547|       |        }/*_FORCE_COVER_END_*/
  548|       |      };
  549|       |
  550|       |      template <typename U0, typename U1, typename... U>
  551|       |      struct AttrsIter<__impl_variadics_type_traits::pack<U0, U1, U...>> {
  552|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  553|       |        static constexpr auto MergeReduce(I&& init, R&& reducer, A&&... attrs) {
  554|       |          using new_init_t =
  555|       |            decltype(reducer(std::forward<I>(init),
  556|       |                             U0::attribute_t::GetAttributeOrGetAttributeIn(
  557|       |                               std::forward<A>(attrs)...)));
  558|       |
  559|       |          return AttrsIter<__impl_variadics_type_traits::pack<U1, U...>>::
  560|       |            MergeReduce(std::forward<new_init_t>(
  561|       |                          reducer(std::forward<I>(init),
  562|       |                                  U0::attribute_t::GetAttributeOrGetAttributeIn(
  563|       |                                    std::forward<A>(attrs)...))),
  564|       |                        std::forward<R>(reducer), std::forward<A>(attrs)...);
  565|       |        }/*_FORCE_COVER_END_*/
  566|       |
  567|       |        /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  568|       |        static constexpr auto Reduce(I&& init, R&& reducer, A&&... attrs) {
  569|       |          using new_init_t = decltype(
  570|       |            reducer(std::forward<I>(init),
  571|       |                    U0::attribute_t::GetAttribute(std::forward<A>(attrs))...));
  572|       |
  573|       |          return AttrsIter<__impl_variadics_type_traits::pack<U1, U...>>::
  574|       |            Reduce(std::forward<new_init_t>(reducer(
  575|       |                     std::forward<I>(init),
  576|       |                     U0::attribute_t::GetAttribute(std::forward<A>(attrs))...)),
  577|       |                   std::forward<R>(reducer), std::forward<A>(attrs)...);
  578|       |        }/*_FORCE_COVER_END_*/
  579|       |
  580|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  581|       |        static constexpr void MergeForeach(F&& callback, A&&... attrs) {
  582|       |          callback(U0::attribute_t::GetAttributeOrGetAttributeIn(
  583|       |            std::forward<A>(attrs)...));
  584|       |
  585|       |          return AttrsIter<__impl_variadics_type_traits::pack<U1, U...>>::
  586|       |            MergeForeach(std::forward<F>(callback), std::forward<A>(attrs)...);
  587|       |        }/*_FORCE_COVER_END_*/
  588|       |
  589|       |        /*_FORCE_COVER_START_*/template <typename F, typename... A>
  590|       |        static constexpr void Foreach(F&& callback, A&&... attrs) {
  591|       |          callback(U0::attribute_t::GetAttribute(std::forward<A>(attrs))...);
  592|       |
  593|       |          return AttrsIter<__impl_variadics_type_traits::pack<U1, U...>>::
  594|       |            Foreach(std::forward<F>(callback), std::forward<A>(attrs)...);
  595|       |        }/*_FORCE_COVER_END_*/
  596|       |      };
  597|       |
  598|       |    }  // namespace __impl_attrs_reduce
  599|       |
  600|       |    /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  601|       |    constexpr auto MergeReduce(I&& init, R&& reducer, A&&... attrs) {
  602|       |      return __impl_attrs_reduce::AttrsIter<
  603|       |        variadic_union_t<is_same_attribute,
  604|       |                         __impl_variadics_type_traits::ToPackType<
  605|       |                           Attrs, typename std::decay_t<A>::attributes_t>...>>::
  606|       |        MergeReduce(std::forward<I>(init), std::forward<R>(reducer),
  607|       |                    std::forward<A>(attrs)...);
  608|       |    }/*_FORCE_COVER_END_*/
  609|       |
  610|       |    /*_FORCE_COVER_START_*/template <typename I, typename R, typename... A>
  611|       |    constexpr auto Reduce(I&& init, R&& reducer, A&&... attrs) {
  612|       |      return __impl_attrs_reduce::AttrsIter<variadic_intersection_t<
  613|       |        is_same_attribute,
  614|       |        __impl_variadics_type_traits::ToPackType<
  615|       |          Attrs, typename std::decay_t<A>::attributes_t>...>>::
  616|       |        Reduce(std::forward<I>(init), std::forward<R>(reducer),
  617|       |               std::forward<A>(attrs)...);
  618|       |    }/*_FORCE_COVER_END_*/
  619|       |
  620|       |    /*_FORCE_COVER_START_*/template <typename F, typename... A>
  621|       |    constexpr void MergeForeach(F&& callback, A&&... attrs) {
  622|       |      return __impl_attrs_reduce::AttrsIter<
  623|       |        variadic_union_t<is_same_attribute,
  624|       |                         __impl_variadics_type_traits::ToPackType<
  625|       |                           Attrs, typename std::decay_t<A>::attributes_t>...>>::
  626|       |        MergeForeach(std::forward<F>(callback), std::forward<A>(attrs)...);
  627|       |    }/*_FORCE_COVER_END_*/
  628|       |    /*_FORCE_COVER_START_*/template <typename F, typename... A>
  629|       |    constexpr void Foreach(F&& callback, A&&... attrs) {
  630|       |      return __impl_attrs_reduce::AttrsIter<variadic_intersection_t<
  631|       |        is_same_attribute,
  632|       |        __impl_variadics_type_traits::ToPackType<
  633|       |          Attrs, typename std::decay_t<A>::attributes_t>...>>::
  634|       |        Foreach(std::forward<F>(callback), std::forward<A>(attrs)...);
  635|       |    }/*_FORCE_COVER_END_*/
  636|       |
  637|       |    template <typename... T>
  638|       |    class Attrs : public __attrs_impl::AttrsParent<T...> {
  639|       |      public:
  640|       |      using attributes_t = Attrs;
  641|       |      using pack_t = TypePack<T...>;
  642|       |
  643|       |      /*_FORCE_COVER_START_*//*_FORCE_COVER_START_*/constexpr Attrs() : __attrs_impl::AttrsParent<T...>{} {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  644|       |
  645|       |      // This is one of the really nasty parts. The problem is that we really
  646|       |      // want two constructors
  647|       |      //
  648|       |      // (1) template<class... U> Attrs(U&& ... MakeAttrs),
  649|       |      // which initializes all the members of the attribute pack and
  650|       |      //
  651|       |      // (2) template<class... U> Attrs(const Attrs<U...>& other),
  652|       |      // which copies the data out of the other attribute pack and into this
  653|       |      // one.
  654|       |      //
  655|       |      // Sadly, C++ can't tell the difference between these two signatures,
  656|       |      // and will only Call the first because of how c++ decides the order to
  657|       |      // resolve overloads in. In ordered to ensure that the correct
  658|       |      // constructor is called, we calculate which constructor should be
  659|       |      // called, and then pass the result into AttrsParent, which has
  660|       |      // unambiguously overloaded constructors which handle each case
  661|       |      /*_FORCE_COVER_START_*/template <class U0, class... U>
  662|       |      /*_FORCE_COVER_START_*/constexpr Attrs(U0&& arg, U&&... args)
  663|       |        : __attrs_impl::AttrsParent<T...>(
  664|       |            // This will resolve to one of several marker structs which will
  665|       |            // select the correct constructor
  666|       |            typename __attrs_impl::AttrsParent<
  667|       |              T...>::template constructor_detector<U0>{},
  668|       |            // The arguments are then forwarded as normal
  669|       |            std::forward<U0>(arg), std::forward<U>(args)...) {}/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  670|       |
  671|       |      private:
  672|       |      constexpr static struct __impl_AssignOp_asssigner_t {
  673|       |        /*_FORCE_COVER_START_*/template <typename T1, typename T2>
  674|       |        /*_FORCE_COVER_START_*/constexpr void operator()(T1& to, T2&& from) const {
  675|       |          to = std::forward<T2>(from);
  676|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  677|       |      } __impl_AssignOp_asssigner{};
  678|       |
  679|       |      public:
  680|       |      /*_FORCE_COVER_START_*/template <typename F>
  681|       |      /*_FORCE_COVER_START_*/Attrs& operator=(F&& from) {
  682|       |        emp::tools::Foreach(__impl_AssignOp_asssigner, *this,
  683|       |                            std ::forward<F>(from));
  684|       |
  685|       |        return *this;
  686|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  687|       |
  688|       |      private:
  689|       |      template <bool Last, typename A>
  690|       |      struct GetAttr;
  691|       |      template <typename A>
  692|       |      struct GetAttr<false, A> {
  693|       |        /*_FORCE_COVER_START_*/template <typename S, typename... U>
  694|       |        /*_FORCE_COVER_START_*/static constexpr decltype(auto) Get(S&& Self, U&&... args) {
  695|       |          using attribute_t = typename A::attribute_t;
  696|       |          return attribute_t::CallOrGetAttribute(std::forward<S>(Self),
  697|       |                                                 args...);
  698|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  699|       |      };
  700|       |
  701|       |      template <typename A>
  702|       |      struct GetAttr<true, A> {
  703|       |        /*_FORCE_COVER_START_*/template <typename S, typename... U>
  704|       |        /*_FORCE_COVER_START_*/static constexpr decltype(auto) Get(S&& Self, U&&... args) {
  705|       |          using attribute_t = typename A::attribute_t;
  706|       |          return attribute_t::CallOrGetAttribute(std::forward<S>(Self),
  707|       |                                                 std::forward<U>(args)...);
  708|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  709|       |      };
  710|       |
  711|       |      /*_FORCE_COVER_START_*/template <typename S, typename... U>
  712|       |      /*_FORCE_COVER_START_*/static constexpr auto Call(S&& Self, U&&... args) {
  713|       |        constexpr size_t last = sizeof...(T) - 1;
  714|       |        return MakeAttrs(
  715|       |          GetAttr<variadic_index_of_v<T, Attrs> == last,
  716|       |                  T>::template Get<S, U...>(std::forward<S>(Self),
  717|       |                                            std::forward<U>(args)...)...);
  718|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  719|       |
  720|       |      public:
  721|       |      /// Provide a call operator for attribute packs. This will attempt to call
  722|       |      /// each member of the attribute pack with the given arguments, and maps
  723|       |      /// the result of that call into a new parameter pack as the same
  724|       |      /// attribute. If one of the members of the pack cannot be called with the
  725|       |      /// given pack, then it is put into the new pack unchanged. Mostly, this
  726|       |      /// is meant to allow the opengl plotting library to do mapping operations
  727|       |      /*_FORCE_COVER_START_*/template <class... U>
  728|       |      /*_FORCE_COVER_START_*/constexpr auto operator()(U&&... args) & {
  729|       |        return Call(*this, std::forward<U>(args)...);
  730|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  731|       |
  732|       |      /*_FORCE_COVER_START_*/template <class... U>
  733|       |      /*_FORCE_COVER_START_*/constexpr auto operator()(U&&... args) const & {
  734|       |        return Call(*this, std::forward<U>(args)...);
  735|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  736|       |
  737|       |      /*_FORCE_COVER_START_*/template <class... U>
  738|       |      /*_FORCE_COVER_START_*/constexpr auto operator()(U&&... args) && {
  739|       |        return Call(std::move(*this), std::forward<U>(args)...);
  740|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  741|       |
  742|       |      /*_FORCE_COVER_START_*/template <class... U>
  743|       |      /*_FORCE_COVER_START_*/constexpr auto operator()(U&&... args) const && {
  744|       |        return Call(std::move(*this), std::forward<U>(args)...);
  745|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  746|       |
  747|       |      private:
  748|       |      struct eq_reducer {
  749|       |        /*_FORCE_COVER_START_*/template <typename A, typename B>
  750|       |        /*_FORCE_COVER_START_*/constexpr bool operator()(bool init, A&& a, B&& b) const {
  751|       |          return init && (std::forward<A>(a).Get() == std::forward<B>(b).Get());
  752|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  753|       |      };
  754|       |
  755|       |      public:
  756|       |      /// Attribute packs support equals and not equals, but are not
  757|       |      /// orderable, as the members are not considered to be ordered from the
  758|       |      /// user's perspective.
  759|       |      /*_FORCE_COVER_START_*/template <class... U>
  760|       |      /*_FORCE_COVER_START_*/constexpr bool operator==(const Attrs<U...>& other) const {
  761|       |        // @todo: this needs more carefull checking, as it will have strange
  762|       |        // behavior when the other attribute pack has different types
  763|       |        return tools::Reduce(true, eq_reducer{}, *this, other);
  764|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  765|       |
  766|       |      private:
  767|       |      template <typename F>
  768|       |      struct __impl_reduce_from_reduce_value {
  769|       |        F callback;
  770|       |        /*_FORCE_COVER_START_*/constexpr __impl_reduce_from_reduce_value(F callback)
  771|       |          : callback(std::forward<F>(callback)) {}/*_FORCE_COVER_END_*/
  772|       |        /*_FORCE_COVER_START_*/template <typename I, typename U>
  773|       |        /*_FORCE_COVER_START_*/constexpr auto operator()(I&& init, U&& value) {
  774|       |          return std::forward<F>(callback)(value.name, std::forward<I>(init),
  775|       |                                           *std::forward<U>(value));
  776|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  777|       |      };
  778|       |
  779|       |      public:
  780|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  781|       |      /*_FORCE_COVER_START_*/constexpr auto AttributeReduce(I&& init, F&& callback) & {
  782|       |        return emp::tools::Reduce(std::forward<I>(init),
  783|       |                                  std::forward<F>(callback), *this);
  784|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  785|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  786|       |      /*_FORCE_COVER_START_*/constexpr auto AttributeReduce(I&& init, F&& callback) const & {
  787|       |        return emp::tools::Reduce(std::forward<I>(init),
  788|       |                                  std::forward<F>(callback), *this);
  789|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  790|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  791|       |      /*_FORCE_COVER_START_*/constexpr auto AttributeReduce(I&& init, F&& callback) && {
  792|       |        return emp::tools::Reduce(std::forward<I>(init),
  793|       |                                  std::forward<F>(callback), std::move(*this));
  794|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  795|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  796|       |      /*_FORCE_COVER_START_*/constexpr auto AttributeReduce(I&& init, F&& callback) const && {
  797|       |        return emp::tools::Reduce(std::forward<I>(init),
  798|       |                                  std::forward<F>(callback), std::move(*this));
  799|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  800|       |
  801|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  802|       |      /*_FORCE_COVER_START_*/constexpr auto Reduce(I&& init, F&& callback) {
  803|       |        return AttributeReduce(
  804|       |          std::forward<I>(init),
  805|       |          __impl_reduce_from_reduce_value<F&&>{std::forward<F>(callback)});
  806|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  807|       |      /*_FORCE_COVER_START_*/template <typename I, typename F>
  808|       |      /*_FORCE_COVER_START_*/constexpr auto Reduce(I&& init, F&& callback) const {
  809|       |        return AttributeReduce(
  810|       |          std::forward<I>(init),
  811|       |          __impl_reduce_from_reduce_value<F&&>{std::forward<F>(callback)});
  812|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  813|       |
  814|       |      private:
  815|       |      template <typename F>
  816|       |      struct __impl_foreach_from_foreach_value {
  817|       |        F callback;
  818|       |        /*_FORCE_COVER_START_*/constexpr __impl_foreach_from_foreach_value(F callback)
  819|       |          : callback(std::forward<F>(callback)) {}/*_FORCE_COVER_END_*/
  820|       |        /*_FORCE_COVER_START_*/template <typename U>
  821|       |        /*_FORCE_COVER_START_*/constexpr void operator()(U&& value) {
  822|       |          std::forward<F>(callback)(value.name, *std::forward<U>(value));
  823|       |        }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  824|       |      };
  825|       |
  826|       |      public:
  827|       |      /*_FORCE_COVER_START_*/template <typename F>
  828|       |      /*_FORCE_COVER_START_*/constexpr void AttributeForeach(F&& callback) & {
  829|       |        tools::Foreach(std::forward<F>(callback), *this);
  830|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  831|       |
  832|       |      /*_FORCE_COVER_START_*/template <typename F>
  833|       |      /*_FORCE_COVER_START_*/constexpr void AttributeForeach(F&& callback) const & {
  834|       |        tools::Foreach(std::forward<F>(callback), *this);
  835|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  836|       |
  837|       |      /*_FORCE_COVER_START_*/template <typename F>
  838|       |      /*_FORCE_COVER_START_*/constexpr void AttributeForeach(F&& callback) && {
  839|       |        tools::Foreach(std::forward<F>(callback), std::move(*this));
  840|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  841|       |
  842|       |      /*_FORCE_COVER_START_*/template <typename F>
  843|       |      /*_FORCE_COVER_START_*/constexpr void AttributeForeach(F&& callback) const && {
  844|       |        tools::Foreach(std::forward<F>(callback), std::move(*this));
  845|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  846|       |
  847|       |      /*_FORCE_COVER_START_*/template <typename F>
  848|       |      /*_FORCE_COVER_START_*/constexpr void Foreach(F&& callback) {
  849|       |        AttributeForeach(
  850|       |          __impl_foreach_from_foreach_value<decltype(
  851|       |            std::forward<F>(callback))>{std::forward<F>(callback)});
  852|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  853|       |
  854|       |      /*_FORCE_COVER_START_*/template <typename F>
  855|       |      /*_FORCE_COVER_START_*/constexpr void Foreach(F&& callback) const {
  856|       |        AttributeForeach(
  857|       |          __impl_foreach_from_foreach_value<decltype(
  858|       |            std::forward<F>(callback))>{std::forward<F>(callback)});
  859|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  860|       |
  861|       |      private:
  862|       |      /*_FORCE_COVER_START_*/template <typename S, typename U>
  863|       |      /*_FORCE_COVER_START_*/constexpr static Attrs<T..., std::decay_t<U>> __impl_SetAttribute(
  864|       |        const std::false_type& has_attr, S&& self, U&& attribute) {
  865|       |        return MakeAttrs(T::attribute_t::GetAttribute(std::forward<S>(self))...,
  866|       |                         std::forward<U>(attribute));
  867|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  868|       |      /*_FORCE_COVER_START_*/template <typename S, typename U>
  869|       |      /*_FORCE_COVER_START_*/constexpr static auto __impl_SetAttribute(const std::true_type& has_attr,
  870|       |                                                S&& self, U&& attribute) {
  871|       |        return MakeAttrs(T::attribute_t::GetAttributeOrGetAttributeIn(
  872|       |          std::forward<S>(self), std::forward<U>(attribute))...);
  873|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  874|       |
  875|       |      /*_FORCE_COVER_START_*/template <typename S, typename U>
  876|       |      /*_FORCE_COVER_START_*/constexpr static auto __impl_SetAttribute(S&& self, U&& attribute) {
  877|       |        return __impl_SetAttribute(
  878|       |          has_attribute<S, typename std::decay_t<U>::attribute_t>{},
  879|       |          std::forward<S>(self), std::forward<U>(attribute));
  880|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  881|       |
  882|       |      public:
  883|       |      /*_FORCE_COVER_START_*/template <typename U>
  884|       |      /*_FORCE_COVER_START_*/constexpr auto SetAttribute(U&& attribute) & {
  885|       |        return __impl_SetAttribute(*this, std::forward<U>(attribute));
  886|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  887|       |
  888|       |      /*_FORCE_COVER_START_*/template <typename U>
  889|       |      /*_FORCE_COVER_START_*/constexpr auto SetAttribute(U&& attribute) const & {
  890|       |        return __impl_SetAttribute(*this, std::forward<U>(attribute));
  891|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  892|       |
  893|       |      /*_FORCE_COVER_START_*/template <typename U>
  894|       |      /*_FORCE_COVER_START_*/constexpr auto SetAttribute(U&& attribute) && {
  895|       |        return __impl_SetAttribute(std::move(*this),
  896|       |                                   std::forward<U>(attribute));
  897|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  898|       |
  899|       |      /*_FORCE_COVER_START_*/template <typename U>
  900|       |      /*_FORCE_COVER_START_*/constexpr auto SetAttribute(U&& attribute) const && {
  901|       |        return __impl_SetAttribute(std::move(*this),
  902|       |                                   std::forward<U>(attribute));
  903|       |      }/*_FORCE_COVER_END_*//*_FORCE_COVER_END_*/
  904|       |    };
  905|       |
  906|       |    template <typename... T>
  907|       |    constexpr typename Attrs<T...>::__impl_AssignOp_asssigner_t
  908|       |      Attrs<T...>::__impl_AssignOp_asssigner;
  909|       |
  910|       |    ///  An alternative syntax for creating attribute packs. Takes any number
  911|       |    ///  of attributes and returns a pack containing each of those attributes.
  912|       |    /*_FORCE_COVER_START_*/template <class... T>
  913|       |    constexpr Attrs<std::decay_t<T>...> MakeAttrs(T&&... props) {
  914|       |      return {std::forward<T>(props)...};
  915|       |    }/*_FORCE_COVER_END_*/;
  916|       |
  917|       |    namespace __impl_attrs_merge {
  918|       |      constexpr struct {
  919|       |        /*_FORCE_COVER_START_*/template <typename I, typename A>
  920|       |        constexpr auto operator()(I&& init, A&& next) const {
  921|       |          return std::forward<I>(init).SetAttribute(std::forward<A>(next));
  922|       |        }/*_FORCE_COVER_END_*/
  923|       |      } attrs_merge{};
  924|       |    }  // namespace __impl_attrs_merge
  925|       |
  926|       |    /// Creates a new attribute pack which has all the attributes of this
  927|       |    /// pack and another pack. Values will be taken from other other pack
  928|       |    /// preferentially.
  929|       |    /*_FORCE_COVER_START_*/template <typename... U>
  930|       |    constexpr auto Merge(U&&... packs)
  931|       |      // This hint is required by some older compilers
  932|       |      -> decltype(MergeReduce(Attrs<>{}, __impl_attrs_merge::attrs_merge,
  933|       |                              std::forward<U>(packs)...)) {
  934|       |      return MergeReduce(Attrs<>{}, __impl_attrs_merge::attrs_merge,
  935|       |                         std::forward<U>(packs)...);
  936|       |    }/*_FORCE_COVER_END_*/
  937|       |
  938|       |    namespace __attrs_impl {
  939|       |      template <class...>
  940|       |      struct print_attrs_tag {};
  941|       |
  942|       |      /*_FORCE_COVER_START_*/template <class... T, class H>
  943|       |      void PrintAttrs(std::ostream& out, const Attrs<T...>& attrs,
  944|       |                      const print_attrs_tag<H>&) {
  945|       |        out << '"' << H::name << "\": " << H::attribute_t::Get(attrs);
  946|       |      }/*_FORCE_COVER_END_*/
  947|       |      /*_FORCE_COVER_START_*/template <class... T, class H0, class H1, class... U>
  948|       |      void PrintAttrs(std::ostream& out, const Attrs<T...>& attrs,
  949|       |                      const print_attrs_tag<H0, H1, U...>&) {
  950|       |        out << '"' << H0::name << "\": " << H0::attribute_t::Get(attrs) << ", ";
  951|       |        PrintAttrs(out, attrs, print_attrs_tag<H1, U...>{});
  952|       |      }/*_FORCE_COVER_END_*/
  953|       |    }  // namespace __attrs_impl
  954|       |
  955|       |    /*_FORCE_COVER_START_*/template <class H, class... T>
  956|       |    std::ostream& operator<<(std::ostream& out, const Attrs<H, T...>& attrs) {
  957|       |      out << "{ ";
  958|       |      __attrs_impl::PrintAttrs(out, attrs,
  959|       |                               __attrs_impl::print_attrs_tag<H, T...>{});
  960|       |      return out << " }";
  961|       |    }/*_FORCE_COVER_END_*/
  962|       |
  963|      0|    std::ostream& operator<<(std::ostream& out, const Attrs<>& attrs) {
  964|      0|      return out << "{ }";
  965|      0|    }
  966|       |  }  // namespace tools
  967|       |}  // namespace emp
  968|       |
  969|       |#endif  // EMP_PLOT_EMP
  970|       |

/home/emily/repos/Empirical_Tests/source/tools/bitset_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  bitset_utils.h
    7|       | *  @brief A set of simple functions to manipulate bitsets.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_BITSET_UTILS_H
   12|       |#define EMP_BITSET_UTILS_H
   13|       |
   14|       |#include "functions.h"
   15|       |
   16|       |namespace emp {
   17|       |
   18|       |  /// Create a series of a specified number of ones (at compile time) in a uint.
   19|       |  /*_FORCE_COVER_START_*/template <int NUM_BITS>
   20|       |  constexpr uint32_t UIntMaskFirst() { return (UIntMaskFirst<NUM_BITS-1> << 1) | 1; }/*_FORCE_COVER_END_*/
   21|       |
   22|       |  /// Create an empty bit mask (all zeros)
   23|       |  template <>
   24|      0|  constexpr uint32_t UIntMaskFirst<0>() { return 0; }
   25|       |
   26|       |  /// How many bits are set to one in each possible byte?
   27|       |  constexpr size_t ByteCount[256] = {
   28|       |    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
   29|       |    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   30|       |    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   31|       |    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   32|       |    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
   33|       |    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   34|       |    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
   35|       |    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
   36|       |  };
   37|       |
   38|       |  /// Count the number of bits in a 64-bit unsigned integer.
   39|      0|  inline constexpr size_t count_bits(uint64_t val) {
   40|      0|    return
   41|      0|      ByteCount[  val >> 56         ] +
   42|      0|      ByteCount[ (val >> 48) & 0xFF ] +
   43|      0|      ByteCount[ (val >> 40) & 0xFF ] +
   44|      0|      ByteCount[ (val >> 32) & 0xFF ] +
   45|      0|      ByteCount[ (val >> 24) & 0xFF ] +
   46|      0|      ByteCount[ (val >> 16) & 0xFF ] +
   47|      0|      ByteCount[ (val >>  8) & 0xFF ] +
   48|      0|      ByteCount[  val        & 0xFF ];
   49|      0|  }
   50|       |
   51|       |  /// Count the number of bits in a 32-bit unsigned integer.
   52|      3|  inline constexpr size_t count_bits(uint32_t val) {
   53|      3|    return
   54|      3|      ByteCount[  val >> 24         ] +
   55|      3|      ByteCount[ (val >> 16) & 0xFF ] +
   56|      3|      ByteCount[ (val >>  8) & 0xFF ] +
   57|      3|      ByteCount[  val        & 0xFF ];
   58|      3|  }
   59|       |
   60|       |  /// Return the position of the first one bit (in a 64-bit unsigned int)
   61|      0|  inline constexpr size_t find_bit(const uint64_t & val) { return count_bits( (~val) & (val-1) ); }
   62|       |
   63|       |  /// Return the position of the first one bit (in a 32-bit unsigned int)
   64|      3|  inline constexpr size_t find_bit(const uint32_t & val) { return count_bits( (~val) & (val-1) ); }
   65|       |
   66|       |  /*
   67|       |  // Returns the position of the first set (one) bit or a -1 if none exist.
   68|       |  template <size_t BITS>
   69|       |  int find_bit(const std::bitset<BITS> & in) {
   70|       |    int offset = 0;
   71|       |    uint64_t tmp_bits = 0ULL;
   72|       |    while (offset < BITS && ((tmp_bits = (in >> offset).to_ullong()) == 0ULL)) {
   73|       |      offset += 64;
   74|       |    }
   75|       |    return tmp_bits ? find_bit(tmp_bits) + offset : -1;
   76|       |  }
   77|       |
   78|       |  template <size_t BITS1, size_t BITS2>
   79|       |  std::bitset<BITS1+BITS2> concat_bits(std::bitset<BITS1> in1, std::bitset<BITS2> in2) {
   80|       |    constexpr int BITS_OUT = BITS1 + BITS2;  // How many bits are in the output?
   81|       |    constexpr int FULL_ULLS1 = BITS1 >> 6;   // How many 64-bit groups of bits fit into in1?
   82|       |    constexpr int FULL_ULLS2 = BITS2 >> 6;   // How many 64-bit groups of bits fit into in2?
   83|       |    // constexpr int EXTRA_BITS1 = BITS1 & 63;  // How many bits are leftover in BITS1?
   84|       |    constexpr int EXTRA_BITS2 = BITS2 & 63;  // How many bits are leftover in BITS2?
   85|       |    std::bitset<BITS_OUT> out_bits;
   86|       |
   87|       |    // Copy over in1...
   88|       |    for (int i = FULL_ULLS1; i >= 0; --i) {
   89|       |      out_bits <<= 64;                          // Make room for the next group of bits.
   90|       |      out_bits |= (in1 >> (i*64)).to_ullong();  // Put them in place.
   91|       |    }
   92|       |  }
   93|       |
   94|       |  template <size_t BITS>
   95|       |  constexpr std::bitset<BITS> mask_bit(uint32_t id) {
   96|       |    return (std::bitset<BITS>(1)) << id;
   97|       |  }
   98|       |
   99|       |  template <size_t BITS>
  100|       |  constexpr std::bitset<BITS> mask_pattern(size_t start, size_t step, size_t end) {
  101|       |    return mask_bit<BITS>(start) | std::bitset<BITS>(mask_pattern<BITS*(start<end)>(start+step,step,end));
  102|       |  }
  103|       |
  104|       |  template <>
  105|       |  constexpr size_t mask_pattern<0>(size_t start, size_t step, size_t end) {
  106|       |    return 0;
  107|       |  }
  108|       |  */
  109|       |}
  110|       |
  111|       |#endif
  112|       |

/home/emily/repos/Empirical_Tests/source/tools/const.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2015-2017
    5|       | *
    6|       | *  @file  const.h
    7|       | *  @brief Commonly used constant values.
    8|       | *  @note Status: RELEASE
    9|       | */
   10|       |
   11|       |#ifndef EMP_CONST_H
   12|       |#define EMP_CONST_H
   13|       |
   14|       |#include <cstdint>
   15|       |
   16|       |namespace emp {
   17|       |
   18|       |  constexpr const double E      = 2.71828;                ///< e
   19|       |  constexpr const double PHI    = 1.61803398874;          ///< Golden ratio
   20|       |  constexpr const double PI     = 3.14159265358979;       ///< pi
   21|       |  constexpr const double SQRT2  = 1.41421356237310;       ///< sqrt(2)
   22|       |
   23|       |  constexpr const uint32_t MAX_BYTE  = 255;           ///< (2^8 - 1)
   24|       |  constexpr const uint32_t MAX_2BYTE = 65535;         ///< (2^16 - 1)
   25|       |  constexpr const uint32_t MAX_WORD  = 65535;         ///< (2^16 - 1)
   26|       |  constexpr const uint32_t MAX_3BYTE = 16777215;      ///< (2^24 - 1)
   27|       |  constexpr const uint32_t MAX_UINT  = 4294967295;    ///< (2^32 - 1)
   28|       |  constexpr const uint32_t MAX_4BYTE = 4294967295;    ///< (2^32 - 1)
   29|       |
   30|       |  constexpr const int32_t MIN_INT = -2147483648;      ///< (- 2^31)
   31|       |
   32|       |  /// Determine the maximum value for any type.
   33|       |  // @CAO: Prevent inf to get more realistic numbers for double/float?
   34|       |  /*_FORCE_COVER_START_*/template <typename T>
   35|      0|  constexpr T MaxValue() {
   36|      0|    T val=1, next=3;
   37|      0|    while (next > val) {
   38|      0|      val = next;
   39|      0|      next = (T) (next * 2);
   40|      0|      next = (T) (next + 1);
   41|      0|    }
   42|      0|    return val;
   43|      0|  }/*_FORCE_COVER_END_*/
   44|       |
   45|       |  /// Large table to log base-2 results.
   46|       |  constexpr const double log2_chart_1_2[] =
   47|       |  {
   48|       |    0, 0.00140819, 0.00281502, 0.00422047, 0.00562455, 0.00702727, 0.00842862, 0.00982862,
   49|       |    0.0112273, 0.0126245, 0.0140205, 0.0154151, 0.0168083, 0.0182002, 0.0195907, 0.0209799,
   50|       |    0.0223678, 0.0237544, 0.0251396, 0.0265234, 0.027906, 0.0292872, 0.0306671, 0.0320457,
   51|       |    0.033423, 0.034799, 0.0361736, 0.037547, 0.038919, 0.0402897, 0.0416592, 0.0430273,
   52|       |    0.0443941, 0.0457597, 0.0471239, 0.0484869, 0.0498485, 0.0512089, 0.0525681, 0.0539259,
   53|       |    0.0552824, 0.0566377, 0.0579917, 0.0593445, 0.0606959, 0.0620461, 0.0633951, 0.0647428,
   54|       |    0.0660892, 0.0674344, 0.0687783, 0.0701209, 0.0714624, 0.0728025, 0.0741415, 0.0754791,
   55|       |    0.0768156, 0.0781508, 0.0794848, 0.0808175, 0.082149, 0.0834793, 0.0848084, 0.0861362,
   56|       |    0.0874628, 0.0887882, 0.0901124, 0.0914354, 0.0927571, 0.0940777, 0.095397, 0.0967152,
   57|       |    0.0980321, 0.0993478, 0.100662, 0.101976, 0.103288, 0.104599, 0.105909, 0.107217,
   58|       |    0.108524, 0.109831, 0.111136, 0.11244, 0.113742, 0.115044, 0.116344, 0.117643,
   59|       |    0.118941, 0.120238, 0.121534, 0.122828, 0.124121, 0.125413, 0.126704, 0.127994,
   60|       |    0.129283, 0.130571, 0.131857, 0.133142, 0.134426, 0.135709, 0.136991, 0.138272,
   61|       |    0.139551, 0.14083, 0.142107, 0.143383, 0.144658, 0.145932, 0.147205, 0.148477,
   62|       |    0.149747, 0.151017, 0.152285, 0.153552, 0.154818, 0.156083, 0.157347, 0.15861,
   63|       |    0.159871, 0.161132, 0.162391, 0.16365, 0.164907, 0.166163, 0.167418, 0.168672,
   64|       |    0.169925, 0.171177, 0.172428, 0.173677, 0.174926, 0.176173, 0.17742, 0.178665,
   65|       |    0.179909, 0.181152, 0.182394, 0.183635, 0.184875, 0.186114, 0.187352, 0.188589,
   66|       |    0.189825, 0.191059, 0.192293, 0.193525, 0.194757, 0.195987, 0.197217, 0.198445,
   67|       |    0.199672, 0.200899, 0.202124, 0.203348, 0.204571, 0.205793, 0.207014, 0.208234,
   68|       |    0.209453, 0.210671, 0.211888, 0.213104, 0.214319, 0.215533, 0.216746, 0.217958,
   69|       |    0.219169, 0.220378, 0.221587, 0.222795, 0.224002, 0.225207, 0.226412, 0.227616,
   70|       |    0.228819, 0.23002, 0.231221, 0.232421, 0.23362, 0.234817, 0.236014, 0.23721,
   71|       |    0.238405, 0.239599, 0.240791, 0.241983, 0.243174, 0.244364, 0.245553, 0.246741,
   72|       |    0.247928, 0.249113, 0.250298, 0.251482, 0.252665, 0.253847, 0.255029, 0.256209,
   73|       |    0.257388, 0.258566, 0.259743, 0.26092, 0.262095, 0.263269, 0.264443, 0.265615,
   74|       |    0.266787, 0.267957, 0.269127, 0.270295, 0.271463, 0.27263, 0.273796, 0.27496,
   75|       |    0.276124, 0.277287, 0.278449, 0.279611, 0.280771, 0.28193, 0.283088, 0.284246,
   76|       |    0.285402, 0.286558, 0.287712, 0.288866, 0.290019, 0.291171, 0.292322, 0.293472,
   77|       |    0.294621, 0.295769, 0.296916, 0.298063, 0.299208, 0.300353, 0.301496, 0.302639,
   78|       |    0.303781, 0.304922, 0.306062, 0.307201, 0.308339, 0.309476, 0.310613, 0.311748,
   79|       |    0.312883, 0.314017, 0.31515, 0.316282, 0.317413, 0.318543, 0.319672, 0.320801,
   80|       |    0.321928, 0.323055, 0.324181, 0.325305, 0.326429, 0.327553, 0.328675, 0.329796,
   81|       |    0.330917, 0.332037, 0.333155, 0.334273, 0.33539, 0.336507, 0.337622, 0.338736,
   82|       |    0.33985, 0.340963, 0.342075, 0.343186, 0.344296, 0.345405, 0.346514, 0.347621,
   83|       |    0.348728, 0.349834, 0.350939, 0.352043, 0.353147, 0.354249, 0.355351, 0.356452,
   84|       |    0.357552, 0.358651, 0.35975, 0.360847, 0.361944, 0.36304, 0.364135, 0.365229,
   85|       |    0.366322, 0.367415, 0.368506, 0.369597, 0.370687, 0.371777, 0.372865, 0.373953,
   86|       |    0.375039, 0.376125, 0.377211, 0.378295, 0.379378, 0.380461, 0.381543, 0.382624,
   87|       |    0.383704, 0.384784, 0.385862, 0.38694, 0.388017, 0.389094, 0.390169, 0.391244,
   88|       |    0.392317, 0.39339, 0.394463, 0.395534, 0.396605, 0.397675, 0.398744, 0.399812,
   89|       |    0.400879, 0.401946, 0.403012, 0.404077, 0.405141, 0.406205, 0.407268, 0.40833,
   90|       |    0.409391, 0.410451, 0.411511, 0.41257, 0.413628, 0.414685, 0.415742, 0.416798,
   91|       |    0.417853, 0.418907, 0.41996, 0.421013, 0.422065, 0.423116, 0.424166, 0.425216,
   92|       |    0.426265, 0.427313, 0.42836, 0.429407, 0.430453, 0.431498, 0.432542, 0.433585,
   93|       |    0.434628, 0.43567, 0.436712, 0.437752, 0.438792, 0.439831, 0.440869, 0.441907,
   94|       |    0.442943, 0.44398, 0.445015, 0.446049, 0.447083, 0.448116, 0.449149, 0.45018,
   95|       |    0.451211, 0.452241, 0.453271, 0.454299, 0.455327, 0.456354, 0.457381, 0.458407,
   96|       |    0.459432, 0.460456, 0.461479, 0.462502, 0.463524, 0.464546, 0.465566, 0.466586,
   97|       |    0.467606, 0.468624, 0.469642, 0.470659, 0.471675, 0.472691, 0.473706, 0.47472,
   98|       |    0.475733, 0.476746, 0.477758, 0.47877, 0.47978, 0.48079, 0.481799, 0.482808,
   99|       |    0.483816, 0.484823, 0.485829, 0.486835, 0.48784, 0.488844, 0.489848, 0.490851,
  100|       |    0.491853, 0.492855, 0.493855, 0.494856, 0.495855, 0.496854, 0.497852, 0.498849,
  101|       |    0.499846, 0.500842, 0.501837, 0.502832, 0.503826, 0.504819, 0.505812, 0.506803,
  102|       |    0.507795, 0.508785, 0.509775, 0.510764, 0.511753, 0.51274, 0.513728, 0.514714,
  103|       |    0.5157, 0.516685, 0.517669, 0.518653, 0.519636, 0.520619, 0.5216, 0.522582,
  104|       |    0.523562, 0.524542, 0.525521, 0.526499, 0.527477, 0.528454, 0.529431, 0.530406,
  105|       |    0.531381, 0.532356, 0.53333, 0.534303, 0.535275, 0.536247, 0.537218, 0.538189,
  106|       |    0.539159, 0.540128, 0.541097, 0.542065, 0.543032, 0.543998, 0.544964, 0.54593,
  107|       |    0.546894, 0.547859, 0.548822, 0.549785, 0.550747, 0.551708, 0.552669, 0.553629,
  108|       |    0.554589, 0.555548, 0.556506, 0.557464, 0.558421, 0.559377, 0.560333, 0.561288,
  109|       |    0.562242, 0.563196, 0.564149, 0.565102, 0.566054, 0.567005, 0.567956, 0.568906,
  110|       |    0.569856, 0.570804, 0.571753, 0.5727, 0.573647, 0.574594, 0.575539, 0.576484,
  111|       |    0.577429, 0.578373, 0.579316, 0.580259, 0.581201, 0.582142, 0.583083, 0.584023,
  112|       |    0.584963, 0.585901, 0.58684, 0.587778, 0.588715, 0.589651, 0.590587, 0.591522,
  113|       |    0.592457, 0.593391, 0.594325, 0.595257, 0.59619, 0.597121, 0.598053, 0.598983,
  114|       |    0.599913, 0.600842, 0.601771, 0.602699, 0.603626, 0.604553, 0.60548, 0.606405,
  115|       |    0.60733, 0.608255, 0.609179, 0.610102, 0.611025, 0.611947, 0.612868, 0.613789,
  116|       |    0.61471, 0.61563, 0.616549, 0.617467, 0.618386, 0.619303, 0.62022, 0.621136,
  117|       |    0.622052, 0.622967, 0.623881, 0.624795, 0.625709, 0.626622, 0.627534, 0.628446,
  118|       |    0.629357, 0.630267, 0.631177, 0.632086, 0.632995, 0.633903, 0.634811, 0.635718,
  119|       |    0.636625, 0.637531, 0.638436, 0.639341, 0.640245, 0.641149, 0.642052, 0.642954,
  120|       |    0.643856, 0.644758, 0.645658, 0.646559, 0.647458, 0.648358, 0.649256, 0.650154,
  121|       |    0.651052, 0.651949, 0.652845, 0.653741, 0.654636, 0.655531, 0.656425, 0.657318,
  122|       |    0.658211, 0.659104, 0.659996, 0.660887, 0.661778, 0.662668, 0.663558, 0.664447,
  123|       |    0.665336, 0.666224, 0.667112, 0.667999, 0.668885, 0.669771, 0.670656, 0.671541,
  124|       |    0.672425, 0.673309, 0.674192, 0.675075, 0.675957, 0.676839, 0.67772, 0.6786,
  125|       |    0.67948, 0.68036, 0.681238, 0.682117, 0.682995, 0.683872, 0.684749, 0.685625,
  126|       |    0.686501, 0.687376, 0.68825, 0.689124, 0.689998, 0.690871, 0.691744, 0.692616,
  127|       |    0.693487, 0.694358, 0.695228, 0.696098, 0.696968, 0.697836, 0.698705, 0.699572,
  128|       |    0.70044, 0.701306, 0.702173, 0.703038, 0.703904, 0.704768, 0.705632, 0.706496,
  129|       |    0.707359, 0.708222, 0.709084, 0.709945, 0.710806, 0.711667, 0.712527, 0.713387,
  130|       |    0.714246, 0.715104, 0.715962, 0.716819, 0.717676, 0.718533, 0.719389, 0.720244,
  131|       |    0.721099, 0.721954, 0.722808, 0.723661, 0.724514, 0.725366, 0.726218, 0.72707,
  132|       |    0.72792, 0.728771, 0.729621, 0.73047, 0.731319, 0.732167, 0.733015, 0.733863,
  133|       |    0.73471, 0.735556, 0.736402, 0.737247, 0.738092, 0.738937, 0.739781, 0.740624,
  134|       |    0.741467, 0.742309, 0.743151, 0.743993, 0.744834, 0.745674, 0.746514, 0.747354,
  135|       |    0.748193, 0.749031, 0.749869, 0.750707, 0.751544, 0.752381, 0.753217, 0.754052,
  136|       |    0.754888, 0.755722, 0.756556, 0.75739, 0.758223, 0.759056, 0.759888, 0.76072,
  137|       |    0.761551, 0.762382, 0.763212, 0.764042, 0.764872, 0.7657, 0.766529, 0.767357,
  138|       |    0.768184, 0.769011, 0.769838, 0.770664, 0.771489, 0.772315, 0.773139, 0.773963,
  139|       |    0.774787, 0.77561, 0.776433, 0.777255, 0.778077, 0.778898, 0.779719, 0.78054,
  140|       |    0.78136, 0.782179, 0.782998, 0.783817, 0.784635, 0.785452, 0.78627, 0.787086,
  141|       |    0.787903, 0.788718, 0.789534, 0.790348, 0.791163, 0.791977, 0.79279, 0.793603,
  142|       |    0.794416, 0.795228, 0.79604, 0.796851, 0.797662, 0.798472, 0.799282, 0.800091,
  143|       |    0.8009, 0.801708, 0.802516, 0.803324, 0.804131, 0.804938, 0.805744, 0.80655,
  144|       |    0.807355, 0.80816, 0.808964, 0.809768, 0.810572, 0.811375, 0.812177, 0.812979,
  145|       |    0.813781, 0.814582, 0.815383, 0.816184, 0.816984, 0.817783, 0.818582, 0.819381,
  146|       |    0.820179, 0.820977, 0.821774, 0.822571, 0.823367, 0.824163, 0.824959, 0.825754,
  147|       |    0.826548, 0.827343, 0.828136, 0.82893, 0.829723, 0.830515, 0.831307, 0.832099,
  148|       |    0.83289, 0.833681, 0.834471, 0.835261, 0.83605, 0.836839, 0.837628, 0.838416,
  149|       |    0.839204, 0.839991, 0.840778, 0.841564, 0.84235, 0.843136, 0.843921, 0.844706,
  150|       |    0.84549, 0.846274, 0.847057, 0.84784, 0.848623, 0.849405, 0.850187, 0.850968,
  151|       |    0.851749, 0.85253, 0.85331, 0.854089, 0.854868, 0.855647, 0.856426, 0.857203,
  152|       |    0.857981, 0.858758, 0.859535, 0.860311, 0.861087, 0.861862, 0.862637, 0.863412,
  153|       |    0.864186, 0.86496, 0.865733, 0.866506, 0.867279, 0.868051, 0.868823, 0.869594,
  154|       |    0.870365, 0.871135, 0.871905, 0.872675, 0.873444, 0.874213, 0.874981, 0.875749,
  155|       |    0.876517, 0.877284, 0.878051, 0.878817, 0.879583, 0.880349, 0.881114, 0.881879,
  156|       |    0.882643, 0.883407, 0.884171, 0.884934, 0.885696, 0.886459, 0.887221, 0.887982,
  157|       |    0.888743, 0.889504, 0.890264, 0.891024, 0.891784, 0.892543, 0.893302, 0.89406,
  158|       |    0.894818, 0.895575, 0.896332, 0.897089, 0.897845, 0.898601, 0.899357, 0.900112,
  159|       |    0.900867, 0.901621, 0.902375, 0.903129, 0.903882, 0.904635, 0.905387, 0.906139,
  160|       |    0.906891, 0.907642, 0.908393, 0.909143, 0.909893, 0.910643, 0.911392, 0.912141,
  161|       |    0.912889, 0.913637, 0.914385, 0.915132, 0.915879, 0.916626, 0.917372, 0.918118,
  162|       |    0.918863, 0.919608, 0.920353, 0.921097, 0.921841, 0.922584, 0.923327, 0.92407,
  163|       |    0.924813, 0.925554, 0.926296, 0.927037, 0.927778, 0.928518, 0.929258, 0.929998,
  164|       |    0.930737, 0.931476, 0.932215, 0.932953, 0.933691, 0.934428, 0.935165, 0.935902,
  165|       |    0.936638, 0.937374, 0.938109, 0.938844, 0.939579, 0.940314, 0.941048, 0.941781,
  166|       |    0.942515, 0.943247, 0.94398, 0.944712, 0.945444, 0.946175, 0.946906, 0.947637,
  167|       |    0.948367, 0.949097, 0.949827, 0.950556, 0.951285, 0.952013, 0.952741, 0.953469,
  168|       |    0.954196, 0.954923, 0.95565, 0.956376, 0.957102, 0.957828, 0.958553, 0.959278,
  169|       |    0.960002, 0.960726, 0.96145, 0.962173, 0.962896, 0.963619, 0.964341, 0.965063,
  170|       |    0.965784, 0.966505, 0.967226, 0.967947, 0.968667, 0.969387, 0.970106, 0.970825,
  171|       |    0.971544, 0.972262, 0.97298, 0.973697, 0.974415, 0.975131, 0.975848, 0.976564,
  172|       |    0.97728, 0.977995, 0.97871, 0.979425, 0.98014, 0.980854, 0.981567, 0.982281,
  173|       |    0.982994, 0.983706, 0.984418, 0.98513, 0.985842, 0.986553, 0.987264, 0.987975,
  174|       |    0.988685, 0.989394, 0.990104, 0.990813, 0.991522, 0.99223, 0.992938, 0.993646,
  175|       |    0.994353, 0.99506, 0.995767, 0.996473, 0.997179, 0.997885, 0.99859, 0.999295,
  176|       |    1.0
  177|       |  };
  178|       |
  179|       |  // constexpr const double pow2_chart_bits[] =
  180|       |  // { 1.414214, 1.189207, 1.090508, 1.044274, 1.021897, 1.010889, 1.005430, 1.002711,
  181|       |  //   1.001355, 1.000677, 1.000339, 1.000169, 1.000085, 1.000042, 1.000021, 1.000011 };
  182|       |
  183|       |  /// Table to provide results of Pow2 for values of bits (0.1, 0.01, 0.001, etc, in binary)
  184|       |  constexpr const double pow2_chart_bits[] =
  185|       |  {
  186|       |    1.4142135623730951, 1.1892071150027210, 1.0905077326652577, 1.0442737824274138,
  187|       |    1.0218971486541166, 1.0108892860517005, 1.0054299011128027, 1.0027112750502025,
  188|       |    1.0013547198921082, 1.0006771306930664, 1.0003385080526823, 1.0001692397053021,
  189|       |    1.0000846162726944, 1.0000423072413958, 1.0000211533969647, 1.0000105766425498,
  190|       |    1.0000052883072919, 1.0000026441501502, 1.0000013220742012, 1.0000006610368821,
  191|       |    1.0000003305183864, 1.0000001652591795, 1.0000000826295863, 1.0000000413147923,
  192|       |    1.0000000206573960, 1.0000000103286979, 1.0000000051643489, 1.0000000025821745,
  193|       |    1.0000000012910872, 1.0000000006455436, 1.0000000003227718, 1.0000000001613858
  194|       |  };
  195|       |
  196|       |  /// Table to provide results of Pow2 from 0 to 1
  197|       |  constexpr const double pow2_chart_0_1[] =
  198|       |  {
  199|       |    1.0, 1.00068, 1.00135, 1.00203, 1.00271, 1.00339, 1.00407, 1.00475,
  200|       |    1.00543, 1.00611, 1.00679, 1.00747, 1.00816, 1.00884, 1.00952, 1.01021,
  201|       |    1.01089, 1.01157, 1.01226, 1.01294, 1.01363, 1.01432, 1.015, 1.01569,
  202|       |    1.01638, 1.01707, 1.01776, 1.01844, 1.01913, 1.01982, 1.02051, 1.02121,
  203|       |    1.0219, 1.02259, 1.02328, 1.02397, 1.02467, 1.02536, 1.02606, 1.02675,
  204|       |    1.02745, 1.02814, 1.02884, 1.02953, 1.03023, 1.03093, 1.03163, 1.03233,
  205|       |    1.03302, 1.03372, 1.03442, 1.03512, 1.03583, 1.03653, 1.03723, 1.03793,
  206|       |    1.03863, 1.03934, 1.04004, 1.04075, 1.04145, 1.04216, 1.04286, 1.04357,
  207|       |    1.04427, 1.04498, 1.04569, 1.0464, 1.04711, 1.04781, 1.04852, 1.04923,
  208|       |    1.04994, 1.05066, 1.05137, 1.05208, 1.05279, 1.0535, 1.05422, 1.05493,
  209|       |    1.05565, 1.05636, 1.05708, 1.05779, 1.05851, 1.05922, 1.05994, 1.06066,
  210|       |    1.06138, 1.0621, 1.06282, 1.06353, 1.06425, 1.06498, 1.0657, 1.06642,
  211|       |    1.06714, 1.06786, 1.06859, 1.06931, 1.07003, 1.07076, 1.07148, 1.07221,
  212|       |    1.07293, 1.07366, 1.07439, 1.07512, 1.07584, 1.07657, 1.0773, 1.07803,
  213|       |    1.07876, 1.07949, 1.08022, 1.08095, 1.08169, 1.08242, 1.08315, 1.08388,
  214|       |    1.08462, 1.08535, 1.08609, 1.08682, 1.08756, 1.0883, 1.08903, 1.08977,
  215|       |    1.09051, 1.09125, 1.09199, 1.09272, 1.09346, 1.0942, 1.09495, 1.09569,
  216|       |    1.09643, 1.09717, 1.09791, 1.09866, 1.0994, 1.10015, 1.10089, 1.10164,
  217|       |    1.10238, 1.10313, 1.10388, 1.10462, 1.10537, 1.10612, 1.10687, 1.10762,
  218|       |    1.10837, 1.10912, 1.10987, 1.11062, 1.11137, 1.11213, 1.11288, 1.11363,
  219|       |    1.11439, 1.11514, 1.1159, 1.11665, 1.11741, 1.11816, 1.11892, 1.11968,
  220|       |    1.12044, 1.1212, 1.12196, 1.12272, 1.12348, 1.12424, 1.125, 1.12576,
  221|       |    1.12652, 1.12728, 1.12805, 1.12881, 1.12958, 1.13034, 1.13111, 1.13187,
  222|       |    1.13264, 1.13341, 1.13417, 1.13494, 1.13571, 1.13648, 1.13725, 1.13802,
  223|       |    1.13879, 1.13956, 1.14033, 1.1411, 1.14188, 1.14265, 1.14342, 1.1442,
  224|       |    1.14497, 1.14575, 1.14652, 1.1473, 1.14808, 1.14885, 1.14963, 1.15041,
  225|       |    1.15119, 1.15197, 1.15275, 1.15353, 1.15431, 1.15509, 1.15587, 1.15666,
  226|       |    1.15744, 1.15822, 1.15901, 1.15979, 1.16058, 1.16136, 1.16215, 1.16294,
  227|       |    1.16372, 1.16451, 1.1653, 1.16609, 1.16688, 1.16767, 1.16846, 1.16925,
  228|       |    1.17004, 1.17084, 1.17163, 1.17242, 1.17322, 1.17401, 1.17481, 1.1756,
  229|       |    1.1764, 1.17719, 1.17799, 1.17879, 1.17959, 1.18039, 1.18118, 1.18198,
  230|       |    1.18278, 1.18359, 1.18439, 1.18519, 1.18599, 1.18679, 1.1876, 1.1884,
  231|       |    1.18921, 1.19001, 1.19082, 1.19162, 1.19243, 1.19324, 1.19405, 1.19486,
  232|       |    1.19566, 1.19647, 1.19728, 1.19809, 1.19891, 1.19972, 1.20053, 1.20134,
  233|       |    1.20216, 1.20297, 1.20379, 1.2046, 1.20542, 1.20623, 1.20705, 1.20787,
  234|       |    1.20868, 1.2095, 1.21032, 1.21114, 1.21196, 1.21278, 1.2136, 1.21443,
  235|       |    1.21525, 1.21607, 1.21689, 1.21772, 1.21854, 1.21937, 1.22019, 1.22102,
  236|       |    1.22185, 1.22267, 1.2235, 1.22433, 1.22516, 1.22599, 1.22682, 1.22765,
  237|       |    1.22848, 1.22931, 1.23014, 1.23098, 1.23181, 1.23265, 1.23348, 1.23432,
  238|       |    1.23515, 1.23599, 1.23682, 1.23766, 1.2385, 1.23934, 1.24018, 1.24102,
  239|       |    1.24186, 1.2427, 1.24354, 1.24438, 1.24522, 1.24607, 1.24691, 1.24776,
  240|       |    1.2486, 1.24945, 1.25029, 1.25114, 1.25199, 1.25283, 1.25368, 1.25453,
  241|       |    1.25538, 1.25623, 1.25708, 1.25793, 1.25878, 1.25964, 1.26049, 1.26134,
  242|       |    1.2622, 1.26305, 1.26391, 1.26476, 1.26562, 1.26648, 1.26733, 1.26819,
  243|       |    1.26905, 1.26991, 1.27077, 1.27163, 1.27249, 1.27335, 1.27422, 1.27508,
  244|       |    1.27594, 1.27681, 1.27767, 1.27854, 1.2794, 1.28027, 1.28113, 1.282,
  245|       |    1.28287, 1.28374, 1.28461, 1.28548, 1.28635, 1.28722, 1.28809, 1.28896,
  246|       |    1.28984, 1.29071, 1.29158, 1.29246, 1.29333, 1.29421, 1.29509, 1.29596,
  247|       |    1.29684, 1.29772, 1.2986, 1.29948, 1.30036, 1.30124, 1.30212, 1.303,
  248|       |    1.30388, 1.30476, 1.30565, 1.30653, 1.30742, 1.3083, 1.30919, 1.31007,
  249|       |    1.31096, 1.31185, 1.31274, 1.31363, 1.31452, 1.31541, 1.3163, 1.31719,
  250|       |    1.31808, 1.31897, 1.31987, 1.32076, 1.32165, 1.32255, 1.32344, 1.32434,
  251|       |    1.32524, 1.32613, 1.32703, 1.32793, 1.32883, 1.32973, 1.33063, 1.33153,
  252|       |    1.33243, 1.33333, 1.33424, 1.33514, 1.33605, 1.33695, 1.33786, 1.33876,
  253|       |    1.33967, 1.34057, 1.34148, 1.34239, 1.3433, 1.34421, 1.34512, 1.34603,
  254|       |    1.34694, 1.34785, 1.34877, 1.34968, 1.35059, 1.35151, 1.35242, 1.35334,
  255|       |    1.35426, 1.35517, 1.35609, 1.35701, 1.35793, 1.35885, 1.35977, 1.36069,
  256|       |    1.36161, 1.36253, 1.36345, 1.36438, 1.3653, 1.36623, 1.36715, 1.36808,
  257|       |    1.369, 1.36993, 1.37086, 1.37179, 1.37271, 1.37364, 1.37457, 1.3755,
  258|       |    1.37644, 1.37737, 1.3783, 1.37923, 1.38017, 1.3811, 1.38204, 1.38297,
  259|       |    1.38391, 1.38485, 1.38578, 1.38672, 1.38766, 1.3886, 1.38954, 1.39048,
  260|       |    1.39142, 1.39237, 1.39331, 1.39425, 1.3952, 1.39614, 1.39709, 1.39803,
  261|       |    1.39898, 1.39993, 1.40087, 1.40182, 1.40277, 1.40372, 1.40467, 1.40562,
  262|       |    1.40658, 1.40753, 1.40848, 1.40944, 1.41039, 1.41134, 1.4123, 1.41326,
  263|       |    1.41421, 1.41517, 1.41613, 1.41709, 1.41805, 1.41901, 1.41997, 1.42093,
  264|       |    1.42189, 1.42286, 1.42382, 1.42478, 1.42575, 1.42671, 1.42768, 1.42865,
  265|       |    1.42961, 1.43058, 1.43155, 1.43252, 1.43349, 1.43446, 1.43543, 1.4364,
  266|       |    1.43738, 1.43835, 1.43932, 1.4403, 1.44127, 1.44225, 1.44323, 1.4442,
  267|       |    1.44518, 1.44616, 1.44714, 1.44812, 1.4491, 1.45008, 1.45106, 1.45204,
  268|       |    1.45303, 1.45401, 1.455, 1.45598, 1.45697, 1.45795, 1.45894, 1.45993,
  269|       |    1.46092, 1.46191, 1.4629, 1.46389, 1.46488, 1.46587, 1.46686, 1.46786,
  270|       |    1.46885, 1.46985, 1.47084, 1.47184, 1.47283, 1.47383, 1.47483, 1.47583,
  271|       |    1.47683, 1.47783, 1.47883, 1.47983, 1.48083, 1.48183, 1.48284, 1.48384,
  272|       |    1.48485, 1.48585, 1.48686, 1.48786, 1.48887, 1.48988, 1.49089, 1.4919,
  273|       |    1.49291, 1.49392, 1.49493, 1.49594, 1.49696, 1.49797, 1.49898, 1.5,
  274|       |    1.50101, 1.50203, 1.50305, 1.50407, 1.50508, 1.5061, 1.50712, 1.50814,
  275|       |    1.50916, 1.51019, 1.51121, 1.51223, 1.51326, 1.51428, 1.51531, 1.51633,
  276|       |    1.51736, 1.51839, 1.51941, 1.52044, 1.52147, 1.5225, 1.52353, 1.52457,
  277|       |    1.5256, 1.52663, 1.52766, 1.5287, 1.52973, 1.53077, 1.53181, 1.53284,
  278|       |    1.53388, 1.53492, 1.53596, 1.537, 1.53804, 1.53908, 1.54012, 1.54117,
  279|       |    1.54221, 1.54326, 1.5443, 1.54535, 1.54639, 1.54744, 1.54849, 1.54954,
  280|       |    1.55058, 1.55163, 1.55269, 1.55374, 1.55479, 1.55584, 1.5569, 1.55795,
  281|       |    1.559, 1.56006, 1.56112, 1.56217, 1.56323, 1.56429, 1.56535, 1.56641,
  282|       |    1.56747, 1.56853, 1.56959, 1.57066, 1.57172, 1.57278, 1.57385, 1.57491,
  283|       |    1.57598, 1.57705, 1.57812, 1.57918, 1.58025, 1.58132, 1.58239, 1.58347,
  284|       |    1.58454, 1.58561, 1.58668, 1.58776, 1.58883, 1.58991, 1.59099, 1.59206,
  285|       |    1.59314, 1.59422, 1.5953, 1.59638, 1.59746, 1.59854, 1.59963, 1.60071,
  286|       |    1.60179, 1.60288, 1.60396, 1.60505, 1.60614, 1.60722, 1.60831, 1.6094,
  287|       |    1.61049, 1.61158, 1.61267, 1.61376, 1.61486, 1.61595, 1.61704, 1.61814,
  288|       |    1.61924, 1.62033, 1.62143, 1.62253, 1.62363, 1.62472, 1.62582, 1.62693,
  289|       |    1.62803, 1.62913, 1.63023, 1.63134, 1.63244, 1.63355, 1.63465, 1.63576,
  290|       |    1.63687, 1.63798, 1.63908, 1.64019, 1.64131, 1.64242, 1.64353, 1.64464,
  291|       |    1.64576, 1.64687, 1.64799, 1.6491, 1.65022, 1.65133, 1.65245, 1.65357,
  292|       |    1.65469, 1.65581, 1.65693, 1.65806, 1.65918, 1.6603, 1.66143, 1.66255,
  293|       |    1.66368, 1.6648, 1.66593, 1.66706, 1.66819, 1.66932, 1.67045, 1.67158,
  294|       |    1.67271, 1.67384, 1.67498, 1.67611, 1.67725, 1.67838, 1.67952, 1.68065,
  295|       |    1.68179, 1.68293, 1.68407, 1.68521, 1.68635, 1.68749, 1.68864, 1.68978,
  296|       |    1.69092, 1.69207, 1.69322, 1.69436, 1.69551, 1.69666, 1.69781, 1.69896,
  297|       |    1.70011, 1.70126, 1.70241, 1.70356, 1.70472, 1.70587, 1.70703, 1.70818,
  298|       |    1.70934, 1.7105, 1.71165, 1.71281, 1.71397, 1.71513, 1.71629, 1.71746,
  299|       |    1.71862, 1.71978, 1.72095, 1.72211, 1.72328, 1.72445, 1.72561, 1.72678,
  300|       |    1.72795, 1.72912, 1.73029, 1.73146, 1.73264, 1.73381, 1.73498, 1.73616,
  301|       |    1.73733, 1.73851, 1.73969, 1.74087, 1.74204, 1.74322, 1.7444, 1.74559,
  302|       |    1.74677, 1.74795, 1.74913, 1.75032, 1.7515, 1.75269, 1.75388, 1.75506,
  303|       |    1.75625, 1.75744, 1.75863, 1.75982, 1.76101, 1.76221, 1.7634, 1.76459,
  304|       |    1.76579, 1.76698, 1.76818, 1.76938, 1.77058, 1.77177, 1.77297, 1.77418,
  305|       |    1.77538, 1.77658, 1.77778, 1.77899, 1.78019, 1.7814, 1.7826, 1.78381,
  306|       |    1.78502, 1.78623, 1.78743, 1.78865, 1.78986, 1.79107, 1.79228, 1.79349,
  307|       |    1.79471, 1.79592, 1.79714, 1.79836, 1.79958, 1.80079, 1.80201, 1.80323,
  308|       |    1.80445, 1.80568, 1.8069, 1.80812, 1.80935, 1.81057, 1.8118, 1.81302,
  309|       |    1.81425, 1.81548, 1.81671, 1.81794, 1.81917, 1.8204, 1.82164, 1.82287,
  310|       |    1.8241, 1.82534, 1.82657, 1.82781, 1.82905, 1.83029, 1.83153, 1.83277,
  311|       |    1.83401, 1.83525, 1.83649, 1.83774, 1.83898, 1.84023, 1.84147, 1.84272,
  312|       |    1.84397, 1.84522, 1.84646, 1.84771, 1.84897, 1.85022, 1.85147, 1.85272,
  313|       |    1.85398, 1.85523, 1.85649, 1.85775, 1.85901, 1.86026, 1.86152, 1.86278,
  314|       |    1.86405, 1.86531, 1.86657, 1.86784, 1.8691, 1.87037, 1.87163, 1.8729,
  315|       |    1.87417, 1.87544, 1.87671, 1.87798, 1.87925, 1.88052, 1.88179, 1.88307,
  316|       |    1.88434, 1.88562, 1.8869, 1.88817, 1.88945, 1.89073, 1.89201, 1.89329,
  317|       |    1.89458, 1.89586, 1.89714, 1.89843, 1.89971, 1.901, 1.90229, 1.90357,
  318|       |    1.90486, 1.90615, 1.90744, 1.90874, 1.91003, 1.91132, 1.91262, 1.91391,
  319|       |    1.91521, 1.9165, 1.9178, 1.9191, 1.9204, 1.9217, 1.923, 1.9243,
  320|       |    1.92561, 1.92691, 1.92821, 1.92952, 1.93083, 1.93213, 1.93344, 1.93475,
  321|       |    1.93606, 1.93737, 1.93868, 1.94, 1.94131, 1.94263, 1.94394, 1.94526,
  322|       |    1.94657, 1.94789, 1.94921, 1.95053, 1.95185, 1.95317, 1.9545, 1.95582,
  323|       |    1.95714, 1.95847, 1.9598, 1.96112, 1.96245, 1.96378, 1.96511, 1.96644,
  324|       |    1.96777, 1.9691, 1.97044, 1.97177, 1.97311, 1.97444, 1.97578, 1.97712,
  325|       |    1.97846, 1.9798, 1.98114, 1.98248, 1.98382, 1.98516, 1.98651, 1.98785,
  326|       |    1.9892, 1.99055, 1.99189, 1.99324, 1.99459, 1.99594, 1.99729, 1.99865,
  327|       |    2.0
  328|       |  };
  329|       |
  330|       |  /// The following function takes a table and a position [0.0, 1.0) and intepolates a value.
  331|       |  /*_FORCE_COVER_START_*/template <typename T>
  332|       |    constexpr double InterpolateTable(T && table, double pos, double tsize) {
  333|       |    return table[(int)(pos*tsize)] * (1.0-pos+((double)((int)(pos*tsize)))/tsize)
  334|       |      + table[(int)(pos*tsize)+1] * (pos-((double)((int)(pos*tsize)))/tsize);
  335|       |  }/*_FORCE_COVER_END_*/
  336|       |
  337|       |}
  338|       |
  339|       |#endif
  340|       |

/home/emily/repos/Empirical_Tests/source/tools/flex_function.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  flex_function.h
    7|       | *  @brief Based on std::function, but holds default parameter values for calls with fewer args.
    8|       | *  @note Status: ALPHA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_FLEX_FUNCTION_H
   13|       |#define EMP_FLEX_FUNCTION_H
   14|       |
   15|       |#include <functional>
   16|       |#include <tuple>
   17|       |
   18|       |#include "../base/assert.h"
   19|       |#include "../meta/meta.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  template <class T> class flex_function;    // Not defined.
   24|       |
   25|       |  /// A functon class that is almost identical to std::function, but is provided with default values
   26|       |  /// for all parameters so that it can be called with fewer arguments, as needed.
   27|       |  template <class R, class... ARGS>
   28|       |  class flex_function<R(ARGS...)> {
   29|       |  public:
   30|       |    using size_t = std::size_t;
   31|       |    using return_t = R;
   32|       |    using fun_t = std::function<R(ARGS...)>;
   33|       |    using this_t = flex_function<R(ARGS...)>;
   34|       |    using tuple_t = std::tuple<ARGS...>;
   35|       |
   36|       |    static constexpr int num_args = sizeof...(ARGS);
   37|       |
   38|       |  private:
   39|       |    fun_t fun;               ///< Function to be called.
   40|       |    tuple_t default_args;    ///< Arguments to be used if not enough are provided in call.
   41|       |
   42|       |  public:
   43|       |    /*_FORCE_COVER_START_*/template <typename T>
   44|      1|    flex_function(T && fun_info) : fun(std::forward<T>(fun_info)), default_args() { ; }/*_FORCE_COVER_END_*/
   45|       |    flex_function(const this_t &) = default;
   46|      1|    flex_function(this_t &&) = default;
   47|       |    flex_function() { ; }
   48|       |
   49|       |    this_t & operator=(const this_t &) = default;
   50|       |    this_t & operator=(this_t &&) = default;
   51|       |    this_t & operator=(const fun_t & _f) { fun=_f; return *this; }
   52|       |    this_t & operator=(fun_t && _f) { fun=std::move(_f); return *this; }
   53|       |    /*_FORCE_COVER_START_*/template <typename T>
   54|       |    this_t & operator=(T && arg) { fun = std::forward<T>(arg); return *this; }/*_FORCE_COVER_END_*/
   55|       |
   56|       |    /// Set the default value for a specific parameter.
   57|       |    /*_FORCE_COVER_START_*/template <int ID> void SetDefault(pack_id<ID,ARGS...> & in_default) {
   58|       |      std::get<ID>(default_args) = in_default;
   59|       |    }/*_FORCE_COVER_END_*/
   60|       |
   61|       |    /// Set the default values for all parameters.
   62|      1|    void SetDefaults(ARGS... args) {
   63|      1|      default_args = std::make_tuple(args...);
   64|      1|    }
   65|       |
   66|       |    /// Allow the function to be called with all args.
   67|      5|    return_t operator()(ARGS... k) const {
   68|      5|      emp_assert(fun);
   69|      5|      return fun(k...);
   70|      5|    }
   71|       |
   72|       |    /// All the function to be called with a subset of arguments (and the rest set to defaults)
   73|       |    /*_FORCE_COVER_START_*/template <class... IN_ARGS>
   74|     10|    return_t operator()(IN_ARGS &&... k) const {
   75|     10|      emp_assert(fun);
   76|     10|      constexpr int in_args = sizeof...(IN_ARGS);
   77|     10|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
   78|     10|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
   79|     10|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiiiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiiRKiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiRKiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJiRKiS5_EEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJRKiEEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJRKiS5_EEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZNK3emp13flex_functionIFiiiiiEEclIJRKiS5_S5_EEEiDpOT_:
  |   74|      1|    return_t operator()(IN_ARGS &&... k) const {
  |   75|      1|      emp_assert(fun);
  |   76|      1|      constexpr int in_args = sizeof...(IN_ARGS);
  |   77|      1|      static_assert(in_args < num_args, "This operator() should only be called if too few args provided.");
  |   78|      1|      return operator()(std::forward<IN_ARGS>(k)..., std::get<in_args>(default_args));
  |   79|      1|    }/*_FORCE_COVER_END_*/
  ------------------
   80|       |
   81|       |    /// Determine whether this function has been set.
   82|       |    operator bool() const { return (bool) fun; }
   83|       |
   84|       |  };
   85|       |
   86|       |}
   87|       |
   88|       |#endif
   89|       |

/home/emily/repos/Empirical_Tests/source/tools/functions.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  flex_function.h
    7|       | *  @brief A collection of broadly-useful functions (that don't fit elsewhere)
    8|       | *  @note Status: BETA (though new functions are added frequently)
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_FUNCTIONS_H
   13|       |#define EMP_FUNCTIONS_H
   14|       |
   15|       |#include <ctime>
   16|       |#include <functional>
   17|       |#include <iostream>
   18|       |#include <type_traits>
   19|       |#include <sstream>
   20|       |
   21|       |#include "../base/assert.h"
   22|       |#include "../base/vector.h"
   23|       |
   24|       |#include "const.h"
   25|       |#include "math.h"
   26|       |
   27|       |/// A simple macro to time how long it takes for a function to complete.
   28|       |#define EMP_FUNCTION_TIMER(TEST_FUN) {                                       \
   29|       |    std::clock_t emp_start_time = std::clock();                              \
   30|       |    auto emp_result = TEST_FUN;                                              \
   31|       |    std::clock_t emp_tot_time = std::clock() - emp_start_time;               \
   32|       |    std::cout << "Time: "                                                    \
   33|       |              << 1000.0 * ((double) emp_tot_time) / (double) CLOCKS_PER_SEC  \
   34|       |              << " ms" << std::endl;                                         \
   35|       |    std::cout << "Result: " << emp_result << std::endl;                      \
   36|       |  }
   37|       |
   38|       |namespace emp {
   39|       |
   40|       |  /// A function timer that takes a functor an identifies how long it takes to complete when run.
   41|      0|  static inline double TimeFun(std::function<void()> test_fun) {
   42|      0|    std::clock_t start_time = std::clock();
   43|      0|    test_fun();
   44|      0|    std::clock_t tot_time = std::clock() - start_time;
   45|      0|    return 1000.0 * ((double) tot_time) / (double) CLOCKS_PER_SEC;
   46|      0|  }
   47|       |
   48|       |  /// Toggle an input bool.
   49|      1|  inline bool Toggle(bool & in_bool) { return (in_bool = !in_bool); }
   50|       |
   51|       |  /// Combine bools to AND them all together.
   52|      3|  inline constexpr bool AllTrue() { return true; }
   53|       |  /*_FORCE_COVER_START_*/template <typename... Ts>
   54|      6|  inline bool AllTrue(bool result, Ts... OTHER) {
   55|      6|    return result && AllTrue(OTHER...);
   56|      6|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7AllTrueIJPNS_17TypeTracker_ClassIiLm0EEEEEEbbDpT_:
  |   54|      2|  inline bool AllTrue(bool result, Ts... OTHER) {
  |   55|      2|    return result && AllTrue(OTHER...);
  |   56|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7AllTrueIJEEEbbDpT_:
  |   54|      3|  inline bool AllTrue(bool result, Ts... OTHER) {
  |   55|      3|    return result && AllTrue(OTHER...);
  |   56|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7AllTrueIJPNS_17TypeTracker_ClassIdLm2EEEEEEbbDpT_:
  |   54|      1|  inline bool AllTrue(bool result, Ts... OTHER) {
  |   55|      1|    return result && AllTrue(OTHER...);
  |   56|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   57|       |
   58|       |  /// Combine bools to OR them all together.
   59|      0|  inline constexpr bool AnyTrue() { return false; }
   60|       |  /*_FORCE_COVER_START_*/template <typename... Ts>
   61|       |  inline bool AnyTrue(bool result, Ts... OTHER) {
   62|       |    return result || AnyTrue(OTHER...);
   63|       |  }/*_FORCE_COVER_END_*/
   64|       |
   65|       |  /// Build a vector with a range of values from min to max at the provided step size.
   66|       |  /*_FORCE_COVER_START_*/template <typename T>
   67|      1|  static inline emp::vector<T> BuildRange(T min, T max, T step=1) {
   68|      1|    emp_assert(max > min);
   69|      1|    size_t vsize = (size_t) ((max-min) / step) + 1;
   70|      1|    emp::vector<T> out_v(vsize);
   71|      1|    size_t pos = 0;
   72|     21|    for (T i = min; i < max; i += step) {
   73|     20|      out_v[pos++] = i;
   74|     20|    }
   75|      1|    return out_v;
   76|      1|  }/*_FORCE_COVER_END_*/
   77|       |
   78|       |
   79|       |  /// Determine the size of a built-in array.
   80|       |  /*_FORCE_COVER_START_*/template <typename T, size_t N>
   81|       |  constexpr size_t GetSize(T (&)[N]) { return N; }/*_FORCE_COVER_END_*/
   82|       |
   83|       |  /// A function that will always return a unique value (and trip an assert if it can't...)
   84|      0|  static size_t UniqueVal() {
   85|      0|    static size_t val = 0;
   86|      0|    emp_assert(val < MaxValue<size_t>() && "Ran out of unique values in size_t!");
   87|      0|    return val++;
   88|      0|  }
   89|       |
   90|       |  /// A function that will always return a unique stringname (using UniqVal) with provided
   91|       |  /// prefix and postfix.)
   92|       |  static inline std::string UniqueName(const std::string & prefix="",
   93|      0|                                       const std::string & postfix="") {
   94|      0|    std::stringstream ss;
   95|      0|    ss << prefix << UniqueVal() << postfix;
   96|      0|    return ss.str();
   97|      0|  }
   98|       |}
   99|       |
  100|       |#endif
  101|       |

/home/emily/repos/Empirical_Tests/source/tools/graph_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2017
    5|       | *
    6|       | *  @file  graph_utils.h
    7|       | *  @brief This file provides a number of tools for manipulating graphs.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_GRAPH_UTILS_H
   12|       |#define EMP_GRAPH_UTILS_H
   13|       |
   14|       |#include <fstream>
   15|       |#include <iostream>
   16|       |#include <string>
   17|       |#include <tuple>
   18|       |
   19|       |#include "../base/assert.h"
   20|       |#include "../base/vector.h"
   21|       |
   22|       |#include "Graph.h"
   23|       |#include "Random.h"
   24|       |#include "random_utils.h"
   25|       |
   26|       |namespace emp {
   27|       |
   28|       |  /// Take an existing graph, and build a new one that is isomorphic to it, but with randomized
   29|       |  /// vertex IDs.
   30|      0|  Graph shuffle_graph(const Graph & in_graph, Random & random) {
   31|      0|    const size_t N = in_graph.GetSize();
   32|      0|    Graph out_graph(N);
   33|      0|
   34|      0|    // Determine new vertex IDs
   35|      0|    emp::vector<size_t> v_map = BuildRange<size_t>(0, N);
   36|      0|    Shuffle(random, v_map);
   37|      0|
   38|      0|    // Put the mapped edges into the new graph.
   39|      0|    for (size_t from = 0; from < N; from++) {
   40|      0|      for (size_t to = 0; to < N; to++) {
   41|      0|	if (in_graph.HasEdge(from, to)) {
   42|      0|	  out_graph.AddEdge( v_map[from], v_map[to] );
   43|      0|	}
   44|      0|      }
   45|      0|    }
   46|      0|
   47|      0|    return out_graph;
   48|      0|  }
   49|       |
   50|       |  /// Construct a graph where all vertics are degree two and form a single ring.
   51|      0|  Graph build_graph_ring(size_t v_count, Random & random) {
   52|      0|    Graph graph(v_count);
   53|      0|
   54|      0|    emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
   55|      0|    Shuffle(random, v_map);
   56|      0|
   57|      0|    for (size_t i = 1; i < v_count; i++) {
   58|      0|      const size_t from = v_map[i];
   59|      0|      const size_t to = v_map[i-1];
   60|      0|      graph.AddEdgePair(from, to);
   61|      0|    }
   62|      0|
   63|      0|    graph.AddEdgePair(v_map[0], v_map[v_count-1]);
   64|      0|
   65|      0|    return graph;
   66|      0|  }
   67|       |
   68|       |  /// Construct a random tree graph (new vertices are repeatedly attached to a random position
   69|       |  /// in a treee as it is constructed.)
   70|      0|  Graph build_graph_tree(size_t v_count, Random & random) {
   71|      0|    Graph graph(v_count);
   72|      0|
   73|      0|    emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
   74|      0|    Shuffle(random, v_map);
   75|      0|
   76|      0|    for (size_t i = 1; i < v_count; i++) {
   77|      0|      const size_t from = v_map[i];
   78|      0|      const size_t to = v_map[random.GetUInt(i)];
   79|      0|      graph.AddEdgePair(from, to);
   80|      0|    }
   81|      0|
   82|      0|    return graph;
   83|      0|  }
   84|       |
   85|       |  /// Construct a random, graph with the specified number of vertices and edges.  If connected is
   86|       |  /// set, start by building a tree.  Then connect random (unconnected) pairs of vertices until
   87|       |  /// the proper number of edges are included.
   88|       |  Graph build_graph_random(size_t v_count, size_t e_count, Random & random, bool connected=true)
   89|      0|  {
   90|      0|    const size_t max_edges = v_count * (v_count-1) / 2;
   91|      0|    (void) max_edges;
   92|      0|
   93|      0|    emp_assert(v_count >= 2 && e_count > 0); // We need at least two vertices to support an edge.
   94|      0|    emp_assert(e_count <= max_edges, e_count, max_edges); // Shouldn't have more edges than can fit!
   95|      0|
   96|      0|    Graph graph(v_count);
   97|      0|    size_t e_cur = 0;           // How many edges have we added?
   98|      0|
   99|      0|    // If the graph should be connected, start by building a tree.
  100|      0|    if (connected) {
  101|      0|      emp_assert(e_count >= v_count - 1);  // We need enough edges to build a connected graph.
  102|      0|      graph = build_graph_tree(v_count, random);
  103|      0|      e_cur = v_count - 1;
  104|      0|    }
  105|      0|
  106|      0|    // @CAO -- we should do something better if we are filling in most of the edges.
  107|      0|
  108|      0|    while (e_cur < e_count) {
  109|      0|      const size_t from = random.GetUInt(v_count);
  110|      0|      const size_t to = random.GetUInt(v_count);
  111|      0|
  112|      0|      if (from == to || graph.HasEdge(from,to)) continue;
  113|      0|
  114|      0|      graph.AddEdgePair(from, to);
  115|      0|      ++e_cur;
  116|      0|    }
  117|      0|
  118|      0|    return graph;
  119|      0|  }
  120|       |
  121|       |  /// Construct a graph with width x height vertices setup into a grid structure.
  122|      1|  Graph build_graph_grid(size_t width, size_t height, Random & random, double prob_use=1.0) {
  123|      1|    emp_assert(width > 0 && height > 0);
  124|      1|
  125|      1|    const size_t v_count = width * height;
  126|      1|    // const size_t e_count = (width-1)*height + width*(height-1);
  127|      1|
  128|      1|    Graph graph(v_count);
  129|      1|
  130|      1|    emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
  131|      1|    Shuffle(random, v_map);
  132|      1|
  133|      6|    for (size_t x=0; x < width; ++x) {
  134|     25|      for (size_t y=0; y < height; ++y) {
  135|     20|        const size_t from = y*width + x;
  136|     20|        if (x != (width-1) && random.P(prob_use)) {
  137|     16|          graph.AddEdgePair(v_map[from], v_map[from+1]);      // Horizontal
  138|     16|        }
  139|     20|        if (y != (height-1) && random.P(prob_use)) {
  140|     15|          graph.AddEdgePair(v_map[from], v_map[from+width]);  // Vertical
  141|     15|        }
  142|     20|      }
  143|      5|    }
  144|      1|
  145|      1|    return graph;
  146|      1|  }
  147|       |
  148|       |  /// Build a set of cliques (such that one member of each can be part of an independent set)
  149|       |  /// and then links them together
  150|       |  Graph build_graph_clique_set(size_t clique_size, size_t clique_count, Random & random,
  151|      0|                               double extra_prob=0.5) {
  152|      0|    emp_assert(clique_size > 0 && clique_count > 0);
  153|      0|
  154|      0|    const size_t v_count = clique_size * clique_count;
  155|      0|    Graph graph(v_count);
  156|      0|
  157|      0|    emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
  158|      0|    Shuffle(random, v_map);
  159|      0|
  160|      0|    // Fill out all of the edges within a clique
  161|      0|    for (size_t start_id = 0; start_id < v_count; start_id += clique_size) {
  162|      0|      const size_t end_id = start_id + clique_size;
  163|      0|      for (size_t node1 = start_id; node1 < end_id; node1++) {
  164|      0|        for (size_t node2 = node1+1; node2 < end_id; node2++) {
  165|      0|          graph.AddEdgePair(v_map[node1], v_map[node2]);
  166|      0|        }
  167|      0|      }
  168|      0|    }
  169|      0|
  170|      0|    // Add on extra edges.
  171|      0|    for (size_t start1 = 0; start1 < v_count; start1 += clique_size) {
  172|      0|      const size_t end1 = start1 + clique_size;
  173|      0|      for (size_t start2 = start1+clique_size; start2 < v_count; start2 += clique_size) {
  174|      0|        const size_t end2 = start2 + clique_size;
  175|      0|        for (size_t node1 = start1; node1 < end1; node1++) {
  176|      0|          for (size_t node2 = start2; node2< end2; node2++) {
  177|      0|            if (node1 == start1 && node2 == start2) continue;  // Both part of IS.
  178|      0|            if (random.P(extra_prob)) graph.AddEdgePair(v_map[node1], v_map[node2]);
  179|      0|          }
  180|      0|        }
  181|      0|      }
  182|      0|    }
  183|      0|
  184|      0|    return graph;
  185|      0|  }
  186|       |
  187|       |
  188|       |  /// Construct a random, graph with the specified number of vertices and edges.  If connected is
  189|       |  /// set, start by building a tree.  Then connect random (unconnected) pairs of vertices until
  190|       |  /// the proper number of edges are included.
  191|       |  Graph build_graph_dag(size_t v_count, size_t e_count, Random & random, bool connected=true)
  192|      0|  {
  193|      0|    const size_t max_edges = v_count * (v_count-1) / 2;
  194|      0|    (void) max_edges;
  195|      0|
  196|      0|    emp_assert(v_count >= 2 && e_count > 0); // We need at least two vertices to support an edge.
  197|      0|    emp_assert(e_count <= max_edges);        // Shouldn't have more edges than can fit!
  198|      0|
  199|      0|    Graph graph(v_count);                    //
  200|      0|    size_t e_cur = 0;                        // How many edges have we added?
  201|      0|
  202|      0|    // If the graph should be connected, start by building a tree.
  203|      0|    if (connected) {
  204|      0|      emp_assert(e_count >= v_count - 1);    // We need enough edges to build a connected graph.
  205|      0|
  206|      0|      // Determine order to connect in new vertices.
  207|      0|      emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
  208|      0|      Shuffle(random, v_map);
  209|      0|
  210|      0|      // Connect in each vertex to the tree.
  211|      0|      for (size_t i = 1; i < v_count; i++) {
  212|      0|        size_t from = v_map[i];                // Pick the next node in the shuffle.
  213|      0|        size_t to = v_map[random.GetUInt(i)];  // Pick node already in the tree.
  214|      0|        if (from > to) std::swap(from, to);    // Make sure lower number is first.
  215|      0|        graph.AddEdge(from, to);
  216|      0|      }
  217|      0|      e_cur = v_count - 1;
  218|      0|    }
  219|      0|
  220|      0|    // @CAO -- we should do something better if we are filling in most of the edges.
  221|      0|
  222|      0|    while (e_cur < e_count) {
  223|      0|      size_t from = random.GetUInt(v_count);
  224|      0|      size_t to = random.GetUInt(v_count);
  225|      0|
  226|      0|      if (from == to || graph.HasEdge(from,to)) continue;
  227|      0|      if (from > to) std::swap(from, to); // Make sure lower number is first.
  228|      0|
  229|      0|      graph.AddEdge(from, to);
  230|      0|      ++e_cur;
  231|      0|    }
  232|      0|
  233|      0|    // Make sure the edge ID numbers that we return are not all in order.
  234|      0|    return shuffle_graph(graph, random);
  235|      0|  }
  236|       |
  237|       |  /// Construct a random WEIGHTED tree graph (new vertices are repeatedly attached to a random
  238|       |  /// position in a treee as it is constructed.)
  239|       |  WeightedGraph build_weighted_graph_tree(size_t v_count, size_t min_weight, size_t max_weight,
  240|      0|                                          Random & random) {
  241|      0|    WeightedGraph graph(v_count);
  242|      0|
  243|      0|    emp::vector<size_t> v_map = BuildRange<size_t>(0, v_count);
  244|      0|    Shuffle(random, v_map);
  245|      0|
  246|      0|    for (size_t i = 1; i < v_count; i++) {
  247|      0|      const size_t from = v_map[i];
  248|      0|      const size_t to = v_map[random.GetUInt(i)];
  249|      0|      const size_t weight = (size_t) random.GetDouble(min_weight, max_weight);
  250|      0|      graph.AddEdgePair(from, to, weight);
  251|      0|    }
  252|      0|
  253|      0|    return graph;
  254|      0|  }
  255|       |
  256|       |  /// Construct a random, WEIGHTED graph with the specified number of vertices, edges, and range
  257|       |  /// of edge weights.  If connected is set, start by building a tree.  Then connect random
  258|       |  /// (unconnected) pairs of vertices until the proper number of edges are included.
  259|       |  WeightedGraph build_weighted_graph_random(size_t v_count, size_t e_count,
  260|       |                                            size_t min_weight, size_t max_weight,
  261|       |                                            Random & random, bool connected=true)
  262|      0|  {
  263|      0|    const size_t max_edges = v_count * (v_count-1) / 2;
  264|      0|    (void) max_edges;
  265|      0|
  266|      0|    emp_assert(v_count >= 2 && e_count > 0); // We need at least two vertices to support an edge.
  267|      0|    emp_assert(e_count <= max_edges, e_count, max_edges); // Shouldn't have more edges than can fit!
  268|      0|
  269|      0|    WeightedGraph graph(v_count);
  270|      0|    size_t e_cur = 0;           // How many edges have we added?
  271|      0|
  272|      0|    // If the graph should be connected, start by building a tree.
  273|      0|    if (connected) {
  274|      0|      emp_assert(e_count >= v_count - 1);  // We need enough edges to build a connected graph.
  275|      0|      graph = build_weighted_graph_tree(v_count, min_weight, max_weight, random);
  276|      0|      e_cur = v_count - 1;
  277|      0|    }
  278|      0|
  279|      0|    // @CAO -- we should do something better if we are filling in most of the edges.
  280|      0|
  281|      0|    while (e_cur < e_count) {
  282|      0|      const size_t from = random.GetUInt(v_count);
  283|      0|      const size_t to = random.GetUInt(v_count);
  284|      0|
  285|      0|      if (from == to || graph.HasEdge(from,to)) continue;
  286|      0|
  287|      0|      graph.AddEdgePair(from, to, (size_t) random.GetDouble(min_weight, max_weight));
  288|      0|      ++e_cur;
  289|      0|    }
  290|      0|
  291|      0|    return graph;
  292|      0|  }
  293|       |
  294|       |
  295|       |
  296|       |
  297|       |
  298|       |  /// Helper function for loading symetric graphs from an input stream.
  299|       |  /// sub1 indicates that verticies are numbered 1 to N instead of 0 to N-1.
  300|       |  // @CAO Need some error checking here...
  301|      0|  Graph load_graph_sym(std::istream & is, bool sub1=false) {
  302|      0|    size_t n_vert, n_edge;
  303|      0|    is >> n_vert >> n_edge;
  304|      0|
  305|      0|    Graph out_graph(n_vert);
  306|      0|    size_t from, to;
  307|      0|    for (size_t i = 0; i < n_edge; i++) {
  308|      0|      is >> from >> to;
  309|      0|      if (sub1) { from--; to--; }
  310|      0|      out_graph.AddEdgePair(from, to);
  311|      0|    }
  312|      0|
  313|      0|    return out_graph;
  314|      0|  }
  315|       |
  316|       |  /// Load a graph with a specified filename.
  317|      0|  Graph load_graph_sym(std::string filename, bool sub1=false) {
  318|      0|    std::ifstream ifile(filename);
  319|      0|    return load_graph_sym(ifile, sub1);
  320|      0|  }
  321|       |
  322|       |  /// Load a graph from a connection matrix.
  323|       |  /// Format: #vertices followed by v^2 0's or 1's
  324|      0|  Graph load_graph_table(std::istream & is) {
  325|      0|    size_t n_vert;
  326|      0|    is >> n_vert;
  327|      0|
  328|      0|    Graph out_graph(n_vert);
  329|      0|    size_t val;
  330|      0|    for (size_t i = 0; i < n_vert; i++) {
  331|      0|      for (size_t j = 0; j < n_vert; j++) {
  332|      0|        is >> val;
  333|      0|        if (val) out_graph.AddEdge(i, j);
  334|      0|      }
  335|      0|    }
  336|      0|
  337|      0|    return out_graph;
  338|      0|  }
  339|       |
  340|       |  /// Load a graph from a connection matrix in a file by the specified name.
  341|      0|  Graph load_graph_table(std::string filename) {
  342|      0|    std::ifstream ifile(filename);
  343|      0|    return load_graph_table(ifile);
  344|      0|  }
  345|       |}
  346|       |
  347|       |#endif
  348|       |

/home/emily/repos/Empirical_Tests/source/tools/info_theory.h:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016-2017.
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//
    6|       |//  Tools to calculate Information Theory metrics.
    7|       |//  Status: ALPHA
    8|       |//
    9|       |//
   10|       |//  Info-theory formulas:
   11|       |//    H(X)   = -SUM(X: p[x] log2 p[x])
   12|       |//    H(X|Y) = H(XY) - H(Y)
   13|       |//    I(X:Y) = H(X) - H(X|Y)
   14|       |//    H2(p)  = -p log2(p) - (1-p)log2(1-p)  = H({p, 1-p})
   15|       |//
   16|       |//  Developer notes:
   17|       |//  * Input may come as WEIGHTS or as ELEMENTS (or both!).
   18|       |//    ELEMENTS need to be converted to WEIGHTS for calculations.
   19|       |//  * Want basic info theory functions, as well as tools (for channels, error-correction,
   20|       |//    compression, etc.)
   21|       |
   22|       |#ifndef EMP_INFO_THEORY_H
   23|       |#define EMP_INFO_THEORY_H
   24|       |
   25|       |#include "../base/vector.h"
   26|       |#include "math.h"
   27|       |
   28|       |namespace emp {
   29|       |
   30|       |  /// Convert a vector of weights to probabilities and return the entropy of the system.
   31|       |  /*_FORCE_COVER_START_*/template<typename CONTAINER>
   32|      2|  double Entropy(const CONTAINER & weights) {
   33|      2|    double total = 0.0;
   34|      2|    double entropy = 0.0;
   35|      9|    for (auto w : weights) total += w;
   36|      9|    for (auto w : weights) {
   37|      9|      double p = ((double) w) / total;
   38|      9|      entropy -= p * Log2(p);
   39|      9|    }
   40|      2|    return entropy;
   41|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7EntropyINS_6vectorIiJEEEEEdRKT_:
  |   32|      1|  double Entropy(const CONTAINER & weights) {
  |   33|      1|    double total = 0.0;
  |   34|      1|    double entropy = 0.0;
  |   35|      3|    for (auto w : weights) total += w;
  |   36|      3|    for (auto w : weights) {
  |   37|      3|      double p = ((double) w) / total;
  |   38|      3|      entropy -= p * Log2(p);
  |   39|      3|    }
  |   40|      1|    return entropy;
  |   41|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7EntropyINS_6vectorIdJEEEEEdRKT_:
  |   32|      1|  double Entropy(const CONTAINER & weights) {
  |   33|      1|    double total = 0.0;
  |   34|      1|    double entropy = 0.0;
  |   35|      6|    for (auto w : weights) total += w;
  |   36|      6|    for (auto w : weights) {
  |   37|      6|      double p = ((double) w) / total;
  |   38|      6|      entropy -= p * Log2(p);
  |   39|      6|    }
  |   40|      1|    return entropy;
  |   41|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   42|       |
   43|       |  /// Calculate the entropy in a container of arbitrary objects.
   44|       |  /// Args are a container, a function to extract the weight of each member, and an (optional) total weight.
   45|       |  /*_FORCE_COVER_START_*/template<typename CONTAINER, typename WEIGHT_FUN>
   46|       |  double Entropy(const CONTAINER & objs, WEIGHT_FUN fun, double total=0.0) {
   47|       |    // If we don't know the total, calculate it.
   48|       |    if (total == 0.0) for (auto & o : objs) total += (double) fun(o);
   49|       |    emp_assert(total > 0.0);
   50|       |
   51|       |    double entropy = 0.0;
   52|       |    for (auto & o : objs) {
   53|       |      double p = ((double) fun(o)) / total;
   54|       |      entropy -= p * Log2(p);
   55|       |    }
   56|       |    return entropy;
   57|       |  }/*_FORCE_COVER_END_*/
   58|       |
   59|       |  /// Calculate the entropy when their are two possibile states based on one state's probability.
   60|      1|  constexpr double Entropy2(const double p) {
   61|      1|    return -(p * Log2(p) + (1.0-p)*Log2(1.0-p));
   62|      1|  }
   63|       |
   64|       |  /// Conitional Entropy: H(X|Y)
   65|       |  /// Allow for entropy of arbitrary objects with a converter.
   66|       |  /*_FORCE_COVER_START_*/template<typename CONTAINER, typename CAT_FUN_X, typename CAT_FUN_Y, typename WEIGHT_FUN>
   67|       |  double Entropy(const CONTAINER & objs, CAT_FUN_X funX, CAT_FUN_Y funY, WEIGHT_FUN funW) {
   68|       |    // @CAO Categorize all XY and all Y (maybe with helper function?) and count each.
   69|       |    // @CAO Run each through Entropy function.
   70|       |
   71|       |    double total = 0.0;
   72|       |    double entropy = 0.0;
   73|       |    for (auto & o : objs) total += fun(o);
   74|       |    for (auto & o : objs) {
   75|       |      double p = ((double) fun(o)) / total;
   76|       |      entropy -= p * Log2(p);
   77|       |    }
   78|       |    return entropy;
   79|       |  }/*_FORCE_COVER_END_*/
   80|       |}
   81|       |
   82|       |#endif
   83|       |

/home/emily/repos/Empirical_Tests/source/tools/lexer_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  lexer_utils.h
    7|       | *  @brief A set of utilities to convert between NFAs and DFAs
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_LEXER_UTILS_H
   13|       |#define EMP_LEXER_UTILS_H
   14|       |
   15|       |#include <map>
   16|       |#include <utility> // std::pair
   17|       |
   18|       |#include "../base/vector.h"
   19|       |
   20|       |#include "BitVector.h"
   21|       |#include "DFA.h"
   22|       |#include "NFA.h"
   23|       |
   24|       |namespace emp {
   25|       |
   26|       |  /// Converting DFA to DFA -- no change needed.
   27|      0|  static inline const DFA & to_DFA(const DFA & dfa) { return dfa; }
   28|       |
   29|       |  /// Converting NFA to MFA -- no change needed.
   30|      5|  static inline const NFA & to_NFA(const NFA & nfa) { return nfa; }
   31|       |
   32|       |  /// Systematic conversion of NFA to DFA...
   33|     13|  static inline DFA to_DFA(const NFA & nfa, int keep_invalid=false) {
   34|     13|    DFA dfa(1);                                  // Setup zero to be the start state.
   35|     13|    std::map<std::set<size_t>, size_t> id_map;   // How do nfa state sets map to dfa states?
   36|     13|    std::vector<std::set<size_t>> state_stack;   // Which states still need to be explored?
   37|     13|    state_stack.emplace_back(nfa.GetStart());    // Place the starting point in the state_stack.
   38|     13|    id_map[state_stack[0]] = 0;                  // Give starting point ID 0.
   39|     13|
   40|     13|    // Loop through all states not full explored; remove top state and add new states.
   41|     70|    while (state_stack.size()) {
   42|     57|      // Get the next state to test.
   43|     57|      std::set<size_t> cur_state = state_stack.back();
   44|     57|      const size_t cur_id = id_map[cur_state];
   45|     57|      state_stack.pop_back();
   46|     57|
   47|     57|      // Determine if this state should be a STOP state and always use HIGHEST stop value.
   48|    128|      for (auto s : cur_state) dfa.AddStop(cur_id, nfa.GetStop(s));
   49|     57|
   50|     57|      // Run through all possible transitions
   51|  7.35k|      for (size_t sym = 0; sym < NFA::NUM_SYMBOLS; sym++) {
   52|  7.29k|        std::set<size_t> next_state = nfa.GetNext(sym, cur_state);
   53|  7.29k|        if (next_state.size() == 0 && !keep_invalid) continue;  // Discard invalid transitions.
   54|  1.44k|
   55|  1.44k|        // Remove NFA states with ONLY free transisions (they will all have been taken already)
   56|  1.44k|        // @CAO do more elegantly!
   57|  1.44k|        emp::vector<size_t> remove_set;
   58|  6.14k|        for (auto x : next_state) if (nfa.IsEmpty(x)) remove_set.push_back(x);
   59|  2.77k|        for (auto x : remove_set) next_state.erase(x);
   60|  1.44k|
   61|  1.44k|        // Determine if we have a new state in the DFA.
   62|  1.44k|        if (id_map.find(next_state) == id_map.end()) {
   63|     44|          const size_t next_id = dfa.GetSize();
   64|     44|          id_map[next_state] = next_id;
   65|     44|          dfa.Resize(next_id + 1);
   66|     44|          state_stack.emplace_back(next_state);
   67|     44|        }
   68|  1.44k|
   69|  1.44k|        // Setup the new connection in the DFA
   70|  1.44k|        const size_t next_id = id_map[next_state];
   71|  1.44k|        dfa.SetTransition(cur_id, next_id, sym);
   72|  1.44k|      }
   73|     57|
   74|     57|    }
   75|     13|
   76|     13|    return dfa;
   77|     13|  }
   78|       |
   79|       |  /// Systematic up-conversion of DFA to NFA...
   80|      0|  static inline NFA to_NFA(const DFA & dfa) {
   81|      0|    NFA nfa(dfa.GetSize());
   82|      0|    for (size_t from = 0; from < dfa.GetSize(); from++) {
   83|      0|      const auto & t = dfa.GetTransitions(from);
   84|      0|      for (size_t sym = 0; sym < t.size(); sym++) {
   85|      0|        if (t[sym] == -1) continue;
   86|      0|        nfa.AddTransition(from, (size_t) t[sym], sym);
   87|      0|      }
   88|      0|      if (dfa.IsStop(from)) nfa.SetStop(from, dfa.GetStop(from));
   89|      0|    }
   90|      0|    return nfa;
   91|      0|  }
   92|       |
   93|       |
   94|       |  /// Merge multiple automata into one NFA (base case, single converstion)
   95|       |  /*_FORCE_COVER_START_*/template <typename T1>
   96|      1|  static NFA MergeNFA(T1 && in) {
   97|      1|    return to_NFA(std::forward<T1>(in));
   98|      1|  }/*_FORCE_COVER_END_*/
   99|       |
  100|       |  /// Merge multiple automata (DFA, NFA, RegEx) into one NFA.
  101|       |  /*_FORCE_COVER_START_*/template <typename T1, typename T2, typename... Ts>
  102|      2|  static NFA MergeNFA(T1 && in1, T2 && in2, Ts &&... others ) {
  103|      2|    NFA nfa_out( to_NFA(std::forward<T1>(in1)) );   // Start out identical to nfa1.
  104|      2|    nfa_out.Merge( to_NFA(std::forward<T2>(in2)) ); // Merge in nfa2;
  105|      2|    return MergeNFA(nfa_out, std::forward<Ts>(others)...);
  106|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3empL8MergeNFAIRNS_4tNFAILm128EhEES3_JS3_EEES2_OT_OT0_DpOT1_:
  |  102|      1|  static NFA MergeNFA(T1 && in1, T2 && in2, Ts &&... others ) {
  |  103|      1|    NFA nfa_out( to_NFA(std::forward<T1>(in1)) );   // Start out identical to nfa1.
  |  104|      1|    nfa_out.Merge( to_NFA(std::forward<T2>(in2)) ); // Merge in nfa2;
  |  105|      1|    return MergeNFA(nfa_out, std::forward<Ts>(others)...);
  |  106|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3empL8MergeNFAIRNS_4tNFAILm128EhEES3_JEEES2_OT_OT0_DpOT1_:
  |  102|      1|  static NFA MergeNFA(T1 && in1, T2 && in2, Ts &&... others ) {
  |  103|      1|    NFA nfa_out( to_NFA(std::forward<T1>(in1)) );   // Start out identical to nfa1.
  |  104|      1|    nfa_out.Merge( to_NFA(std::forward<T2>(in2)) ); // Merge in nfa2;
  |  105|      1|    return MergeNFA(nfa_out, std::forward<Ts>(others)...);
  |  106|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  107|       |
  108|       |
  109|       |  /// Merge multiple automata (DFA, NFA, RegEx) into one DFA.
  110|       |  /*_FORCE_COVER_START_*/template <typename T1, typename T2, typename... Ts>
  111|       |  static DFA MergeDFA(T1 && in1, T2 && in2, Ts &&... others ) {
  112|       |    return to_DFA( MergeNFA(in1, in2, others...) );
  113|       |  }/*_FORCE_COVER_END_*/
  114|       |
  115|       |  /// Structure to track the current status of a DFA.
  116|       |  struct DFAStatus {
  117|       |    size_t state;
  118|       |    std::string sequence;
  119|      0|    DFAStatus(size_t _state, const std::string & _seq) : state(_state), sequence(_seq) { ; }
  120|       |  };
  121|       |
  122|       |  /// Method to find an example string that satisfies a DFA.
  123|      0|  std::string FindExample(const DFA & dfa, const size_t min_size=1) {
  124|      0|    emp::vector< DFAStatus > traverse_set;
  125|      0|    traverse_set.emplace_back(0, "");
  126|      0|    // BitVector state_found(dfa.GetSize());
  127|      0|
  128|      0|    size_t next_id = 0;
  129|      0|    while (next_id < traverse_set.size()) {
  130|      0|      const auto cur_status = traverse_set[next_id++];       // pair: cur state and cur string
  131|      0|      const auto & t = dfa.GetTransitions(cur_status.state); // int array of TO states (or -1 if none)
  132|      0|      for (size_t sym = 0; sym < t.size(); sym++) {
  133|      0|        const int next_state = t[sym];
  134|      0|        if (next_state == -1) continue;                      // Ignore non-transitions
  135|      0|        std::string cur_str(cur_status.sequence);
  136|      0|        cur_str += (char) sym;                               // Figure out current string
  137|      0|        if (min_size <= cur_str.size() ) {             // If the DFA is big enough...
  138|      0|          if (dfa.IsStop(next_state)) return cur_str;        //  return if this is a legal answer
  139|      0|        }
  140|      0|        traverse_set.emplace_back(next_state, cur_str);      // Continue searching from here.
  141|      0|      }
  142|      0|    }
  143|      0|
  144|      0|    return "";
  145|      0|  }
  146|       |}
  147|       |
  148|       |#endif
  149|       |

/home/emily/repos/Empirical_Tests/source/tools/map_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  map_utils.h
    7|       | *  @brief A set of simple functions to manipulate maps.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_MAP_UTILS_H
   12|       |#define EMP_MAP_UTILS_H
   13|       |
   14|       |#include <map>
   15|       |#include <unordered_map>
   16|       |
   17|       |namespace emp {
   18|       |
   19|       |  /// Take any map type, and run find to determine if a key is present.
   20|       |  /*_FORCE_COVER_START_*/template <class MAP_T, class KEY_T>
   21|      9|  inline bool Has( const MAP_T & in_map, const KEY_T & key ) {
   22|      9|    return in_map.find(key) != in_map.end();
   23|      9|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3HasISt3mapIicSt4lessIiESaISt4pairIKicEEEiEEbRKT_RKT0_:
  |   21|      3|  inline bool Has( const MAP_T & in_map, const KEY_T & key ) {
  |   22|      3|    return in_map.find(key) != in_map.end();
  |   23|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3HasISt8multimapIciSt4lessIcESaISt4pairIKciEEEcEEbRKT_RKT0_:
  |   21|      2|  inline bool Has( const MAP_T & in_map, const KEY_T & key ) {
  |   22|      2|    return in_map.find(key) != in_map.end();
  |   23|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3HasISt13unordered_mapImPNS_15GenericFunctionESt4hashImESt8equal_toImESaISt4pairIKmS3_EEEmEEbRKT_RKT0_:
  |   21|      4|  inline bool Has( const MAP_T & in_map, const KEY_T & key ) {
  |   22|      4|    return in_map.find(key) != in_map.end();
  |   23|      4|  }/*_FORCE_COVER_END_*/
  ------------------
   24|       |
   25|       |
   26|       |  /// Take any map, run find() member function, and return the result found
   27|       |  /// (or default value if no results found).
   28|       |  /*_FORCE_COVER_START_*/template <class MAP_T, class KEY_T>
   29|      4|  inline auto Find( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {
   30|      4|    auto val_it = in_map.find(key);
   31|      4|    if (val_it == in_map.end()) return dval;
   32|      2|    return val_it->second;
   33|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4FindISt3mapIicSt4lessIiESaISt4pairIKicEEEiEEDaRKT_RKT0_RKNSA_11mapped_typeE:
  |   29|      2|  inline auto Find( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {
  |   30|      2|    auto val_it = in_map.find(key);
  |   31|      2|    if (val_it == in_map.end()) return dval;
  |   32|      1|    return val_it->second;
  |   33|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4FindISt3mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_St4lessIS7_ESaISt4pairIKS7_S7_EEEA2_cEEDaRKT_RKT0_RKNSH_11mapped_typeE:
  |   29|      2|  inline auto Find( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {
  |   30|      2|    auto val_it = in_map.find(key);
  |   31|      2|    if (val_it == in_map.end()) return dval;
  |   32|      1|    return val_it->second;
  |   33|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   34|       |
   35|       |
   36|       |  /// Take any map and element, run find() member function, and return a reference to
   37|       |  /// the result found (or default value if no results found).
   38|       |  /*_FORCE_COVER_START_*/template <class MAP_T, class KEY_T>
   39|      1|  inline const auto & FindRef( const MAP_T & in_map, const KEY_T & key, const typename MAP_T::mapped_type & dval) {
   40|      1|    auto val_it = in_map.find(key);
   41|      1|    if (val_it == in_map.end()) return dval;
   42|      1|    return val_it->second;
   43|      1|  }/*_FORCE_COVER_END_*/
   44|       |
   45|       |
   46|       |  // The following two functions are from:
   47|       |  // http://stackoverflow.com/questions/5056645/sorting-stdmap-using-value
   48|       |
   49|       |  /// Take an std::pair<A,B> and return the flipped pair std::pair<B,A>
   50|       |  /*_FORCE_COVER_START_*/template<typename A, typename B> constexpr std::pair<B,A> flip_pair(const std::pair<A,B> &p)
   51|      5|  {
   52|      5|    return std::pair<B,A>(p.second, p.first);
   53|      5|  }/*_FORCE_COVER_END_*/
   54|       |
   55|       |  /// Take an std::map<A,B> and return the flipped map (now multimap to be safe): std::multimap<B,A>
   56|       |  /*_FORCE_COVER_START_*/template<typename A, typename B> std::multimap<B,A> flip_map(const std::map<A,B> &src)
   57|      1|  {
   58|      1|    std::multimap<B,A> dst;
   59|      5|    for (const auto & x : src) dst.insert( flip_pair(x) );
   60|      1|    return dst;
   61|      1|  }/*_FORCE_COVER_END_*/
   62|       |}
   63|       |
   64|       |#endif
   65|       |

/home/emily/repos/Empirical_Tests/source/tools/math.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file  math.h
    7|       | *  @brief Useful mathematical functions (that are constexpr when possible.)
    8|       | *  @note Status: BETA (though new functions are added frequently)
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_MATH_H
   13|       |#define EMP_MATH_H
   14|       |
   15|       |#include <initializer_list>
   16|       |#include <algorithm>
   17|       |#include <cmath>
   18|       |
   19|       |#include "../base/assert.h"
   20|       |#include "../meta/reflection.h"
   21|       |#include "const.h"
   22|       |
   23|       |namespace emp {
   24|       |
   25|       |  /// % is actually remainder; Mod is a proper modulus command that handles negative #'s correctly
   26|      7|  inline constexpr int Mod(int in_val, int mod_val) {
   27|      7|    emp_assert(mod_val != 0);
   28|      7|    in_val %= mod_val;
   29|      7|    return (in_val < 0) ? (in_val + mod_val) : in_val;
   30|      7|  }
   31|       |
   32|       |  /// Regular Mod doesn't work on doubles.  Build one that does!
   33|       |  // @CAO Make constexpr?
   34|      0|  inline double Mod(double in_val, double mod_val) {
   35|      0|    emp_assert(mod_val != 0);
   36|      0|    const double remain = std::remainder(in_val, mod_val);
   37|      0|    return (remain < 0.0) ? (remain + mod_val) : remain;
   38|      0|  }
   39|       |
   40|       |  /// Find the absolute value for any variable.
   41|       |  /*_FORCE_COVER_START_*/template <typename T> constexpr T Abs(T in) { return (in > 0) ? in : (-in); }/*_FORCE_COVER_END_*/
   42|       |
   43|       |  /// Run both min and max on a value to put it into a desired range.
   44|     10|  /*_FORCE_COVER_START_*/template <typename TYPE> constexpr TYPE ToRange(const TYPE & value, const TYPE & in_min, const TYPE & in_max) {
   45|     10|    emp_assert(in_min <= in_max);
   46|     10|    return (value < in_min) ? in_min : ((value > in_max) ? in_max : value);
   47|     10|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7ToRangeIiEET_RKS1_S3_S3_:
  |   44|      8|  /*_FORCE_COVER_START_*/template <typename TYPE> constexpr TYPE ToRange(const TYPE & value, const TYPE & in_min, const TYPE & in_max) {
  |   45|      8|    emp_assert(in_min <= in_max);
  |   46|      8|    return (value < in_min) ? in_min : ((value > in_max) ? in_max : value);
  |   47|      8|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp7ToRangeIdEET_RKS1_S3_S3_:
  |   44|      2|  /*_FORCE_COVER_START_*/template <typename TYPE> constexpr TYPE ToRange(const TYPE & value, const TYPE & in_min, const TYPE & in_max) {
  |   45|      2|    emp_assert(in_min <= in_max);
  |   46|      2|    return (value < in_min) ? in_min : ((value > in_max) ? in_max : value);
  |   47|      2|  }/*_FORCE_COVER_END_*/
  ------------------
   48|       |
   49|       |  /// Min of only one element is that element itself!
   50|      4|  /*_FORCE_COVER_START_*/template <typename T> constexpr T Min(T in1) { return in1; }/*_FORCE_COVER_END_*/
   51|       |
   52|       |  /// Min of multiple elements is solved recursively.
   53|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
   54|      9|  constexpr T Min(T in1, T in2, Ts... extras) {
   55|      9|    T cur_result = Min(in2, extras...);
   56|      9|    return (in1 < cur_result) ? in1 : cur_result;
   57|      9|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJEEET_S1_S1_DpT0_:
  |   54|      3|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      3|    T cur_result = Min(in2, extras...);
  |   56|      3|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiiiiiiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiiiiiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiiiiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiiiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MinIiJiEEET_S1_S1_DpT0_:
  |   54|      1|  constexpr T Min(T in1, T in2, Ts... extras) {
  |   55|      1|    T cur_result = Min(in2, extras...);
  |   56|      1|    return (in1 < cur_result) ? in1 : cur_result;
  |   57|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   58|       |
   59|       |
   60|       |  /// Max of only one element is that element itself!
   61|      4|  /*_FORCE_COVER_START_*/template <typename T> constexpr T Max(T in1) { return in1; }/*_FORCE_COVER_END_*/
   62|       |
   63|       |  /// Max of multiple elements is solved recursively.
   64|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
   65|      9|  constexpr T Max(T in1, T in2, Ts... extras) {
   66|      9|    T cur_result = Max(in2, extras...);
   67|      9|    return (in1 < cur_result) ? cur_result : in1;
   68|      9|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJEEET_S1_S1_DpT0_:
  |   65|      3|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      3|    T cur_result = Max(in2, extras...);
  |   67|      3|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiiiiiiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiiiiiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiiiiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiiiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3MaxIiJiEEET_S1_S1_DpT0_:
  |   65|      1|  constexpr T Max(T in1, T in2, Ts... extras) {
  |   66|      1|    T cur_result = Max(in2, extras...);
  |   67|      1|    return (in1 < cur_result) ? cur_result : in1;
  |   68|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   69|       |
   70|       |  /// MinRef works like Min, but never copies any inputs; always treats as references.
   71|       |  /// MinRef of only one element returns reference to that element itself!
   72|       |  /*_FORCE_COVER_START_*/template <typename T> constexpr const T & MinRef(const T& in1) { return in1; }/*_FORCE_COVER_END_*/
   73|       |
   74|       |  /// MinRef of multiple elements returns reference to minimum value.
   75|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
   76|       |  constexpr const T & MinRef(const T& in1, const T& in2, const Ts&... extras) {
   77|       |    const T & cur_result = MinRef(in2, extras...);
   78|       |    return (in1 < cur_result) ? in1 : cur_result;
   79|       |  }/*_FORCE_COVER_END_*/
   80|       |
   81|       |
   82|       |  /// MaxRef works like Max, but never copies any inputs; always treats as references.
   83|       |  /// MaxRef of only one element returns reference to that element itself!
   84|       |  /*_FORCE_COVER_START_*/template <typename T> constexpr const T & MaxRef(const T& in1) { return in1; }/*_FORCE_COVER_END_*/
   85|       |
   86|       |  /// MaxRef of multiple elements returns reference to maximum value.
   87|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
   88|       |  constexpr const T & MaxRef(const T& in1, const T& in2, const Ts&... extras) {
   89|       |    const T & cur_result = MaxRef(in2, extras...);
   90|       |    return (in1 < cur_result) ? cur_result : in1;
   91|       |  }/*_FORCE_COVER_END_*/
   92|       |
   93|       |
   94|       |  namespace internal {
   95|       |    // A compile-time log calculator for values [1,2)
   96|     32|    static constexpr double Log2_base(double x) {
   97|     32|      emp_assert(x > 0);
   98|     32|      return log2_chart_1_2[(int)((x-1.0)*1024)];
   99|     32|      // return InterpolateTable(log2_chart_1_2, x-1.0, 1024);
  100|     32|    }
  101|       |
  102|       |    // A compile-time log calculator for values < 1
  103|     81|    static constexpr double Log2_frac(double x) {
  104|     81|      emp_assert(x > 0);
  105|     81|      return (x >= 1.0) ? Log2_base(x) : (Log2_frac(x*2.0) - 1.0);
  106|     81|    }
  107|       |
  108|       |    // A compile-time log calculator for values >= 2
  109|      4|    static constexpr double Log2_pos(double x) {
  110|      4|      emp_assert(x > 0);
  111|      4|      emp_assert(x != INFINITY);
  112|      4|      return (x < 2.0) ? Log2_base(x) : (Log2_pos(x/2.0) + 1.0);
  113|      4|    }
  114|       |
  115|       |  }
  116|       |
  117|       |  /// @endcond
  118|       |
  119|       |  /// Compile-time log base 2 calculator.
  120|     32|  static constexpr double Log2(double x) {
  121|     32|    emp_assert(x > 0);
  122|     32|    return (x < 1.0) ? internal::Log2_frac(x) : internal::Log2_pos(x);
  123|     32|  }
  124|       |
  125|       |  /// Compile-time log calculator
  126|      0|  static constexpr double Log(double x, double base=10.0) { return Log2(x) / Log2(base); }
  127|       |  /// Compile-time natural log calculator
  128|      0|  static constexpr double Ln(double x) { return Log(x, emp::E); }   // Natural Log...
  129|       |  /// Compile-time log base 10 calculator.
  130|      0|  static constexpr double Log10(double x) { return Log(x, 10.0); }
  131|       |
  132|       |  /// A simple function to square a value.
  133|       |  /*_FORCE_COVER_START_*/template <typename T>
  134|      2|  static constexpr T Square(T val) { return val * val; }/*_FORCE_COVER_END_*/
  135|       |
  136|       |  // Pow helper functions.
  137|       |  namespace internal {
  138|    462|    static constexpr double Pow2_lt1(double exp, int id=0) {
  139|    462|      return (id==32) ? 1.0 :
  140|    462|        ( (exp > 0.5) ? (pow2_chart_bits[id]*Pow2_lt1(exp*2.0-1.0,id+1)) : Pow2_lt1(exp*2.0,id+1) );
  141|    462|    }
  142|       |
  143|     36|    static constexpr double Pow2_impl(double exp) {
  144|     36|      return (exp >= 1.0) ? (2.0*Pow2_impl(exp-1.0)) : Pow2_lt1(exp);
  145|     36|    }
  146|       |  }
  147|       |
  148|       |  /// A fast (O(log p)) integral-power command.
  149|       |  /*_FORCE_COVER_START_*/template <typename T>
  150|      7|  static constexpr type_if<T, std::is_integral> Pow(T base, T p) {
  151|      7|    if (p <= 0) return 1;
  152|      5|    if (p & 1) return base * Pow(base, p-1); // Odd exponent: strip one mulitple off and recurse.
  153|      2|    return Square( Pow(base,p/2) );          // Even exponent: calc for half and square result.
  154|      2|  }/*_FORCE_COVER_END_*/
  155|       |
  156|       |  /// A fast 2^x command.
  157|     14|  static constexpr double Pow2(double exp) {
  158|     14|    return (exp < 0.0) ? (1.0/internal::Pow2_impl(-exp)) : internal::Pow2_impl(exp);
  159|     14|  }
  160|       |
  161|       |  /// A fast method for calculating exponents for int types.
  162|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
  163|     59|  static constexpr TYPE IntPow(TYPE base, TYPE exp) {
  164|     59|    emp_assert(exp < 65536); // Set a crazy-high limit for exp to identify problems...
  165|     59|    return exp < 1 ? 1 : (base * IntPow(base, exp-1));
  166|     59|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3empL6IntPowIiEET_S1_S1_:
  |  163|      5|  static constexpr TYPE IntPow(TYPE base, TYPE exp) {
  |  164|      5|    emp_assert(exp < 65536); // Set a crazy-high limit for exp to identify problems...
  |  165|      5|    return exp < 1 ? 1 : (base * IntPow(base, exp-1));
  |  166|      5|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3empL6IntPowIdEET_S1_S1_:
  |  163|     54|  static constexpr TYPE IntPow(TYPE base, TYPE exp) {
  |  164|     54|    emp_assert(exp < 65536); // Set a crazy-high limit for exp to identify problems...
  |  165|     54|    return exp < 1 ? 1 : (base * IntPow(base, exp-1));
  |  166|     54|  }/*_FORCE_COVER_END_*/
  ------------------
  167|       |
  168|       |  /// A fast method for calculating exponents on doubles.
  169|     32|  static constexpr double Pow(double base, double exp) {
  170|     32|    // Normally, convert to a base of 2 and then use Pow2.
  171|     32|    // If base is negative, we don't want to deal with imaginary numbers, so use IntPow.
  172|     32|    return (base > 0) ? Pow2(Log2(base) * exp) : IntPow(base,exp);
  173|     32|  }
  174|       |
  175|       |  // A fast (O(log p)) integer-power command.
  176|       |  // static constexpr int Pow(int base, int p) {
  177|       |  //   return (p <= 0) ? 1 : (base * Pow(base, p-1));
  178|       |  // }
  179|       |
  180|       |  /// A fast method of calculating e^x
  181|      0|  static constexpr double Exp(double exp) {
  182|      0|    return Pow2(Log2(emp::E) * exp);  // convert to a base of e.
  183|      0|  }
  184|       |
  185|       |
  186|       |  /// A compile-time int-log calculator (aka, significant bits)
  187|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
  188|       |  static constexpr int IntLog2(TYPE x) { return x <= 1 ? 0 : (IntLog2(x/2) + 1); }/*_FORCE_COVER_END_*/
  189|       |
  190|       |  /// A compile-time bit counter.
  191|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
  192|       |  static constexpr int CountOnes(TYPE x) { return x == 0 ? 0 : (CountOnes(x/2) + (x&1)); }/*_FORCE_COVER_END_*/
  193|       |
  194|       |  /// Quick bit-mask generator for low bits.
  195|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
  196|      7|  static constexpr TYPE MaskLow(std::size_t num_bits) {
  197|      7|    return (num_bits == 8*sizeof(TYPE)) ? ((TYPE)-1) : ((((TYPE)1) << num_bits) - 1);
  198|      7|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3empL7MaskLowImEET_m
  ------------------
  | test_tools.cc:_ZN3empL7MaskLowIjEET_m:
  |  196|      7|  static constexpr TYPE MaskLow(std::size_t num_bits) {
  |  197|      7|    return (num_bits == 8*sizeof(TYPE)) ? ((TYPE)-1) : ((((TYPE)1) << num_bits) - 1);
  |  198|      7|  }/*_FORCE_COVER_END_*/
  ------------------
  199|       |
  200|       |  /// Quick bit-mask generator for high bits.
  201|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
  202|       |  static constexpr TYPE MaskHigh(std::size_t num_bits) {
  203|       |    return MaskLow<TYPE>(num_bits) << (8*sizeof(TYPE)-num_bits);
  204|       |  }/*_FORCE_COVER_END_*/
  205|       |
  206|       |  /// Return the minimum of three values.
  207|  1.21k|  /*_FORCE_COVER_START_*/template <typename T> constexpr const T & Min(const T& in1, const T& in2, const T& in3) {
  208|  1.21k|    return std::min(std::min(in1,in2), in3);
  209|  1.21k|  }/*_FORCE_COVER_END_*/
  210|       |
  211|       |  /// A version of Min that allows a variable number of inputs to be compared.
  212|       |  /*_FORCE_COVER_START_*/template <typename T> const T & Min(std::initializer_list<const T&> lst) {
  213|       |    emp_assert(lst.size > 0); // Nothing to return if nothing in the list!
  214|       |    auto min_found = lst.begin();
  215|       |    for (auto it = lst.begin()+1; it < lst.end(); it++) {
  216|       |      if (*it < *min_found) min_found = it;
  217|       |    }
  218|       |    return *min_found;
  219|       |  }/*_FORCE_COVER_END_*/
  220|       |
  221|       |  /// A version of Max that allows a variable number of inputs to be compared.
  222|       |  /*_FORCE_COVER_START_*/template <typename T> const T & Max(std::initializer_list<const T&> lst) {
  223|       |    emp_assert(lst.size > 0); // Nothing to return if nothing in the list!
  224|       |    auto max_found = lst.begin();
  225|       |    for (auto it = lst.begin()+1; it < lst.end(); it++) {
  226|       |      if (*it > *max_found) max_found = it;
  227|       |    }
  228|       |    return *max_found;
  229|       |  }/*_FORCE_COVER_END_*/
  230|       |
  231|       |
  232|       |}
  233|       |
  234|       |#endif
  235|       |

/home/emily/repos/Empirical_Tests/source/tools/mem_track.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2015-2017
    5|       | *
    6|       | *  @file  mem_track.h
    7|       | *  @brief A set of macros to track how many instances of specific classes are made.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  One way of tracking memory leaks is to simply count instances of classes.  The macros here
   11|       | *  simplify this process.
   12|       | *
   13|       | *  To setup, every constructor for a class must incude EMP_TRACK_CONSTRUCT(CLASS_NAME),
   14|       | *  and every destructor must have EMP_TRACK_DESTRUCT(CLASS_NAME).  Make sure to avoid
   15|       | *  implicit constructors/destructors or counts will be off.
   16|       | *
   17|       | *  To collect information, EMP_TRACK_COUNT(CLASS_NAME) will provide the current count
   18|       | *  for a specific class, and EMP_TRACK_STATUS will translate into a string providing
   19|       | *  information about all available classes.
   20|       | *
   21|       | *  Developer notes:
   22|       | *  @todo Currently having issues with the memory map corruption.  Perhaps it needs to use onload?
   23|       | *   Also, can try using JS maps instead?  (only when using Emscripten.)
   24|       | */
   25|       |
   26|       |#ifndef EMP_MEM_TRACK
   27|       |#define EMP_MEM_TRACK
   28|       |
   29|       |
   30|       |// If EMP_NDEBUG is turned on, turn off mem checks.
   31|       |#ifdef EMP_NDEBUG
   32|       |#define EMP_NO_MEM_CHECK
   33|       |#endif
   34|       |
   35|       |
   36|       |#include <map>
   37|       |#include <string>
   38|       |#include <sstream>
   39|       |
   40|       |#include "alert.h"
   41|       |
   42|       |#ifdef EMP_NO_MEM_CHECK
   43|       |
   44|       |#define EMP_TRACK_CONSTRUCT(CLASS_NAME)
   45|       |#define EMP_TRACK_DESTRUCT(CLASS_NAME)
   46|       |#define EMP_TRACK_COUNT(CLASS_NAME) 0
   47|       |#define EMP_TRACK_STATUS std::string("(not in debug mode)")
   48|       |
   49|       |#else  // DEBUG MODE!
   50|       |
   51|  1.00k|#define EMP_TRACK_CONSTRUCT(CLASS_NAME) emp::internal::TrackMem_Inc(#CLASS_NAME)
   52|    501|#define EMP_TRACK_DESTRUCT(CLASS_NAME) emp::internal::TrackMem_Dec(#CLASS_NAME)
   53|       |#define EMP_TRACK_COUNT(CLASS_NAME) emp::internal::TrackMem_Count(#CLASS_NAME)
   54|       |#define EMP_TRACK_STATUS emp::internal::TrackMem_Status()
   55|       |
   56|       |namespace emp {
   57|       |
   58|       |  namespace internal {
   59|       |
   60|  1.50k|    static std::map<std::string,int> & TrackMem_GetMap() {
   61|  1.50k|      static std::map<std::string,int> * track_mem_class_map = nullptr;
   62|  1.50k|      if (!track_mem_class_map) track_mem_class_map = new std::map<std::string,int>;
   63|  1.50k|      return *track_mem_class_map;
   64|  1.50k|    }
   65|       |
   66|      0|    static std::string TrackMem_Status() {
   67|      0|      auto & mem_map = TrackMem_GetMap();
   68|      0|
   69|      0|      std::stringstream ss;
   70|      0|      for (auto stat : mem_map) {
   71|      0|        ss << "[" << stat.first << "] : " << stat.second << std::endl;
   72|      0|      }
   73|      0|      return ss.str();
   74|      0|    }
   75|       |
   76|  1.00k|    static void TrackMem_Inc(const std::string & class_name) {
   77|  1.00k|      (void) class_name;
   78|  1.00k|      auto & mem_map = TrackMem_GetMap();
   79|  1.00k|      if (mem_map.find(class_name) == mem_map.end()) {
   80|      2|        mem_map[class_name] = 0;
   81|      2|      }
   82|  1.00k|      mem_map[class_name]++;
   83|  1.00k|    }
   84|       |
   85|    501|    static void TrackMem_Dec(const std::string & class_name) {
   86|    501|      (void) class_name;
   87|    501|      auto & mem_map = TrackMem_GetMap();
   88|    501|
   89|    501|      // Make sure we are not trying to delete a class that was never registered!
   90|    501|      if (mem_map.find(class_name) == mem_map.end()) {
   91|      0|        emp::CappedAlert(3, "Trying to delete unknown: [", class_name,
   92|      0|                         "]; map size = ", mem_map.size());
   93|      0|        abort();
   94|      0|      }
   95|    501|      mem_map[class_name]--;
   96|    501|      if (mem_map[class_name] < 0) {
   97|      0|        emp::CappedAlert(3, "Trying to delete too many: ", class_name);
   98|      0|        abort();
   99|      0|      }
  100|    501|    }
  101|       |
  102|      0|    static int TrackMem_Count(const std::string & class_name) {
  103|      0|      (void) class_name;
  104|      0|      auto & mem_map = TrackMem_GetMap();
  105|      0|
  106|      0|      if (mem_map.find(class_name) == mem_map.end()) {
  107|      0|        return 0;
  108|      0|      }
  109|      0|      return mem_map[class_name];
  110|      0|    }
  111|       |
  112|       |  }
  113|       |
  114|       |}
  115|       |#endif
  116|       |
  117|       |
  118|       |#endif
  119|       |

/home/emily/repos/Empirical_Tests/source/tools/memo_function.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  memo_function.h
    7|       | *  @brief A function that memorizes previous results to speed up any repeated calls.
    8|       | *  @note Status: BETA (though new functions are added frequently)
    9|       | */
   10|       |
   11|       |#ifndef EMP_MEMO_FUNCTIONS_H
   12|       |#define EMP_MEMO_FUNCTIONS_H
   13|       |
   14|       |#include <unordered_map>
   15|       |
   16|       |#include "../base/assert.h"
   17|       |#include "../meta/meta.h"
   18|       |
   19|       |#include "tuple_utils.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  /// Identical to std::function, but memorizes prior results (caches them) so that the function
   24|       |  /// doesn't have to process those results again.  (note: Genetic version is undefinined; must have
   25|       |  /// a function signature.)
   26|       |  template <class T> class memo_function;    // Not defined.
   27|       |
   28|       |  // Single argument functions don't need a tuple...
   29|       |  template <class R, class ARG>
   30|       |  class memo_function<R(ARG)> {
   31|       |  public:
   32|       |    using size_t = std::size_t;
   33|       |    using return_t = R;
   34|       |    using index_t = std::decay_t<ARG>;
   35|       |    using fun_t = std::function<R(ARG)>;
   36|       |    using this_t = memo_function<R(ARG)>;
   37|       |
   38|       |  private:
   39|       |    mutable std::unordered_map<index_t, return_t> cache_map; ///< Cached results.
   40|       |    fun_t fun;                                               ///< Function to call.
   41|       |
   42|       |  public:
   43|       |    /*_FORCE_COVER_START_*/template <typename T>
   44|       |    memo_function(T && fun_info) : cache_map(), fun(std::forward<T>(fun_info)) { ; }/*_FORCE_COVER_END_*/
   45|       |    memo_function(const this_t &) = default;
   46|       |    memo_function(this_t &&) = default;
   47|      1|    memo_function() : cache_map(), fun() { ; }
   48|       |
   49|       |    /// Copy another memo_function of the same type.
   50|       |    this_t & operator=(const this_t &) = default;
   51|       |
   52|       |    /// Move to here another memo function of the same type.
   53|       |    this_t & operator=(this_t &&) = default;
   54|       |
   55|       |    /// Set a new std::function of the appropriate type.
   56|       |    this_t & operator=(const fun_t & _f) { cache_map.clear(); fun=_f; return *this; }
   57|       |
   58|       |    /// Move to here an std::function of the appropriate type.
   59|       |    this_t & operator=(fun_t && _f) { cache_map.clear(); fun=std::move(_f); return *this; }
   60|       |    /*_FORCE_COVER_START_*/template <typename T>
   61|       |
   62|       |    /// A universal copy/move for other combinations that work with std::function.
   63|      1|    this_t & operator=(T && arg) { cache_map.clear(); fun = std::forward<T>(arg); return *this; }/*_FORCE_COVER_END_*/
   64|       |
   65|       |    /// How many values have been cached?
   66|       |    size_t size() const { return cache_map.size(); }
   67|       |
   68|       |    /// Test if a certain input has been cached.
   69|       |    bool Has(const ARG & k) const { return cache_map.find(k) != cache_map.end(); }
   70|       |
   71|       |    /// Clear out the cache.
   72|       |    void Clear() { cache_map.clear(); }
   73|       |
   74|       |    /// Erase a specific entry from the cache.
   75|       |    void Erase(const ARG & k) { cache_map.erase(k); }
   76|       |
   77|       |    /// Call the memo_function.
   78|       |    /*_FORCE_COVER_START_*/template <class KEY>
   79|    159|    return_t operator()(KEY && k) const {
   80|    159|      emp_assert(fun);
   81|    159|      auto cache_it = cache_map.find(k);
   82|    159|      if (cache_it != cache_map.end()) return cache_it->second;
   83|     81|      const return_t result = fun(k);
   84|     81|      return cache_map.emplace(std::forward<KEY>(k), result).first->second;
   85|     81|    }/*_FORCE_COVER_END_*/
   86|       |
   87|       |    /// Identify if the memo_function has been set.
   88|       |    operator bool() const { return (bool) fun; }
   89|       |
   90|       |    /// Convert a memo_function to a regular std::function for function calls.
   91|       |    operator std::function<R(ARG)>() {
   92|       |      return [this](const ARG & arg){ return operator()(arg); };
   93|       |    }
   94|       |
   95|       |    /// Convert a memo_function to a regular std::function for function calls.
   96|       |    std::function<R(ARG)> to_function() {
   97|       |      return [this](const ARG & arg){ return operator()(arg); };
   98|       |    }
   99|       |  };
  100|       |
  101|       |  // Specialization for when we have more than one argument...  we need to convert inputs
  102|       |  // to a tuple to make this work.
  103|       |  template <class R, class A1, class A2, class... EXTRA>
  104|       |  class memo_function<R(A1,A2,EXTRA...)> {
  105|       |  public:
  106|       |    using size_t = std::size_t;
  107|       |    using return_t = R;
  108|       |    using fun_t = std::function<R(A1,A2,EXTRA...)>;
  109|       |    using hash_t = emp::TupleHash<A1,A2,EXTRA...>;
  110|       |    using this_t = memo_function<R(A1,A2,EXTRA...)>;
  111|       |    using tuple_t = std::tuple<std::decay_t<A1>,std::decay_t<A2>,std::decay_t<EXTRA>...>;
  112|       |
  113|       |  private:
  114|       |    std::unordered_map<tuple_t, return_t, hash_t> cache_map;
  115|       |    fun_t fun;
  116|       |
  117|       |  public:
  118|       |    /*_FORCE_COVER_START_*/template <typename... Ts>
  119|       |    memo_function(Ts &&... args) : cache_map(), fun(std::forward<Ts>(args)...) { ; }/*_FORCE_COVER_END_*/
  120|       |    memo_function(const memo_function &) = default;
  121|       |    memo_function(memo_function &&) = default;
  122|       |
  123|       |    this_t & operator=(const this_t &) = default;
  124|       |    this_t & operator=(this_t &&) = default;
  125|       |    this_t & operator=(const fun_t & _f) { cache_map.clear(); fun=_f; return *this; }
  126|       |    this_t & operator=(fun_t && _f) { cache_map.clear(); fun=std::move(_f); return *this; }
  127|       |    /*_FORCE_COVER_START_*/template <typename T>
  128|       |    this_t & operator=(T && arg) { cache_map.clear(); fun = std::forward<T>(arg); return *this; }/*_FORCE_COVER_END_*/
  129|       |
  130|       |    size_t size() const { return cache_map.size(); }
  131|       |
  132|       |    inline static size_t Hash(const A1 & k1, const A2 & k2, const EXTRA &... k_extra) {
  133|       |      return CombineHash(k1,k2,k_extra...);
  134|       |    }
  135|       |    bool Has(const A1 & k1, const A2 & k2, const EXTRA &... k_extra) const {
  136|       |      return cache_map.find(std::make_tuple(k1,k2,k_extra...)) != cache_map.end();
  137|       |    }
  138|       |    void Clear() { cache_map.clear(); }
  139|       |    void Erase(const A1 & k1, const A2 & k2, const EXTRA &... k_extra) {
  140|       |      cache_map.erase(std::make_tuple(k1,k2,k_extra...));
  141|       |    }
  142|       |
  143|       |    return_t operator()(const A1 & k1, const A2 & k2, const EXTRA &... k_extra) {
  144|       |      emp_assert(fun); // Function must be specified with Get() -or- already set.
  145|       |      auto cache_it = cache_map.find(std::make_tuple(k1,k2,k_extra...));
  146|       |      if (cache_it != cache_map.end()) return cache_it->second;
  147|       |      return cache_map.emplace(std::make_tuple(k1,k2,k_extra...),
  148|       |                               fun(k1, k2, k_extra...)).first->second;
  149|       |    }
  150|       |
  151|       |    operator bool() const { return (bool) fun; }
  152|       |
  153|       |    // A memo_function can be converted to a regular std::function for function calls.
  154|       |    operator std::function<R(A1,A2,EXTRA...)>() const {
  155|       |      return [this](A1 k1, A2 k2, EXTRA... k_extra) {
  156|       |         return operator()(k1, k2, k_extra...);
  157|       |      };
  158|       |    }
  159|       |    std::function<R(A1,A2,EXTRA...)> to_function() const {
  160|       |      return [this](A1 k1, A2 k2, EXTRA... k_extra) {
  161|       |         return operator()(k1, k2, k_extra...);
  162|       |      };
  163|       |    }
  164|       |  };
  165|       |
  166|       |  // Single argument functions don't need a tuple...
  167|       |  template <class R>
  168|       |  class memo_function<R()> {
  169|       |  public:
  170|       |    using size_t = std::size_t;
  171|       |    using return_t = R;
  172|       |    using index_t = void;
  173|       |    using fun_t = std::function<R()>;
  174|       |    using this_t = memo_function<R()>;
  175|       |
  176|       |  private:
  177|       |    return_t cached_value;
  178|       |    bool has_cache;
  179|       |    fun_t fun;
  180|       |
  181|       |  public:
  182|       |    /*_FORCE_COVER_START_*/template <typename T>
  183|       |    memo_function(T && fun_info) : cached_value(), has_cache(false), fun(std::forward<T>(fun_info)) { ; }/*_FORCE_COVER_END_*/
  184|       |    memo_function(const this_t &) = default;
  185|       |    memo_function(this_t &&) = default;
  186|       |    memo_function() : has_cache(false) { ; }
  187|       |
  188|       |    this_t & operator=(const this_t &) = default;
  189|       |    this_t & operator=(this_t &&) = default;
  190|       |    this_t & operator=(const fun_t & _f) { has_cache=false; fun=_f; return *this; }
  191|       |    this_t & operator=(fun_t && _f) { has_cache=false; fun=std::move(_f); return *this; }
  192|       |    /*_FORCE_COVER_START_*/template <typename T>
  193|       |    this_t & operator=(T && arg) { has_cache=false; fun = std::forward<T>(arg); return *this; }/*_FORCE_COVER_END_*/
  194|       |
  195|       |    size_t size() const { return (size_t) has_cache; }
  196|       |
  197|       |    bool Has() const { return has_cache; }
  198|       |    void Clear() { has_cache=false; }
  199|       |    void Erase() { has_cache=false; }
  200|       |
  201|       |    return_t operator()() {
  202|       |      emp_assert(fun);
  203|       |      if (has_cache == false) { cached_value = fun(); has_cache = true; }
  204|       |      return cached_value;
  205|       |    }
  206|       |
  207|       |    operator bool() { return (bool) fun; }
  208|       |
  209|       |    // A memo_function can be converted to a regular std::function for function calls.
  210|       |    operator std::function<R()>() {
  211|       |      return [this](){ return operator()(); };
  212|       |    }
  213|       |    std::function<R()> to_function() {
  214|       |      return [this](){ return operator()(); };
  215|       |    }
  216|       |  };
  217|       |
  218|       |}
  219|       |
  220|       |#endif
  221|       |

/home/emily/repos/Empirical_Tests/source/tools/random_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file  random_utils.h
    7|       | *  @brief Helper functions for emp::Random for common random tasks.
    8|       | *  @note Status: RELEASE
    9|       | */
   10|       |
   11|       |#ifndef EMP_RANDOM_UTILS_H
   12|       |#define EMP_RANDOM_UTILS_H
   13|       |
   14|       |#include "../base/vector.h"
   15|       |#include "BitVector.h"
   16|       |#include "Random.h"
   17|       |
   18|       |namespace emp {
   19|       |
   20|       |  /// Randomly reorder all of the elements in a vector.
   21|       |  /// If max_count is provided, just make sure that the first max_count entries are randomly
   22|       |  /// drawn from entire vector.
   23|       |
   24|       |  /*_FORCE_COVER_START_*/template <typename T>
   25|       |  inline void Shuffle(Random & random, emp::vector<T> & v, size_t max_count)
   26|      1|  {
   27|     22|    for (size_t i = 0; i < max_count; i++) {
   28|     21|      const size_t pos = random.GetUInt(i, v.size());
   29|     21|      if (pos == i) continue;
   30|     14|      std::swap(v[i], v[pos]);
   31|     14|    }
   32|      1|  }/*_FORCE_COVER_END_*/
   33|       |
   34|       |  /*_FORCE_COVER_START_*/template <typename T>
   35|      1|  inline void Shuffle(Random & random, emp::vector<T> & v) { Shuffle(random, v, v.size()); }/*_FORCE_COVER_END_*/
   36|       |
   37|       |
   38|       |  /// Return an emp::vector<int> numbered 0 through size-1 in a random order.
   39|       |
   40|      0|  inline emp::vector<size_t> GetPermutation(Random & random, size_t size) {
   41|      0|    emp::vector<size_t> seq(size);
   42|      0|    seq[0] = 0;
   43|      0|    for (size_t i = 1; i < size; i++) {
   44|      0|      size_t val_pos = random.GetUInt(i+1);
   45|      0|      seq[i] = seq[val_pos];
   46|      0|      seq[val_pos] = i;
   47|      0|    }
   48|      0|    return seq;
   49|      0|  }
   50|       |
   51|       |  /// Choose K positions from N possibilities.
   52|       |
   53|      1|  inline void Choose(Random & random, size_t N, size_t K, std::vector<size_t> & choices) {
   54|      1|    emp_assert (N >= K);
   55|      1|
   56|      1|    choices.resize(K);
   57|     93|    while (K) {
   58|     92|      if (N==K || random.P(((double) K)/((double) N))) { choices[--K] = --N; }
   59|     82|      else --N;
   60|     92|    }
   61|      1|  }
   62|       |
   63|      1|  inline std::vector<size_t> Choose(Random & random, size_t N, size_t K) {
   64|      1|    std::vector<size_t> choices;
   65|      1|    Choose(random,N,K,choices);
   66|      1|    return choices;
   67|      1|  }
   68|       |
   69|       |
   70|       |  /// Generate a random BitVector of the specified size.
   71|       |  inline BitVector RandomBitVector(Random & random, size_t size, double p=0.5)
   72|      0|  {
   73|      0|    emp_assert(p >= 0.0 && p <= 1.0);
   74|      0|    BitVector bits(size);
   75|      0|    for (size_t i = 0; i < size; i++) bits[i] = random.P(p);
   76|      0|    return bits;
   77|      0|  }
   78|       |
   79|       |  /// Generate a random double vector in the specified range.
   80|      0|  inline emp::vector<double> RandomDoubleVector(Random & random, size_t size, double min, double max) {
   81|      0|    emp::vector<double> vals(size);
   82|      0|    for (double & v : vals) v = random.GetDouble(min, max);
   83|      0|    return vals;
   84|      0|  }
   85|       |
   86|       |  /// Generate a random size_t vector in the specified range.
   87|      0|  inline emp::vector<size_t> RandomUIntVector(Random & random, size_t size, size_t min, size_t max) {
   88|      0|    emp::vector<size_t> vals(size);
   89|      0|    for (size_t & v : vals) v = random.GetUInt(min, max);
   90|      0|    return vals;
   91|      0|  }
   92|       |
   93|       |  /// Generate a random vector in the specified type and range.
   94|       |  /*_FORCE_COVER_START_*/template <typename T>
   95|       |  inline emp::vector<T> RandomVector(Random & random, size_t size, T min, T max) {
   96|       |    emp::vector<T> vals(size);
   97|       |    for (T & v : vals) v = (T) random.GetDouble((double) min, (double) max);
   98|       |    return vals;
   99|       |  }/*_FORCE_COVER_END_*/
  100|       |
  101|       |  /// Generate a random BitVector of the specified size.
  102|       |  inline void RandomizeBitVector(BitVector & bits, Random & random, double p=0.5)
  103|      0|  {
  104|      0|    emp_assert(p >= 0.0 && p <= 1.0);
  105|      0|    for (size_t i = 0; i < bits.size(); i++) bits[i] = random.P(p);
  106|      0|  }
  107|       |
  108|       |  /// Generate a random vector in the specified type and range.
  109|       |  /*_FORCE_COVER_START_*/template <typename T>
  110|       |  inline void RandomizeVector(emp::vector<T> & vals, Random & random, T min, T max) {
  111|       |    for (T & v : vals) v = (T) random.GetDouble((double) min, (double) max);
  112|       |  }/*_FORCE_COVER_END_*/
  113|       |}
  114|       |
  115|       |#endif
  116|       |

/home/emily/repos/Empirical_Tests/source/tools/sequence_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file sequence_utils.h
    7|       | *  @brief Functions for analyzing with generic sequence types.
    8|       | *  @note Status: BETA
    9|       | *
   10|       | *  A set of functions for analyzing sequences, including distance metrics (Hamming and
   11|       | *  Edit/Levenschtein) and alignment.
   12|       | */
   13|       |
   14|       |
   15|       |
   16|       |#ifndef EMP_SEQUENCE_UTILS_H
   17|       |#define EMP_SEQUENCE_UTILS_H
   18|       |
   19|       |#include "../base/vector.h"
   20|       |
   21|       |#include "functions.h"
   22|       |
   23|       |namespace emp {
   24|       |
   25|       |  // --- Distance functions for any array-type objects ---
   26|       |
   27|       |  /// Hamming distance is a simple count of substitutions needed to convert one array to another.
   28|       |  /// @param in1 The first sequence to compare.
   29|       |  /// @param in2 The second sequence to compare.
   30|       |  /// @param offset (optional) Position in the first sequence to start the second sequence.
   31|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
   32|      1|  size_t calc_hamming_distance(const TYPE & in1, const TYPE & in2, int offset=0) {
   33|      1|    if (offset < 0) return calc_hamming_distance(in2, in1, -offset);
   34|      1|
   35|      1|    const auto size1 = in1.size();
   36|      1|    const auto size2 = in2.size();
   37|      1|
   38|      1|    // Calculate by how much the strings overlap.
   39|      1|    size_t overlap = std::min( size1 - offset,  size2 );
   40|      1|
   41|      1|    // Initialize the distance to that part of the strings which do not overlap.
   42|      1|    size_t num_diffs = size1 + size2 - 2 * overlap;
   43|      1|
   44|      1|    // Step through the overlapped section and add on additional differences.
   45|     31|    for (size_t i = 0; i < overlap; i++) {
   46|     30|      if (in1[i + offset] != in2[i]) num_diffs++;
   47|     30|    }
   48|      1|
   49|      1|    return num_diffs;
   50|      1|  }/*_FORCE_COVER_END_*/
   51|       |
   52|       |  /// Edit distance is the minimum number of insertions, deletions and substitutions to convert
   53|       |  /// one array to another.
   54|       |  /*_FORCE_COVER_START_*/template <typename TYPE>
   55|      1|  size_t calc_edit_distance(const TYPE & in1, const TYPE & in2) {
   56|      1|    const auto size1 = in1.size();
   57|      1|    const auto size2 = in2.size();
   58|      1|
   59|      1|    // If either size is zero, other size indicates number of insertions needed to produce it.
   60|      1|    if (size1 == 0) return size2;
   61|      1|    if (size2 == 0) return size1;
   62|      1|
   63|      1|    emp::vector<size_t> cur_row(size1);   // The row we are calculating
   64|      1|    emp::vector<size_t> prev_row(size1);  // The previous row we calculated
   65|      1|
   66|      1|    // Initialize the previous row to record the differece from nothing.
   67|     31|    for (size_t i = 0; i < size1; i++) prev_row[i] = i + 1;
   68|      1|
   69|      1|    // Loop through all other rows
   70|     32|    for (size_t row = 0; row < size2; row++) {
   71|     31|      // Initialize the first entry in the current row.
   72|     31|      if (in1[0] == in2[row]) cur_row[0] = row;
   73|     30|      else cur_row[0] = std::min(row, prev_row[0]) + 1;
   74|     31|
   75|     31|      // Move through the cur_row and fill it in.
   76|    930|      for (size_t col = 1; col < size1; col++) {
   77|    899|        // If the values are equal, keep the value in the upper left.
   78|    899|        if (in1[col] == in2[row]) cur_row[col] = prev_row[col-1];
   79|    801|
   80|    801|        // Otherwise, set the current position the the minimal of the three
   81|    801|        // numbers to the upper right in the chart plus one.
   82|    801|        else {
   83|    801|          cur_row[col] = emp::Min(prev_row[col], prev_row[col-1], cur_row[col-1]) + 1;
   84|    801|        }
   85|    899|      }
   86|     31|
   87|     31|      // Swap cur_row and prev_row (keep cur vals in prev row, recycle vector cur_row)
   88|     31|      std::swap(cur_row, prev_row);
   89|     31|    }
   90|      1|
   91|      1|    // Now that we are done, return the bottom-right corner of the chart.
   92|      1|    return prev_row[size1 - 1];
   93|      1|  }/*_FORCE_COVER_END_*/
   94|       |
   95|       |  /// Use edit distance to find the minimum number of insertions, deletions and substitutions
   96|       |  /// to convert one array to another, and then insert gaps into the arrays appropriately.
   97|       |  /*_FORCE_COVER_START_*/template <typename TYPE, typename GAP_TYPE>
   98|      2|  size_t align(TYPE & in1, TYPE & in2, GAP_TYPE gap) {
   99|      2|    const auto size1 = in1.size();
  100|      2|    const auto size2 = in2.size();
  101|      2|
  102|      2|    // If either size is zero, other size indicates number of insertions needed to produce it.
  103|      2|    if (size1 == 0) return size2;
  104|      2|    if (size2 == 0) return size1;
  105|      2|
  106|      2|    emp::vector<size_t> cur_row(size1);   // The row we are calculating
  107|      2|    emp::vector<size_t> prev_row(size1);  // The previous row we calculated
  108|      2|    emp::vector<emp::vector<char> > edit_info(size2, emp::vector<char>(size1));
  109|      2|
  110|      2|    // Initialize the previous row to record the differece from nothing.
  111|     27|    for (size_t i = 0; i < size1; i++) {
  112|     25|      prev_row[i] = i + 1;
  113|     25|      edit_info[0][i] = 'i';
  114|     25|    }
  115|      2|
  116|      2|    // Loop through all other rows
  117|     33|    for (size_t row = 0; row < size2; row++) {
  118|     31|      // Initialize the first entry in the current row.
  119|     31|      if (in1[0] == in2[row]) { cur_row[0] = row; edit_info[row][0] = 's'; }
  120|     29|      else { cur_row[0] = prev_row[0] + 1; edit_info[row][0] = 'd'; }
  121|     31|
  122|     31|      // Move through the cur_row and fill it in.
  123|    461|      for (size_t col = 1; col < size1; col++) {
  124|    430|        // If the values are equal, keep the value in the upper left.
  125|    430|        if (in1[col] == in2[row]) { cur_row[col] = prev_row[col-1]; edit_info[row][col] = 's'; }
  126|    411|
  127|    411|        // Otherwise, set the current position to the minimum of the three
  128|    411|        // numbers to the left, upper, or upper left in the chart plus one.
  129|    411|        else {
  130|    411|          cur_row[col] = emp::Min(prev_row[col], prev_row[col-1], cur_row[col-1]) + 1;
  131|    411|          if (cur_row[col] == prev_row[col]+1)   { edit_info[row][col] = 'd'; }
  132|    411|          if (cur_row[col] == prev_row[col-1]+1) { edit_info[row][col] = 's'; }
  133|    411|          if (cur_row[col] == cur_row[col-1]+1)  { edit_info[row][col] = 'i'; }
  134|    411|        }
  135|    430|      }
  136|     31|
  137|     31|      // Swap cur_row and prev_row (keep cur vals in prev row, recycle vector cur_row)
  138|     31|      std::swap(cur_row, prev_row);
  139|     31|    }
  140|      2|
  141|      2|    // Fill in gaps in the sequences to make them align!
  142|      2|
  143|      2|    int c = (int) size1 - 1;
  144|      2|    int r = (int) size2 - 1;
  145|      2|    size_t length = 0;
  146|      2|
  147|     37|    while (c >= 0 || r >= 0) {
  148|     35|      if (c < 0) { ++length; --r; continue; }
  149|     35|      else if (r < 0) { ++length; --c; continue; }
  150|     35|
  151|     35|      char cur_move = edit_info[(size_t)r][(size_t)c];
  152|     35|      switch(cur_move) {
  153|     35|      case 's': --c; --r; ++length; break;
  154|     35|      case 'd': --r; ++length; break;
  155|     35|      case 'i': --c; ++length; break;
  156|     35|      };
  157|     35|    }
  158|      2|
  159|      2|    c = (int) size1-1;
  160|      2|    r = (int) size2-1;
  161|      2|
  162|      2|    TYPE out1(length, gap);
  163|      2|    TYPE out2(length, gap);
  164|      2|
  165|      2|    size_t pos = length - 1;
  166|      2|
  167|     37|    while (c >= 0 && r >= 0) {
  168|     35|      switch(edit_info[(size_t)r][(size_t)c]) {
  169|     35|      case 's': out1[pos] = in1[(size_t)c]; out2[pos] = in2[(size_t)r]; --c; --r; break;
  170|     35|      case 'd': out1[pos] = gap;    out2[pos] = in2[(size_t)r];      --r; break;
  171|     35|      case 'i': out1[pos] = in1[(size_t)c]; out2[pos] = gap;    --c;      break;
  172|     35|      };
  173|     35|      --pos;
  174|     35|    }
  175|      2|    while (c >= 0) { out1[pos] = in1[(size_t)c]; --c; --pos; }
  176|      2|    while (r >= 0) { out2[pos] = in2[(size_t)r]; --r; --pos; }
  177|      2|
  178|      2|    in1 = out1;
  179|      2|    in2 = out2;
  180|      2|
  181|      2|    // Now that we are done, return the bottom-right corner of the chart.
  182|      2|    return prev_row[size1 - 1];
  183|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5alignINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEcEEmRT_S8_T0_:
  |   98|      1|  size_t align(TYPE & in1, TYPE & in2, GAP_TYPE gap) {
  |   99|      1|    const auto size1 = in1.size();
  |  100|      1|    const auto size2 = in2.size();
  |  101|      1|
  |  102|      1|    // If either size is zero, other size indicates number of insertions needed to produce it.
  |  103|      1|    if (size1 == 0) return size2;
  |  104|      1|    if (size2 == 0) return size1;
  |  105|      1|
  |  106|      1|    emp::vector<size_t> cur_row(size1);   // The row we are calculating
  |  107|      1|    emp::vector<size_t> prev_row(size1);  // The previous row we calculated
  |  108|      1|    emp::vector<emp::vector<char> > edit_info(size2, emp::vector<char>(size1));
  |  109|      1|
  |  110|      1|    // Initialize the previous row to record the differece from nothing.
  |  111|     17|    for (size_t i = 0; i < size1; i++) {
  |  112|     16|      prev_row[i] = i + 1;
  |  113|     16|      edit_info[0][i] = 'i';
  |  114|     16|    }
  |  115|      1|
  |  116|      1|    // Loop through all other rows
  |  117|     27|    for (size_t row = 0; row < size2; row++) {
  |  118|     26|      // Initialize the first entry in the current row.
  |  119|     26|      if (in1[0] == in2[row]) { cur_row[0] = row; edit_info[row][0] = 's'; }
  |  120|     25|      else { cur_row[0] = prev_row[0] + 1; edit_info[row][0] = 'd'; }
  |  121|     26|
  |  122|     26|      // Move through the cur_row and fill it in.
  |  123|    416|      for (size_t col = 1; col < size1; col++) {
  |  124|    390|        // If the values are equal, keep the value in the upper left.
  |  125|    390|        if (in1[col] == in2[row]) { cur_row[col] = prev_row[col-1]; edit_info[row][col] = 's'; }
  |  126|    375|
  |  127|    375|        // Otherwise, set the current position to the minimum of the three
  |  128|    375|        // numbers to the left, upper, or upper left in the chart plus one.
  |  129|    375|        else {
  |  130|    375|          cur_row[col] = emp::Min(prev_row[col], prev_row[col-1], cur_row[col-1]) + 1;
  |  131|    375|          if (cur_row[col] == prev_row[col]+1)   { edit_info[row][col] = 'd'; }
  |  132|    375|          if (cur_row[col] == prev_row[col-1]+1) { edit_info[row][col] = 's'; }
  |  133|    375|          if (cur_row[col] == cur_row[col-1]+1)  { edit_info[row][col] = 'i'; }
  |  134|    375|        }
  |  135|    390|      }
  |  136|     26|
  |  137|     26|      // Swap cur_row and prev_row (keep cur vals in prev row, recycle vector cur_row)
  |  138|     26|      std::swap(cur_row, prev_row);
  |  139|     26|    }
  |  140|      1|
  |  141|      1|    // Fill in gaps in the sequences to make them align!
  |  142|      1|
  |  143|      1|    int c = (int) size1 - 1;
  |  144|      1|    int r = (int) size2 - 1;
  |  145|      1|    size_t length = 0;
  |  146|      1|
  |  147|     27|    while (c >= 0 || r >= 0) {
  |  148|     26|      if (c < 0) { ++length; --r; continue; }
  |  149|     26|      else if (r < 0) { ++length; --c; continue; }
  |  150|     26|
  |  151|     26|      char cur_move = edit_info[(size_t)r][(size_t)c];
  |  152|     26|      switch(cur_move) {
  |  153|     26|      case 's': --c; --r; ++length; break;
  |  154|     26|      case 'd': --r; ++length; break;
  |  155|     26|      case 'i': --c; ++length; break;
  |  156|     26|      };
  |  157|     26|    }
  |  158|      1|
  |  159|      1|    c = (int) size1-1;
  |  160|      1|    r = (int) size2-1;
  |  161|      1|
  |  162|      1|    TYPE out1(length, gap);
  |  163|      1|    TYPE out2(length, gap);
  |  164|      1|
  |  165|      1|    size_t pos = length - 1;
  |  166|      1|
  |  167|     27|    while (c >= 0 && r >= 0) {
  |  168|     26|      switch(edit_info[(size_t)r][(size_t)c]) {
  |  169|     26|      case 's': out1[pos] = in1[(size_t)c]; out2[pos] = in2[(size_t)r]; --c; --r; break;
  |  170|     26|      case 'd': out1[pos] = gap;    out2[pos] = in2[(size_t)r];      --r; break;
  |  171|     26|      case 'i': out1[pos] = in1[(size_t)c]; out2[pos] = gap;    --c;      break;
  |  172|     26|      };
  |  173|     26|      --pos;
  |  174|     26|    }
  |  175|      1|    while (c >= 0) { out1[pos] = in1[(size_t)c]; --c; --pos; }
  |  176|      1|    while (r >= 0) { out2[pos] = in2[(size_t)r]; --r; --pos; }
  |  177|      1|
  |  178|      1|    in1 = out1;
  |  179|      1|    in2 = out2;
  |  180|      1|
  |  181|      1|    // Now that we are done, return the bottom-right corner of the chart.
  |  182|      1|    return prev_row[size1 - 1];
  |  183|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp5alignINS_6vectorIiJEEEiEEmRT_S4_T0_:
  |   98|      1|  size_t align(TYPE & in1, TYPE & in2, GAP_TYPE gap) {
  |   99|      1|    const auto size1 = in1.size();
  |  100|      1|    const auto size2 = in2.size();
  |  101|      1|
  |  102|      1|    // If either size is zero, other size indicates number of insertions needed to produce it.
  |  103|      1|    if (size1 == 0) return size2;
  |  104|      1|    if (size2 == 0) return size1;
  |  105|      1|
  |  106|      1|    emp::vector<size_t> cur_row(size1);   // The row we are calculating
  |  107|      1|    emp::vector<size_t> prev_row(size1);  // The previous row we calculated
  |  108|      1|    emp::vector<emp::vector<char> > edit_info(size2, emp::vector<char>(size1));
  |  109|      1|
  |  110|      1|    // Initialize the previous row to record the differece from nothing.
  |  111|     10|    for (size_t i = 0; i < size1; i++) {
  |  112|      9|      prev_row[i] = i + 1;
  |  113|      9|      edit_info[0][i] = 'i';
  |  114|      9|    }
  |  115|      1|
  |  116|      1|    // Loop through all other rows
  |  117|      6|    for (size_t row = 0; row < size2; row++) {
  |  118|      5|      // Initialize the first entry in the current row.
  |  119|      5|      if (in1[0] == in2[row]) { cur_row[0] = row; edit_info[row][0] = 's'; }
  |  120|      4|      else { cur_row[0] = prev_row[0] + 1; edit_info[row][0] = 'd'; }
  |  121|      5|
  |  122|      5|      // Move through the cur_row and fill it in.
  |  123|     45|      for (size_t col = 1; col < size1; col++) {
  |  124|     40|        // If the values are equal, keep the value in the upper left.
  |  125|     40|        if (in1[col] == in2[row]) { cur_row[col] = prev_row[col-1]; edit_info[row][col] = 's'; }
  |  126|     36|
  |  127|     36|        // Otherwise, set the current position to the minimum of the three
  |  128|     36|        // numbers to the left, upper, or upper left in the chart plus one.
  |  129|     36|        else {
  |  130|     36|          cur_row[col] = emp::Min(prev_row[col], prev_row[col-1], cur_row[col-1]) + 1;
  |  131|     36|          if (cur_row[col] == prev_row[col]+1)   { edit_info[row][col] = 'd'; }
  |  132|     36|          if (cur_row[col] == prev_row[col-1]+1) { edit_info[row][col] = 's'; }
  |  133|     36|          if (cur_row[col] == cur_row[col-1]+1)  { edit_info[row][col] = 'i'; }
  |  134|     36|        }
  |  135|     40|      }
  |  136|      5|
  |  137|      5|      // Swap cur_row and prev_row (keep cur vals in prev row, recycle vector cur_row)
  |  138|      5|      std::swap(cur_row, prev_row);
  |  139|      5|    }
  |  140|      1|
  |  141|      1|    // Fill in gaps in the sequences to make them align!
  |  142|      1|
  |  143|      1|    int c = (int) size1 - 1;
  |  144|      1|    int r = (int) size2 - 1;
  |  145|      1|    size_t length = 0;
  |  146|      1|
  |  147|     10|    while (c >= 0 || r >= 0) {
  |  148|      9|      if (c < 0) { ++length; --r; continue; }
  |  149|      9|      else if (r < 0) { ++length; --c; continue; }
  |  150|      9|
  |  151|      9|      char cur_move = edit_info[(size_t)r][(size_t)c];
  |  152|      9|      switch(cur_move) {
  |  153|      9|      case 's': --c; --r; ++length; break;
  |  154|      9|      case 'd': --r; ++length; break;
  |  155|      9|      case 'i': --c; ++length; break;
  |  156|      9|      };
  |  157|      9|    }
  |  158|      1|
  |  159|      1|    c = (int) size1-1;
  |  160|      1|    r = (int) size2-1;
  |  161|      1|
  |  162|      1|    TYPE out1(length, gap);
  |  163|      1|    TYPE out2(length, gap);
  |  164|      1|
  |  165|      1|    size_t pos = length - 1;
  |  166|      1|
  |  167|     10|    while (c >= 0 && r >= 0) {
  |  168|      9|      switch(edit_info[(size_t)r][(size_t)c]) {
  |  169|      9|      case 's': out1[pos] = in1[(size_t)c]; out2[pos] = in2[(size_t)r]; --c; --r; break;
  |  170|      9|      case 'd': out1[pos] = gap;    out2[pos] = in2[(size_t)r];      --r; break;
  |  171|      9|      case 'i': out1[pos] = in1[(size_t)c]; out2[pos] = gap;    --c;      break;
  |  172|      9|      };
  |  173|      9|      --pos;
  |  174|      9|    }
  |  175|      1|    while (c >= 0) { out1[pos] = in1[(size_t)c]; --c; --pos; }
  |  176|      1|    while (r >= 0) { out2[pos] = in2[(size_t)r]; --r; --pos; }
  |  177|      1|
  |  178|      1|    in1 = out1;
  |  179|      1|    in2 = out2;
  |  180|      1|
  |  181|      1|    // Now that we are done, return the bottom-right corner of the chart.
  |  182|      1|    return prev_row[size1 - 1];
  |  183|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  184|       |
  185|       |}
  186|       |
  187|       |#endif
  188|       |

/home/emily/repos/Empirical_Tests/source/tools/set_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file set_utils.h
    7|       | *  @brief Tools to save and load data from classes.
    8|       | *  @note Status: ALPHA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_SET_UTILS_H
   13|       |#define EMP_SET_UTILS_H
   14|       |
   15|       |#include <set>
   16|       |#include <unordered_set>
   17|       |#include <algorithm>
   18|       |
   19|       |#include "../base/vector.h"
   20|       |
   21|       |namespace emp {
   22|       |
   23|       |  /// Insert the full contents of s2 into s1.
   24|       |  /*_FORCE_COVER_START_*/template <typename T>
   25|  1.82k|  void insert(std::set<T> & s1, const std::set<T> & s2) {
   26|  1.82k|    s1.insert(s2.begin(), s2.end());
   27|  1.82k|  }/*_FORCE_COVER_END_*/
   28|       |
   29|       |  /// Test if an std::set has a particular element without modifying the set in any way.
   30|       |  /*_FORCE_COVER_START_*/template <typename T, typename H>
   31|      2|  bool Has(const std::set<T,H> & s, const T & val) { return s.count(val); }/*_FORCE_COVER_END_*/
   32|       |
   33|       |  /// Test if an std::multiset has a particular element without modifying the set in any way.
   34|       |  /*_FORCE_COVER_START_*/template <typename T, typename H>
   35|       |  bool Has(const std::multiset<T,H> & s, const T & val) { return s.count(val); }/*_FORCE_COVER_END_*/
   36|       |
   37|       |  /// Test if an std::unordered_set has a particular element without modifying the set in any way.
   38|       |  /*_FORCE_COVER_START_*/template <typename T, typename H>
   39|       |  bool Has(const std::unordered_set<T,H> & s, const T & val) { return s.count(val); }/*_FORCE_COVER_END_*/
   40|       |
   41|       |  /// Test if an std::unordere_multiset has a particular element without modifying the set in any way.
   42|       |  /*_FORCE_COVER_START_*/template <typename T, typename H>
   43|       |  bool Has(const std::unordered_multiset<T,H> & s, const T & val) { return s.count(val); }/*_FORCE_COVER_END_*/
   44|       |
   45|       |  // Note: the following functions allow the use of sets or vectors. Sets are passed
   46|       |  // by reference and vectors are passed by value, because these functions only work
   47|       |  // on sorted data. Therefore, vectors must be sorted first, which happens in place.
   48|       |
   49|       |  /// Compute the set difference of @param s1 and @param s2 (elements that are in S1 but no S2)
   50|       |  /*_FORCE_COVER_START_*/template <typename T>
   51|      2|  std::set<T> difference(std::set<T> & s1, std::set<T> & s2) {
   52|      2|    // Based on PierreBdR's answer to https://stackoverflow.com/questions/283977/c-stl-set-difference
   53|      2|    std::set<T> result;
   54|      2|    std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
   55|      2|                        std::inserter(result, result.end()));
   56|      2|    return result;
   57|      2|  }/*_FORCE_COVER_END_*/
   58|       |
   59|       |  /// Compute the set difference of @param s1 and @param s2 (elements that are in S1 but no S2)
   60|       |  /*_FORCE_COVER_START_*/template <typename T>
   61|      1|  std::set<T> difference(emp::vector<T> s1, emp::vector<T> & s2) {
   62|      1|    // Based on PierreBdR's answer to https://stackoverflow.com/questions/283977/c-stl-set-difference
   63|      1|    std::sort(s1.begin(), s1.end()); // set_difference expects sorted things
   64|      1|    std::sort(s2.begin(), s2.end()); // set_difference expects sorted things
   65|      1|
   66|      1|    std::set<T> result;
   67|      1|    std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
   68|      1|                        std::inserter(result, result.end()));
   69|      1|    return result;
   70|      1|  }/*_FORCE_COVER_END_*/
   71|       |
   72|       |  /// Compute the set difference of @param s1 and @param s2 (elements that are in S1 but not S2)
   73|       |  /*_FORCE_COVER_START_*/template <typename T>
   74|      1|  std::set<T> difference(std::set<T> & s1, emp::vector<T> s2) {
   75|      1|    // Based on PierreBdR's answer to https://stackoverflow.com/questions/283977/c-stl-set-difference
   76|      1|    std::sort(s2.begin(), s2.end()); // set_difference expects sorted things
   77|      1|    std::set<T> result;
   78|      1|    std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
   79|      1|                        std::inserter(result, result.end()));
   80|      1|    return result;
   81|      1|  }/*_FORCE_COVER_END_*/
   82|       |
   83|       |  /// Compute the set difference of @param s1 and @param s2 (elements that are in S1 but no S2)
   84|       |  /*_FORCE_COVER_START_*/template <typename T>
   85|       |  std::set<T> difference(emp::vector<T> s1, std::set<T> & s2) {
   86|       |    // Based on PierreBdR's answer to https://stackoverflow.com/questions/283977/c-stl-set-difference
   87|       |    std::sort(s1.begin(), s1.end()); // set_difference expects sorted things
   88|       |    std::set<T> result;
   89|       |    std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
   90|       |                        std::inserter(result, result.end()));
   91|       |    return result;
   92|       |  }/*_FORCE_COVER_END_*/
   93|       |
   94|       |  /// Compute the set intersection of @param s1 and @param s2 (elements that are in both S1 and S2)
   95|       |  /*_FORCE_COVER_START_*/template <typename T>
   96|      2|  std::set<T> intersection(std::set<T> s1, std::set<T> s2) {
   97|      2|    std::set<T> result;
   98|      2|    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
   99|      2|                        std::inserter(result, result.end()));
  100|      2|    return result;
  101|      2|  }/*_FORCE_COVER_END_*/
  102|       |
  103|       |  /// Compute the set intersection of @param s1 and @param s2 (elements that are in both S1 and S2)
  104|       |  /*_FORCE_COVER_START_*/template <typename T>
  105|      2|  std::set<T> intersection(emp::vector<T> s1, emp::vector<T> s2) {
  106|      2|    std::sort(s1.begin(), s1.end()); // set_intersection expects sorted things
  107|      2|    std::sort(s2.begin(), s2.end()); // set_intersection expects sorted things
  108|      2|
  109|      2|    std::set<T> result;
  110|      2|    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
  111|      2|                        std::inserter(result, result.end()));
  112|      2|    return result;
  113|      2|  }/*_FORCE_COVER_END_*/
  114|       |
  115|       |  /// Compute the set intersection of @param s1 and @param s2 (elements that are in both S1 and S2)
  116|       |  /*_FORCE_COVER_START_*/template <typename T>
  117|      1|  std::set<T> intersection(std::set<T> s1, emp::vector<T> s2) {
  118|      1|    std::sort(s2.begin(), s2.end()); // set_intersection expects sorted things
  119|      1|
  120|      1|    std::set<T> result;
  121|      1|    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
  122|      1|                        std::inserter(result, result.end()));
  123|      1|    return result;
  124|      1|  }/*_FORCE_COVER_END_*/
  125|       |
  126|       |  /// Compute the set intersection of @param s1 and @param s2 (elements that are in both S1 and S2)
  127|       |  /*_FORCE_COVER_START_*/template <typename T>
  128|      1|  std::set<T> intersection(emp::vector<T> s1, std::set<T> s2) {
  129|      1|    std::sort(s1.begin(), s1.end()); // set_intersection expects sorted things
  130|      1|
  131|      1|    std::set<T> result;
  132|      1|    std::set_intersection(s1.begin(), s1.end(), s2.begin(), s2.end(),
  133|      1|                        std::inserter(result, result.end()));
  134|      1|    return result;
  135|      1|  }/*_FORCE_COVER_END_*/
  136|       |
  137|       |  /// Compute the set union of @param s1 and @param s2 (elements that are in either S1 or S2)
  138|       |  /*_FORCE_COVER_START_*/template <typename T>
  139|      2|  std::set<T> set_union(std::set<T> s1, std::set<T> s2) {
  140|      2|    std::set<T> result;
  141|      2|    std::set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
  142|      2|                        std::inserter(result, result.end()));
  143|      2|    return result;
  144|      2|  }/*_FORCE_COVER_END_*/
  145|       |
  146|       |  /// Compute the set union of @param s1 and @param s2 (elements that are in either S1 or S2)
  147|       |  /*_FORCE_COVER_START_*/template <typename T>
  148|      2|  std::set<T> set_union(emp::vector<T> s1, emp::vector<T> s2) {
  149|      2|    std::sort(s1.begin(), s1.end()); // set_union expects sorted things
  150|      2|    std::sort(s2.begin(), s2.end()); // set_union expects sorted things
  151|      2|
  152|      2|    std::set<T> result;
  153|      2|    std::set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
  154|      2|                        std::inserter(result, result.end()));
  155|      2|    return result;
  156|      2|  }/*_FORCE_COVER_END_*/
  157|       |
  158|       |  /// Compute the set union of @param s1 and @param s2 (elements that are in either S1 or S2)
  159|       |  /*_FORCE_COVER_START_*/template <typename T>
  160|      1|  std::set<T> set_union(std::set<T> s1, emp::vector<T> s2) {
  161|      1|    std::sort(s2.begin(), s2.end()); // set_union expects sorted things
  162|      1|
  163|      1|    std::set<T> result;
  164|      1|    std::set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
  165|      1|                        std::inserter(result, result.end()));
  166|      1|    return result;
  167|      1|  }/*_FORCE_COVER_END_*/
  168|       |
  169|       |  /// Compute the set union of @param s1 and @param s2 (elements that are in either S1 or S2)
  170|       |  /*_FORCE_COVER_START_*/template <typename T>
  171|      1|  std::set<T> set_union(emp::vector<T> s1, std::set<T> s2) {
  172|      1|    std::sort(s1.begin(), s1.end()); // set_union expects sorted things
  173|      1|
  174|      1|    std::set<T> result;
  175|      1|    std::set_union(s1.begin(), s1.end(), s2.begin(), s2.end(),
  176|      1|                        std::inserter(result, result.end()));
  177|      1|    return result;
  178|      1|  }/*_FORCE_COVER_END_*/
  179|       |
  180|       | /// Compute the set symmetric_difference of @param s1 and @param s2 (elements that are in either S1 or S2 but not both)
  181|       |  /*_FORCE_COVER_START_*/template <typename T>
  182|      2|  std::set<T> symmetric_difference(std::set<T> s1, std::set<T> s2) {
  183|      2|    std::set<T> result;
  184|      2|    std::set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
  185|      2|                        std::inserter(result, result.end()));
  186|      2|    return result;
  187|      2|  }/*_FORCE_COVER_END_*/
  188|       |
  189|       |  /// Compute the set symmetric_difference of @param s1 and @param s2 (elements that are in either S1 or S2 but not both)
  190|       |  /*_FORCE_COVER_START_*/template <typename T>
  191|      2|  std::set<T> symmetric_difference(emp::vector<T> s1, emp::vector<T> s2) {
  192|      2|    std::sort(s1.begin(), s1.end()); // set_symmetric_difference expects sorted things
  193|      2|    std::sort(s2.begin(), s2.end()); // set_symmetric_difference expects sorted things
  194|      2|
  195|      2|    std::set<T> result;
  196|      2|    std::set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
  197|      2|                        std::inserter(result, result.end()));
  198|      2|    return result;
  199|      2|  }/*_FORCE_COVER_END_*/
  200|       |
  201|       |  /// Compute the set symmetric_difference of @param s1 and @param s2 (elements that are in either S1 or S2 but not both)
  202|       |  /*_FORCE_COVER_START_*/template <typename T>
  203|      1|  std::set<T> symmetric_difference(std::set<T> s1, emp::vector<T> s2) {
  204|      1|    std::sort(s2.begin(), s2.end()); // set_symmetric_difference expects sorted things
  205|      1|
  206|      1|    std::set<T> result;
  207|      1|    std::set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
  208|      1|                        std::inserter(result, result.end()));
  209|      1|    return result;
  210|      1|  }/*_FORCE_COVER_END_*/
  211|       |
  212|       |  /// Compute the set symmetric_difference of @param s1 and @param s2 (elements that are in either S1 or S2 but not both)
  213|       |  /*_FORCE_COVER_START_*/template <typename T>
  214|      1|  std::set<T> symmetric_difference(emp::vector<T> s1, std::set<T> s2) {
  215|      1|    std::sort(s1.begin(), s1.end()); // set_symmetric_difference expects sorted things
  216|      1|
  217|      1|    std::set<T> result;
  218|      1|    std::set_symmetric_difference(s1.begin(), s1.end(), s2.begin(), s2.end(),
  219|      1|                        std::inserter(result, result.end()));
  220|      1|    return result;
  221|      1|  }/*_FORCE_COVER_END_*/
  222|       |
  223|       |
  224|       |}
  225|       |
  226|       |#endif
  227|       |

/home/emily/repos/Empirical_Tests/source/tools/stats.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2017
    5|       | *
    6|       | *  @file stats.h
    7|       | *  @brief Functions for calculating various statistics about an ensemble.
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_STATS_H
   13|       |#define EMP_STATS_H
   14|       |
   15|       |#include <type_traits>
   16|       |#include <map>
   17|       |#include <unordered_map>
   18|       |#include <cmath>
   19|       |#include <vector>
   20|       |#include <set>
   21|       |#include <unordered_set>
   22|       |#include <functional>
   23|       |
   24|       |#include "../base/vector.h"
   25|       |#include "../meta/type_traits.h"
   26|       |#include "math.h"
   27|       |
   28|       |namespace emp {
   29|       |
   30|       |  /// Calculate sum of the members of the container passed
   31|       |  /// Only works on containers with a scalar member type
   32|       |  /*_FORCE_COVER_START_*/template <typename C>
   33|       |  typename std::enable_if<!emp::is_ptr_type<typename C::value_type>::value && std::is_scalar<typename C::value_type>::value, typename C::value_type>::type
   34|      9|  Sum(C & elements) {
   35|      9|
   36|      9|    double total = 0;
   37|     53|    for (auto element : elements) {
   38|     53|      total += element;
   39|     53|    }
   40|      9|
   41|      9|    return total;
   42|      9|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3SumINS_6vectorIiJEEEEENSt9enable_ifIXaantsr3emp11is_ptr_typeINT_10value_typeEEE5valuesr3std9is_scalarIS5_EE5valueES5_E4typeERS4_:
  |   34|      5|  Sum(C & elements) {
  |   35|      5|
  |   36|      5|    double total = 0;
  |   37|     29|    for (auto element : elements) {
  |   38|     29|      total += element;
  |   39|     29|    }
  |   40|      5|
  |   41|      5|    return total;
  |   42|      5|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp3SumISt5dequeIdSaIdEEEENSt9enable_ifIXaantsr3emp11is_ptr_typeINT_10value_typeEEE5valuesr3std9is_scalarIS6_EE5valueES6_E4typeERS5_:
  |   34|      4|  Sum(C & elements) {
  |   35|      4|
  |   36|      4|    double total = 0;
  |   37|     24|    for (auto element : elements) {
  |   38|     24|      total += element;
  |   39|     24|    }
  |   40|      4|
  |   41|      4|    return total;
  |   42|      4|  }/*_FORCE_COVER_END_*/
  ------------------
   43|       |
   44|       |  /// Calculate sum of the values pointed at by pointers in a container
   45|       |  /// Only works on containers of pointers to a scalar type
   46|       |  /*_FORCE_COVER_START_*/template <typename C>
   47|       |  typename std::enable_if<emp::is_ptr_type<typename C::value_type>::value && std::is_scalar<typename emp::remove_ptr_type<typename C::value_type>::type >::value, typename emp::remove_ptr_type<typename C::value_type>::type >::type
   48|      4|  Sum(C & elements) {
   49|      4|
   50|      4|    double total = 0;
   51|     16|    for (auto element : elements) {
   52|     16|      total += *element;
   53|     16|    }
   54|      4|
   55|      4|    return total;
   56|      4|  }/*_FORCE_COVER_END_*/
   57|       |
   58|       |
   59|       |  /// Calculate Shannon Entropy of the members of the container passed
   60|       |  /*_FORCE_COVER_START_*/template <typename C>
   61|       |  typename std::enable_if<!emp::is_ptr_type<typename C::value_type>::value, double>::type
   62|      2|  ShannonEntropy(C & elements) {
   63|      2|
   64|      2|    // Count number of each value present
   65|      2|    std::map<typename C::value_type, int> counts;
   66|     12|    for (auto element : elements) {
   67|     12|      if (counts.find(element) != counts.end()) {
   68|      5|	       counts[element]++;
   69|      7|      } else {
   70|      7|	       counts[element] = 1;
   71|      7|      }
   72|     12|    }
   73|      2|
   74|      2|    // Shannon entropy calculation
   75|      2|    double result = 0;
   76|      7|    for (auto element : counts) {
   77|      7|      double p = double(element.second)/elements.size();
   78|      7|      result +=  p * Log2(p);
   79|      7|    }
   80|      2|
   81|      2|    return -1 * result;
   82|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp14ShannonEntropyINS_6vectorIiJEEEEENSt9enable_ifIXntsr3emp11is_ptr_typeINT_10value_typeEEE5valueEdE4typeERS4_:
  |   62|      1|  ShannonEntropy(C & elements) {
  |   63|      1|
  |   64|      1|    // Count number of each value present
  |   65|      1|    std::map<typename C::value_type, int> counts;
  |   66|      6|    for (auto element : elements) {
  |   67|      6|      if (counts.find(element) != counts.end()) {
  |   68|      3|	       counts[element]++;
  |   69|      3|      } else {
  |   70|      3|	       counts[element] = 1;
  |   71|      3|      }
  |   72|      6|    }
  |   73|      1|
  |   74|      1|    // Shannon entropy calculation
  |   75|      1|    double result = 0;
  |   76|      3|    for (auto element : counts) {
  |   77|      3|      double p = double(element.second)/elements.size();
  |   78|      3|      result +=  p * Log2(p);
  |   79|      3|    }
  |   80|      1|
  |   81|      1|    return -1 * result;
  |   82|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp14ShannonEntropyISt5dequeIdSaIdEEEENSt9enable_ifIXntsr3emp11is_ptr_typeINT_10value_typeEEE5valueEdE4typeERS5_:
  |   62|      1|  ShannonEntropy(C & elements) {
  |   63|      1|
  |   64|      1|    // Count number of each value present
  |   65|      1|    std::map<typename C::value_type, int> counts;
  |   66|      6|    for (auto element : elements) {
  |   67|      6|      if (counts.find(element) != counts.end()) {
  |   68|      2|	       counts[element]++;
  |   69|      4|      } else {
  |   70|      4|	       counts[element] = 1;
  |   71|      4|      }
  |   72|      6|    }
  |   73|      1|
  |   74|      1|    // Shannon entropy calculation
  |   75|      1|    double result = 0;
  |   76|      4|    for (auto element : counts) {
  |   77|      4|      double p = double(element.second)/elements.size();
  |   78|      4|      result +=  p * Log2(p);
  |   79|      4|    }
  |   80|      1|
  |   81|      1|    return -1 * result;
  |   82|      1|  }/*_FORCE_COVER_END_*/
  ------------------
   83|       |
   84|       |  /// Calculate Shannon Entropy of the members of the container when those members are pointers
   85|       |  /*_FORCE_COVER_START_*/template <typename C>
   86|       |  typename std::enable_if<emp::is_ptr_type<typename C::value_type>::value, double>::type
   87|      1|  ShannonEntropy(C & elements) {
   88|      1|    //   std::cout<< "In se" << std::endl;
   89|      1|    using pointed_at = typename emp::remove_ptr_type<typename C::value_type>::type;
   90|      1|    // Count number of each value present
   91|      1|    std::map<pointed_at, int> counts;
   92|      4|    for (auto element : elements) {
   93|      4|      if (counts.find(*element) != counts.end()) {
   94|      2|        counts[*element]++;
   95|      2|      } else {
   96|      2|        counts[*element] = 1;
   97|      2|      }
   98|      4|
   99|      4|    }
  100|      1|    // Shannon entropy calculation
  101|      1|    double result = 0;
  102|      2|    for (auto element : counts) {
  103|      2|      double p = double(element.second)/elements.size();
  104|      2|      result +=  p * log2(p);
  105|      2|    }
  106|      1|    //   std::cout<< "leaving se" << std::endl;
  107|      1|    return -1 * result;
  108|      1|  }/*_FORCE_COVER_END_*/
  109|       |
  110|       |  /// Calculate variance of the members of the container passed
  111|       |  /// Only works on containers with a scalar member type
  112|       |  /*_FORCE_COVER_START_*/template <typename C>
  113|       |  typename std::enable_if<!emp::is_ptr_type<typename C::value_type>::value && std::is_scalar<typename C::value_type>::value, double>::type
  114|      4|  Variance(C & elements) {
  115|      4|
  116|      4|    double var = 0;
  117|      4|    double mean = (double)Sum(elements)/elements.size();
  118|     24|    for (auto element : elements) {
  119|     24|      var += emp::Pow(element - mean, 2);
  120|     24|    }
  121|      4|    return var/elements.size();
  122|      4|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8VarianceINS_6vectorIiJEEEEENSt9enable_ifIXaantsr3emp11is_ptr_typeINT_10value_typeEEE5valuesr3std9is_scalarIS5_EE5valueEdE4typeERS4_:
  |  114|      2|  Variance(C & elements) {
  |  115|      2|
  |  116|      2|    double var = 0;
  |  117|      2|    double mean = (double)Sum(elements)/elements.size();
  |  118|     12|    for (auto element : elements) {
  |  119|     12|      var += emp::Pow(element - mean, 2);
  |  120|     12|    }
  |  121|      2|    return var/elements.size();
  |  122|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8VarianceISt5dequeIdSaIdEEEENSt9enable_ifIXaantsr3emp11is_ptr_typeINT_10value_typeEEE5valuesr3std9is_scalarIS6_EE5valueEdE4typeERS5_:
  |  114|      2|  Variance(C & elements) {
  |  115|      2|
  |  116|      2|    double var = 0;
  |  117|      2|    double mean = (double)Sum(elements)/elements.size();
  |  118|     12|    for (auto element : elements) {
  |  119|     12|      var += emp::Pow(element - mean, 2);
  |  120|     12|    }
  |  121|      2|    return var/elements.size();
  |  122|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  123|       |
  124|       |  /// Calculate variance of the values pointed at by members of the container passed
  125|       |  /// Only works on containers with a scalar member type
  126|       |  /*_FORCE_COVER_START_*/template <typename C>
  127|       |  typename std::enable_if<emp::is_ptr_type<typename C::value_type>::value && std::is_scalar<typename emp::remove_ptr_type<typename C::value_type>::type >::value, double>::type
  128|      2|  Variance(C & elements) {
  129|      2|
  130|      2|    double var = 0;
  131|      2|    double mean = (double)Sum(elements)/elements.size();
  132|      8|    for (auto element : elements) {
  133|      8|      var += emp::Pow(*element - mean, 2);
  134|      8|    }
  135|      2|    return var/elements.size();
  136|      2|  }/*_FORCE_COVER_END_*/
  137|       |
  138|       |  /// Calculate the mean of the values in a container
  139|       |  /// If values are pointers, they will be automatically de-referenced
  140|       |  /// Values must be numeric.
  141|       |  /*_FORCE_COVER_START_*/template <typename C>
  142|       |  emp::sfinae_decoy<double, typename C::value_type> 
  143|      3|  Mean(C & elements) {
  144|      3|    return (double)Sum(elements)/elements.size();
  145|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4MeanINS_6vectorIiJEEEEEdRT_:
  |  143|      1|  Mean(C & elements) {
  |  144|      1|    return (double)Sum(elements)/elements.size();
  |  145|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4MeanINS_6vectorIPdJEEEEEdRT_:
  |  143|      1|  Mean(C & elements) {
  |  144|      1|    return (double)Sum(elements)/elements.size();
  |  145|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp4MeanISt5dequeIdSaIdEEEEdRT_:
  |  143|      1|  Mean(C & elements) {
  |  144|      1|    return (double)Sum(elements)/elements.size();
  |  145|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  146|       |
  147|       |  /// Calculate the standard deviation of the values in a container
  148|       |  /// If values are pointers, they will be automatically de-referenced
  149|       |  /// Values must be numeric.
  150|       |  /*_FORCE_COVER_START_*/template <typename C>
  151|       |  emp::sfinae_decoy<double, typename C::value_type> 
  152|      3|  StandardDeviation(C & elements) {
  153|      3|    return sqrt(Variance(elements));
  154|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17StandardDeviationINS_6vectorIiJEEEEEdRT_:
  |  152|      1|  StandardDeviation(C & elements) {
  |  153|      1|    return sqrt(Variance(elements));
  |  154|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17StandardDeviationINS_6vectorIPdJEEEEEdRT_:
  |  152|      1|  StandardDeviation(C & elements) {
  |  153|      1|    return sqrt(Variance(elements));
  |  154|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp17StandardDeviationISt5dequeIdSaIdEEEEdRT_:
  |  152|      1|  StandardDeviation(C & elements) {
  |  153|      1|    return sqrt(Variance(elements));
  |  154|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  155|       |
  156|       |  /// Count the number of unique elements in a container
  157|       |  /*_FORCE_COVER_START_*/template <typename C>
  158|       |  typename std::enable_if<!emp::is_ptr_type<typename C::value_type>::value, int>::type
  159|      2|  UniqueCount(C & elements) {
  160|      2|    // Converting to a set will remove duplicates leaving only unique values
  161|      2|    std::set<typename C::value_type> unique_elements(elements.begin(),
  162|      2|                           elements.end());
  163|      2|    return unique_elements.size();
  164|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11UniqueCountINS_6vectorIiJEEEEENSt9enable_ifIXntsr3emp11is_ptr_typeINT_10value_typeEEE5valueEiE4typeERS4_:
  |  159|      1|  UniqueCount(C & elements) {
  |  160|      1|    // Converting to a set will remove duplicates leaving only unique values
  |  161|      1|    std::set<typename C::value_type> unique_elements(elements.begin(),
  |  162|      1|                           elements.end());
  |  163|      1|    return unique_elements.size();
  |  164|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp11UniqueCountISt5dequeIdSaIdEEEENSt9enable_ifIXntsr3emp11is_ptr_typeINT_10value_typeEEE5valueEiE4typeERS5_:
  |  159|      1|  UniqueCount(C & elements) {
  |  160|      1|    // Converting to a set will remove duplicates leaving only unique values
  |  161|      1|    std::set<typename C::value_type> unique_elements(elements.begin(),
  |  162|      1|                           elements.end());
  |  163|      1|    return unique_elements.size();
  |  164|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  165|       |
  166|       |  /// Count the number of unique elements in the container of pointers. (compares objects pointed
  167|       |  /// to; pointers do not have to be identical)
  168|       |  /*_FORCE_COVER_START_*/template <typename C>
  169|       |  typename std::enable_if<emp::is_ptr_type<typename C::value_type>::value, int>::type
  170|      1|  UniqueCount(C & elements) {
  171|      1|    // Converting to a set will remove duplicates leaving only unique values
  172|      1|    using pointed_at = typename emp::remove_ptr_type<typename C::value_type>::type;
  173|      1|    std::set<pointed_at> unique_elements;
  174|      4|    for (auto element : elements) {
  175|      4|        unique_elements.insert(*element);
  176|      4|    }
  177|      1|
  178|      1|    return unique_elements.size();
  179|      1|  }/*_FORCE_COVER_END_*/
  180|       |
  181|       |  /// Run the provided function on every member of a container and return the MAXIMUM result.
  182|       |  /*_FORCE_COVER_START_*/template <typename C, typename RET_TYPE, typename ARG_TYPE>
  183|      1|  RET_TYPE MaxResult(std::function<RET_TYPE(ARG_TYPE)> & fun, C & elements){
  184|      1|    auto best = fun(elements.front());  // @CAO Technically, front is processed twice...
  185|      6|    for (auto element : elements){
  186|      6|      auto result = fun(element);
  187|      6|      if (result > best) best = result;
  188|      6|    }
  189|      1|    return best;
  190|      1|  }/*_FORCE_COVER_END_*/
  191|       |
  192|       |  /// Run the provided function on every member of a container and return the MINIMUM result.
  193|       |  /*_FORCE_COVER_START_*/template <typename C, typename RET_TYPE, typename ARG_TYPE>
  194|      1|  RET_TYPE MinResult(std::function<RET_TYPE(ARG_TYPE)> & fun, C & elements){
  195|      1|    auto best = fun(elements.front());  // @CAO Technically, front is processed twice...
  196|      6|    for (auto element : elements){
  197|      6|      auto result = fun(element);
  198|      6|      if (result < best) best = result;
  199|      6|    }
  200|      1|    return best;
  201|      1|  }/*_FORCE_COVER_END_*/
  202|       |
  203|       |  /// Run the provided function on every member of a container and return the AVERAGE result.
  204|       |  /// Function must return a scalar (i.e. numeric) type.
  205|       |  /*_FORCE_COVER_START_*/template <typename C, typename RET_TYPE, typename ARG_TYPE>
  206|       |  typename std::enable_if<std::is_scalar<RET_TYPE>::value, double>::type 
  207|      1|  MeanResult(std::function<RET_TYPE(ARG_TYPE)> & fun, C & elements){
  208|      1|    double cumulative_value = 0;
  209|      1|    double count = 0;
  210|      6|    for (auto element : elements){
  211|      6|        ++count;
  212|      6|        cumulative_value += fun(element);
  213|      6|    }
  214|      1|    return (cumulative_value / count);
  215|      1|  }/*_FORCE_COVER_END_*/
  216|       |
  217|       |  /// Run the provided function on every member of a container and return a vector of ALL results.
  218|       |  /*_FORCE_COVER_START_*/template <typename C, typename RET_TYPE, typename ARG_TYPE>
  219|      1|  emp::vector<RET_TYPE> ApplyFunction(std::function<RET_TYPE(ARG_TYPE)> & fun, C & elements) {
  220|      1|      emp::vector<RET_TYPE> results;
  221|      6|      for (auto element : elements){
  222|      6|          results.push_back(fun(element));
  223|      6|      }
  224|      1|      return results;
  225|      1|  }/*_FORCE_COVER_END_*/
  226|       |
  227|       |  // This variant is actually super confusing because the value_type of world
  228|       |  // and population managers are pointers whereas the type that they're templated
  229|       |  // on is not. Also because the insert method for emp::vectors doesn't take an
  230|       |  // additional argument?
  231|       |
  232|       |  /* template <template <typename> class C, typename RET_TYPE, typename T>
  233|       |  C<RET_TYPE> RunFunctionOnContainer(std::function<RET_TYPE(T)> fun, C<T> & elements) {
  234|       |      C<RET_TYPE> results;
  235|       |      for (auto element : elements){
  236|       |          results.insert(fun(element), results.back());
  237|       |      }
  238|       |      return results;
  239|       |  } */
  240|       |
  241|       |}
  242|       |
  243|       |#endif
  244|       |
  245|       |//Base class outputs most recent
  246|       |//Write derived class
  247|       |

/home/emily/repos/Empirical_Tests/source/tools/string_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2016-2018
    5|       | *
    6|       | *  @file string_utils.h
    7|       | *  @brief Simple functions to manipulate strings.
    8|       | *  @note Status: RELEASE
    9|       | */
   10|       |
   11|       |
   12|       |#ifndef EMP_STRING_UTILS_H
   13|       |#define EMP_STRING_UTILS_H
   14|       |
   15|       |#include <functional>
   16|       |#include <initializer_list>
   17|       |#include <iostream>
   18|       |#include <sstream>
   19|       |#include <string>
   20|       |
   21|       |#include "../base/vector.h"
   22|       |#include "../meta/reflection.h"
   23|       |
   24|       |namespace emp {
   25|       |
   26|       |  /// Return a const reference to an empty string.  This function is useful to implement other
   27|       |  /// functions that need to return a const reference for efficiency, but also need a null response.
   28|       |
   29|      0|  static inline const std::string & empty_string() {
   30|      0|    static std::string empty = "";
   31|      0|    return empty;
   32|      0|  }
   33|       |
   34|       |
   35|       |  /// Convert a single chararcter to one that uses a proper escape sequence (in a string) if needed.
   36|     38|  static inline std::string to_escaped_string(char value) {
   37|     38|    // Start by quickly returning a string if it's easy.
   38|     38|    std::stringstream ss;
   39|     38|    if ( (value >= 40 && value < 91) || (value > 96 && value < 127)) {
   40|     29|      ss << value;
   41|     29|      return ss.str();
   42|     29|    }
   43|      9|    switch (value) {
   44|      9|    case '\0': return "\\0";
   45|      9|    case 1: return "\\001";
   46|      9|    case 2: return "\\002";
   47|      9|    case 3: return "\\003";
   48|      9|    case 4: return "\\004";
   49|      9|    case 5: return "\\005";
   50|      9|    case 6: return "\\006";
   51|      9|    case '\a': return "\\a";  // case  7 (audible bell)
   52|      9|    case '\b': return "\\b";  // case  8 (backspace)
   53|      9|    case '\t': return "\\t";  // case  9 (tab)
   54|      9|    case '\n': return "\\n";  // case 10 (newline)
   55|      9|    case '\v': return "\\v";  // case 11 (vertical tab)
   56|      9|    case '\f': return "\\f";  // case 12 (form feed - new page)
   57|      9|    case '\r': return "\\r";  // case 13 (carriage return)
   58|      9|    case 14: return "\\016";
   59|      9|    case 15: return "\\017";
   60|      9|    case 16: return "\\020";
   61|      9|    case 17: return "\\021";
   62|      9|    case 18: return "\\022";
   63|      9|    case 19: return "\\023";
   64|      9|    case 20: return "\\024";
   65|      9|    case 21: return "\\025";
   66|      9|    case 22: return "\\026";
   67|      9|    case 23: return "\\027";
   68|      9|    case 24: return "\\030";
   69|      9|    case 25: return "\\031";
   70|      9|    case 26: return "\\032";
   71|      9|    case 27: return "\\033";  // case 27 (ESC), sometimes \e
   72|      9|    case 28: return "\\034";
   73|      9|    case 29: return "\\035";
   74|      9|    case 30: return "\\036";
   75|      9|    case 31: return "\\037";
   76|      9|
   77|      9|    case '\"': return "\\\"";  // case 34
   78|      9|    case '\'': return "\\\'";  // case 39
   79|      9|    case '\\': return "\\\\";  // case 92
   80|      9|    case 127: return "\\177";  // (delete)
   81|      9|
   82|      9|    // case '\?': return "\\\?";
   83|      9|    default:
   84|      3|      ss << value;
   85|      3|      return ss.str();
   86|      0|    };
   87|      0|  }
   88|       |
   89|       |  /// Convert a full string to one that uses proper escape sequences, as needed.
   90|      1|  static inline std::string to_escaped_string(const std::string & value) {
   91|      1|    std::stringstream ss;
   92|     36|    for (char c : value) { ss << to_escaped_string(c); }
   93|      1|    return ss.str();
   94|      1|  }
   95|       |
   96|       |
   97|       |  /// Take a value and convert it to a C++-style literal.
   98|       |  /*_FORCE_COVER_START_*/template <typename LIT_TYPE>
   99|      2|  inline std::string to_literal(const LIT_TYPE & value) {
  100|      2|    return std::to_string(value);
  101|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp10to_literalIiEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
  |   99|      1|  inline std::string to_literal(const LIT_TYPE & value) {
  |  100|      1|    return std::to_string(value);
  |  101|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp10to_literalIdEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKT_:
  |   99|      1|  inline std::string to_literal(const LIT_TYPE & value) {
  |  100|      1|    return std::to_string(value);
  |  101|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  102|       |
  103|       |  /// Take a char and convert it to a C++-style literal.
  104|      2|  static inline std::string to_literal(char value) {
  105|      2|    std::stringstream ss;
  106|      2|    ss << "'" << to_escaped_string(value) << "'";
  107|      2|    return ss.str();
  108|      2|  }
  109|       |
  110|       |  /// Take a string and convert it to a C++-style literal.
  111|      0|  static inline std::string to_literal(const std::string & value) {
  112|      0|    // Add quotes to the ends and convert each character.
  113|      0|    std::stringstream ss;
  114|      0|    ss << "\"";
  115|      0|    for (char c : value) {
  116|      0|      ss << to_escaped_string(c);
  117|      0|    }
  118|      0|    ss << "\"";
  119|      0|    return ss.str();
  120|      0|  }
  121|       |
  122|       |  /// Convert a string to all uppercase.
  123|      0|  static inline std::string to_upper(std::string value) {
  124|      0|    constexpr int char_shift = 'a' - 'A';
  125|      0|    for (auto & x : value) {
  126|      0|      if (x >= 'a' && x <= 'z') x = (char) (x - char_shift);
  127|      0|    }
  128|      0|    return value;
  129|      0|  }
  130|       |
  131|       |  /// Convert a string to all lowercase.
  132|      0|  static inline std::string to_lower(std::string value) {
  133|      0|    constexpr int char_shift = 'a' - 'A';
  134|      0|    for (auto & x : value) {
  135|      0|      if (x >= 'A' && x <= 'Z') x = (char) (x + char_shift);
  136|      0|    }
  137|      0|    return value;
  138|      0|  }
  139|       |
  140|       |  // Convert an integer to a roman numeral string.
  141|      0|  static inline std::string to_roman_numeral(int val, const std::string & prefix="") {
  142|      0|    std::string ret_string(prefix);
  143|      0|    if (val < 0) ret_string += to_roman_numeral(-val, "-");
  144|      0|    else if (val > 3999) { ; } // Out of bounds; return a blank;
  145|      0|    else if (val >= 1000) ret_string += to_roman_numeral(val - 1000, "M");
  146|      0|    else if (val >= 900) ret_string += to_roman_numeral(val - 900, "CM");
  147|      0|    else if (val >= 500) ret_string += to_roman_numeral(val - 500, "D");
  148|      0|    else if (val >= 400) ret_string += to_roman_numeral(val - 400, "CD");
  149|      0|    else if (val >= 100) ret_string += to_roman_numeral(val - 100, "C");
  150|      0|    else if (val >= 90) ret_string += to_roman_numeral(val - 90, "XC");
  151|      0|    else if (val >= 50) ret_string += to_roman_numeral(val - 50, "L");
  152|      0|    else if (val >= 40) ret_string += to_roman_numeral(val - 40, "XL");
  153|      0|    else if (val >= 10) ret_string += to_roman_numeral(val - 10, "X");
  154|      0|    else if (val == 9) ret_string += "IX";
  155|      0|    else if (val >= 5) ret_string += to_roman_numeral(val - 5, "V");
  156|      0|    else if (val == 4) ret_string += "IV";
  157|      0|    else if (val > 0) ret_string += to_roman_numeral(val - 1, "I");
  158|      0|
  159|      0|    // else we already have it exactly and don't need to return anything.
  160|      0|    return ret_string;
  161|      0|  }
  162|       |
  163|       |
  164|       |  /// Determine if a character is whitespace.
  165|     96|  inline bool is_whitespace(char test_char) {
  166|     96|    return (test_char == ' ' || test_char == '\n' || test_char == '\r' || test_char == '\t');
  167|     96|  }
  168|       |
  169|       |  /// Determine if a character is an uppercase letter.
  170|    108|  inline bool is_upper_letter(char test_char) {
  171|    108|    return (test_char >= 'A' && test_char <= 'Z');
  172|    108|  }
  173|       |
  174|       |  /// Determine if a character is a lowercase letter.
  175|     96|  inline bool is_lower_letter(char test_char) {
  176|     96|    return (test_char >= 'a' && test_char <= 'z');
  177|     96|  }
  178|       |
  179|       |  /// Determine if a character is a letter of any kind.
  180|     72|  inline bool is_letter(char test_char) {
  181|     72|    return is_upper_letter(test_char) || is_lower_letter(test_char);
  182|     72|  }
  183|       |
  184|       |  /// Determine if a character is a digit.
  185|     50|  inline bool is_digit(char test_char) {
  186|     50|    return (test_char >= '0' && test_char <= '9');
  187|     50|  }
  188|       |
  189|       |  /// Determine if a character is a letter or digit.
  190|     36|  inline bool is_alphanumeric(char test_char) {
  191|     36|    return is_letter(test_char) || is_digit(test_char);
  192|     36|  }
  193|       |
  194|       |  /// Determine if a character is a letter, digit, or underscore.
  195|      0|  inline bool is_idchar(char test_char) {
  196|      0|    return is_alphanumeric(test_char) || test_char == '_';
  197|      0|  }
  198|       |
  199|       |  /// Determine if a character is in a set of characters (represented as a string)
  200|      0|  static inline bool is_one_of(char test_char, const std::string & char_set) {
  201|      0|    for (char x : char_set) if (test_char == x) return true;
  202|      0|    return false;
  203|      0|  }
  204|       |
  205|       |  /// Determine if a string is composed only of a set of characters (represented as a string)
  206|      0|  static inline bool is_composed_of(const std::string & test_str, const std::string & char_set) {
  207|      0|    for (char x : test_str) if (!is_one_of(x, char_set)) return false;
  208|      0|    return true;
  209|      0|  }
  210|       |
  211|       |  /// Determine if there is whitespace anywhere in a string.
  212|      0|  inline bool has_whitespace(const std::string & test_str) {
  213|      0|    for (char c : test_str) if (is_whitespace(c)) return true;
  214|      0|    return false;
  215|      0|  }
  216|       |
  217|       |  /// Determine if there are any uppercase letters in a string.
  218|      0|  inline bool has_upper_letter(const std::string & test_str) {
  219|      0|    for (char c : test_str) if (is_upper_letter(c)) return true;
  220|      0|    return false;
  221|      0|  }
  222|       |
  223|       |  /// Determine if there are any lowercase letters in a string.
  224|      0|  inline bool has_lower_letter(const std::string & test_str) {
  225|      0|    for (char c : test_str) if (is_lower_letter(c)) return true;
  226|      0|    return false;
  227|      0|  }
  228|       |
  229|       |  /// Determine if there are any letters in a string.
  230|      0|  inline bool has_letter(const std::string & test_str) {
  231|      0|    for (char c : test_str) if (is_letter(c)) return true;
  232|      0|    return false;
  233|      0|  }
  234|       |
  235|       |  /// Determine if there are any digits in a string.
  236|      0|  inline bool has_digit(const std::string & test_str) {
  237|      0|    for (char c : test_str) if (is_digit(c)) return true;
  238|      0|    return false;
  239|      0|  }
  240|       |
  241|       |  /// Determine if there are any letters or digits anywhere in a string.
  242|      0|  inline bool has_alphanumeric(const std::string & test_str) {
  243|      0|    for (char c : test_str) if (is_alphanumeric(c)) return true;
  244|      0|    return false;
  245|      0|  }
  246|       |
  247|       |  /// Determine if there are any letters, digit, or underscores anywhere in a string.
  248|      0|  inline bool has_idchar(const std::string & test_str) {
  249|      0|    for (char c : test_str) if (is_idchar(c)) return true;
  250|      0|    return false;
  251|      0|  }
  252|       |
  253|       |  /// Determine if a specified set of characters appears anywhere in a string.
  254|      0|  static inline bool has_one_of(const std::string & test_str, const std::string & char_set) {
  255|      0|    for (char c : test_str) if (is_one_of(c, char_set)) return true;
  256|      0|    return false;
  257|      0|  }
  258|       |
  259|       |
  260|       |  /// If no functions are provided to is_valid(), always return false as base case.
  261|     62|  inline bool is_valid(char test_char) { return false; }
  262|       |
  263|       |  /// Determine if a character passes any of the test functions provided.
  264|       |  /*_FORCE_COVER_START_*/template <typename... FUNS>
  265|    229|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  266|    229|    return fun1(test_char) || is_valid(test_char, funs...);
  267|    229|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8is_validIJEEEbcSt8functionIFbcEEDpT_:
  |  265|     65|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     65|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     65|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8is_validIJZL32____C_A_T_C_H____T_E_S_T____1060vE3$_6ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_7ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_8ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_9ZL32____C_A_T_C_H____T_E_S_T____1060vE4$_10EEEbcSt8functionIFbcEEDpT_:
  |  265|     36|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     36|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     36|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8is_validIJZL32____C_A_T_C_H____T_E_S_T____1060vE3$_7ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_8ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_9ZL32____C_A_T_C_H____T_E_S_T____1060vE4$_10EEEbcSt8functionIFbcEEDpT_:
  |  265|     36|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     36|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     36|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8is_validIJZL32____C_A_T_C_H____T_E_S_T____1060vE3$_8ZL32____C_A_T_C_H____T_E_S_T____1060vE3$_9ZL32____C_A_T_C_H____T_E_S_T____1060vE4$_10EEEbcSt8functionIFbcEEDpT_:
  |  265|     33|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     33|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     33|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8is_validIJZL32____C_A_T_C_H____T_E_S_T____1060vE3$_9ZL32____C_A_T_C_H____T_E_S_T____1060vE4$_10EEEbcSt8functionIFbcEEDpT_:
  |  265|     30|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     30|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     30|  }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8is_validIJZL32____C_A_T_C_H____T_E_S_T____1060vE4$_10EEEbcSt8functionIFbcEEDpT_:
  |  265|     29|  inline bool is_valid(char test_char, std::function<bool(char)> fun1, FUNS... funs) {
  |  266|     29|    return fun1(test_char) || is_valid(test_char, funs...);
  |  267|     29|  }/*_FORCE_COVER_END_*/
  ------------------
  268|       |
  269|       |  /// For a string to be valid, each character must pass at least one provided function.
  270|       |  /*_FORCE_COVER_START_*/template <typename... FUNS>
  271|       |  static inline bool is_valid(const std::string & test_str, FUNS... funs) {
  272|       |    for (char x : test_str) if ( !is_valid(x, funs...) ) return false;
  273|       |    return true;
  274|       |  }/*_FORCE_COVER_END_*/
  275|       |
  276|       |
  277|       |  /// Pop a segment from the beginning of a string as another string, shortening original.
  278|       |  static inline std::string string_pop_fixed(std::string & in_string, std::size_t end_pos, size_t delim_size=0)
  279|      6|  {
  280|      6|    std::string out_string = "";
  281|      6|    if (end_pos == 0);                        // Not popping anything!
  282|      6|    else if (end_pos == std::string::npos) {  // Popping whole string.
  283|      0|      out_string = in_string;
  284|      0|      in_string = "";
  285|      0|    }
  286|      6|    else {
  287|      6|      out_string = in_string.substr(0, end_pos);  // Copy up to the deliminator for ouput
  288|      6|      in_string.erase(0, end_pos + delim_size);   // Delete output string AND deliminator
  289|      6|    }
  290|      6|
  291|      6|    return out_string;
  292|      6|  }
  293|       |
  294|       |  /// Get a segment from the beginning of a string as another string, leaving original untouched.
  295|       |  static inline std::string string_get_range(const std::string & in_string, std::size_t start_pos,
  296|      1|                                             std::size_t end_pos) {
  297|      1|    if (end_pos == std::string::npos) end_pos = in_string.size() - start_pos;
  298|      1|    return in_string.substr(start_pos, end_pos);
  299|      1|  }
  300|       |
  301|       |  /// Remove a prefix of the input string (up to a specified delimeter) and return it.  If the
  302|       |  /// delimeter is not found, return the entire input string and clear it.
  303|      2|  inline std::string string_pop(std::string & in_string, const char delim=' ') {
  304|      2|    return string_pop_fixed(in_string, in_string.find(delim), 1);
  305|      2|  }
  306|       |
  307|       |  /// Return a prefix of the input string (up to a specified delimeter), but do not modify it.
  308|       |  /// If the delimeter is not found, return the entire input string.
  309|      0|  inline std::string string_get(const std::string & in_string, const char delim, size_t start_pos=0) {
  310|      0|    return string_get_range(in_string, start_pos, in_string.find(delim, start_pos));
  311|      0|  }
  312|       |
  313|       |  /// Remove a prefix of the input string (up to any of a specified set of delimeters) and
  314|       |  /// return it.  If the delimeter is not found, return the entire input string and clear it.
  315|      3|  inline std::string string_pop(std::string & in_string, const std::string & delim_set) {
  316|      3|    return string_pop_fixed(in_string, in_string.find_first_of(delim_set), 1);
  317|      3|  }
  318|       |
  319|       |  /// Return a prefix of the input string (up to any of a specified set of delimeters), but do not
  320|       |  /// modify it. If the delimeter is not found, return the entire input string.
  321|      1|  inline std::string string_get(const std::string & in_string, const std::string & delim_set, size_t start_pos=0) {
  322|      1|    return string_get_range(in_string, start_pos, in_string.find_first_of(delim_set, start_pos));
  323|      1|  }
  324|       |
  325|       |  /// Remove a prefix of a string, up to the first whitespace, and return it.
  326|      1|  inline std::string string_pop_word(std::string & in_string) {
  327|      1|    // Whitespace = ' ' '\n' '\r' or '\t'
  328|      1|    return string_pop(in_string, " \n\r\t");
  329|      1|  }
  330|       |
  331|       |  /// Return a prefix of a string, up to the first whitespace (do not modify the original string)
  332|      1|  inline std::string string_get_word(const std::string & in_string, size_t start_pos=0) {
  333|      1|    // Whitespace = ' ' '\n' '\r' or '\t'
  334|      1|    return string_get(in_string, " \n\r\t", start_pos);
  335|      1|  }
  336|       |
  337|       |  /// Remove a prefix of a string, up to the first newline, and return it.
  338|      1|  inline std::string string_pop_line(std::string & in_string) {
  339|      1|    return string_pop(in_string, '\n');
  340|      1|  }
  341|       |
  342|       |  /// Return a prefix of a string, up to the first newline (do not modify the original string)
  343|      0|  inline std::string string_get_line(const std::string & in_string, size_t start_pos=0) {
  344|      0|    return string_get(in_string, '\n', start_pos);
  345|      0|  }
  346|       |
  347|       |  /// Remove all whitespace at the beginning of a string.  Return the whitespace removed.
  348|      1|  inline std::string left_justify(std::string & in_string) {
  349|      1|    return string_pop_fixed(in_string, in_string.find_first_not_of(" \n\r\t"));
  350|      1|  }
  351|       |
  352|       |  /// Remove all whitespace at the end of a string.
  353|      1|  inline void right_justify(std::string & in_string) {
  354|      1|    // @CAO *very* inefficient at the moment.
  355|      4|    while (is_whitespace(in_string.back())) in_string.pop_back();
  356|      1|  }
  357|       |
  358|       |  /// Remove instances of characters from file.
  359|      0|  static inline void remove_chars(std::string & in_string, std::string chars) {
  360|      0|    size_t cur_pos = 0;
  361|      0|    for (size_t i = 0; i < in_string.size(); i++) {
  362|      0|      if (is_one_of(in_string[i], chars)) continue;
  363|      0|      in_string[cur_pos++] = in_string[i];
  364|      0|    }
  365|      0|    in_string.resize(cur_pos);
  366|      0|  }
  367|       |
  368|       |  /// Every time one or more whitespace characters appear replace them with a single space.
  369|      1|  static inline void compress_whitespace(std::string & in_string) {
  370|      1|    const size_t strlen = in_string.size();
  371|      1|    bool last_whitespace = true;          // Remove whitespace from beginning of line.
  372|      1|    size_t pos = 0;
  373|      1|
  374|     39|    for (size_t i = 0; i < strlen; i++) {
  375|     38|      if (is_whitespace(in_string[i])) {  // This char is whitespace
  376|     10|        if (last_whitespace) continue;
  377|      5|        in_string[pos++] = ' ';
  378|      5|        last_whitespace = true;
  379|      5|      }
  380|     28|      else {  // Not whitespace
  381|     28|        in_string[pos++] = in_string[i];
  382|     28|        last_whitespace = false;
  383|     28|      }
  384|     38|    }
  385|      1|
  386|      1|    if (pos && last_whitespace) pos--;   // If the end of the line is whitespace, remove it.
  387|      1|
  388|      1|    in_string.resize(pos);
  389|      1|  }
  390|       |
  391|       |  /// Remove all whitespace from anywhere within a string.
  392|      1|  static inline void remove_whitespace(std::string & in_string) {
  393|      1|    const size_t strlen = in_string.size();
  394|      1|    size_t pos = 0;
  395|      1|
  396|     19|    for (size_t i = 0; i < strlen; i++) {
  397|     18|      if (is_whitespace(in_string[i])) continue;
  398|     15|      in_string[pos++] = in_string[i];
  399|     15|    }
  400|      1|
  401|      1|    in_string.resize(pos);
  402|      1|  }
  403|       |
  404|       |  /// Remove all characters from a string except letters, numbers, and whitespace.
  405|      0|  static inline void remove_punctuation(std::string & in_string) {
  406|      0|    const size_t strlen = in_string.size();
  407|      0|    size_t pos = 0;
  408|      0|
  409|      0|    for (size_t i = 0; i < strlen; i++) {
  410|      0|      const char cur_char = in_string[i];
  411|      0|      if (is_alphanumeric(cur_char) || is_whitespace(cur_char)) {
  412|      0|        in_string[pos++] = cur_char;
  413|      0|      }
  414|      0|    }
  415|      0|
  416|      0|    in_string.resize(pos);
  417|      0|  }
  418|       |
  419|       |
  420|       |  /// Cut up a string based on the provided delimitor; fill them in to the provided vector.
  421|       |  static inline void slice(const std::string & in_string, emp::vector<std::string> & out_set,
  422|      2|                           char delim='\n') {
  423|      2|    const size_t test_size = in_string.size();
  424|      2|
  425|      2|    // Count produced strings
  426|      2|    size_t out_count = 0;
  427|      2|    size_t pos = 0;
  428|     17|    while (pos < test_size) {
  429|     82|      while (pos < test_size && in_string[pos] != delim) pos++;
  430|     15|      pos++; // Skip over deliminator
  431|     15|      out_count++;  // Increment for each delim plus once at the end (so once if no delims).
  432|     15|    }
  433|      2|
  434|      2|    // And copy over the strings
  435|      2|    out_set.resize(out_count);
  436|      2|    pos = 0;
  437|      2|    size_t string_id = 0;
  438|     17|    while (pos < test_size) {
  439|     15|      out_set[string_id] = "";
  440|     82|      while (pos < test_size && in_string[pos] != delim) {
  441|     67|        out_set[string_id] += in_string[pos];
  442|     67|        pos++;
  443|     67|      }
  444|     15|      pos++;        // Skip over any final deliminator
  445|     15|      string_id++;  // Move to the next sub-string.
  446|     15|    }
  447|      2|
  448|      2|  }
  449|       |
  450|       |  /// Slice a string without passing in result vector (may be less efficient).
  451|      1|  static inline emp::vector<std::string> slice(const std::string & in_string, char delim='\n') {
  452|      1|    emp::vector<std::string> result;
  453|      1|    slice(in_string, result, delim);
  454|      1|    return result;
  455|      1|  }
  456|       |
  457|       |  /// @cond TEMPLATES
  458|       |
  459|       |  // The next functions are not efficient, but they will take any number of inputs and
  460|       |  // dynamically convert them all into a single, concatanated strings or stringstreams.
  461|       |
  462|       |  namespace internal {
  463|      1|    inline void append_sstream(std::stringstream & ss) { (void) ss; }
  464|       |
  465|       |    /*_FORCE_COVER_START_*/template <typename TYPE, typename... OTHER_TYPES>
  466|      4|    static void append_sstream(std::stringstream & ss, TYPE value, OTHER_TYPES... other_values) {
  467|      4|      ss << value;
  468|      4|      append_sstream(ss, other_values...);
  469|      4|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJcS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJPKcEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJcS3_mS3_cS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJPKcmS3_cS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJmS3_cS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamImJPKccS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJcccEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJccEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJcEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJcS3_mS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIcJPKcmS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJmS3_EEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamImJPKcEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES3_mEEEvRNS4_18basic_stringstreamIcS7_S8_EET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJPKcmEEEvRNS2_18basic_stringstreamIcS5_S6_EET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJmEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamImJEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamIPKcJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEEvRNS4_18basic_stringstreamIcS7_S8_EET_DpT0_
  ------------------
  | Unexecuted instantiation: test_tools.cc:_ZN3emp8internalL14append_sstreamINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEEvRNS2_18basic_stringstreamIcS5_S6_EET_DpT0_
  ------------------
  | test_tools.cc:_ZN3emp8internalL14append_sstreamINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJbciEEEvRNS2_18basic_stringstreamIcS5_S6_EET_DpT0_:
  |  466|      1|    static void append_sstream(std::stringstream & ss, TYPE value, OTHER_TYPES... other_values) {
  |  467|      1|      ss << value;
  |  468|      1|      append_sstream(ss, other_values...);
  |  469|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8internalL14append_sstreamIbJciEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_:
  |  466|      1|    static void append_sstream(std::stringstream & ss, TYPE value, OTHER_TYPES... other_values) {
  |  467|      1|      ss << value;
  |  468|      1|      append_sstream(ss, other_values...);
  |  469|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8internalL14append_sstreamIcJiEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_:
  |  466|      1|    static void append_sstream(std::stringstream & ss, TYPE value, OTHER_TYPES... other_values) {
  |  467|      1|      ss << value;
  |  468|      1|      append_sstream(ss, other_values...);
  |  469|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | test_tools.cc:_ZN3emp8internalL14append_sstreamIiJEEEvRNSt7__cxx1118basic_stringstreamIcSt11char_traitsIcESaIcEEET_DpT0_:
  |  466|      1|    static void append_sstream(std::stringstream & ss, TYPE value, OTHER_TYPES... other_values) {
  |  467|      1|      ss << value;
  |  468|      1|      append_sstream(ss, other_values...);
  |  469|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  470|       |
  471|       |    // Give mutliple implmentations of to_string_impl... if we can append quickly, do so!!
  472|       |    /*_FORCE_COVER_START_*/template <typename T1, typename T2, typename... EXTRA_TYPES>
  473|      1|    inline std::string to_string_impl(int, T1 val1, T2 val2, EXTRA_TYPES... extra_values) {
  474|      1|      std::stringstream ss;
  475|      1|      append_sstream(ss, val1, val2, extra_values...);
  476|      1|      return ss.str();
  477|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKccJS3_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiT_T0_DpT1_
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKccJS3_mS3_cS3_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiT_T0_DpT1_
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKccJccEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiT_T0_DpT1_
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKccJS3_mS3_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiT_T0_DpT1_
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJS3_mEEES9_iT_T0_DpT1_
  ------------------
  | Unexecuted instantiation: _ZN3emp8internal14to_string_implIPKcNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEJEEES9_iT_T0_DpT1_
  ------------------
  | _ZN3emp8internal14to_string_implINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbJciEEES7_iT_T0_DpT1_:
  |  473|      1|    inline std::string to_string_impl(int, T1 val1, T2 val2, EXTRA_TYPES... extra_values) {
  |  474|      1|      std::stringstream ss;
  |  475|      1|      append_sstream(ss, val1, val2, extra_values...);
  |  476|      1|      return ss.str();
  |  477|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  478|       |
  479|       |    // If std::to_string knows how to handle the case use it!
  480|       |    /*_FORCE_COVER_START_*/template <typename T>
  481|       |    inline auto to_string_impl(bool, T val) -> decltype(std::to_string(val))
  482|     21|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIsEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      1|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIlEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      2|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implItEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      1|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIjEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      1|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implImEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      6|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIfEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      1|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIiEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      6|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implIdEEDTclsr3stdE9to_stringfp0_EEbT_:
  |  482|      3|    { return std::to_string(val); }/*_FORCE_COVER_END_*/
  ------------------
  483|       |
  484|       |    // If there's another single POD entry, we can convert it manually and pass the result back.
  485|      2|    inline std::string to_string_impl(bool, const std::string & s) { return s; }
  486|      2|    inline std::string to_string_impl(bool, char c) { return std::string(1,c); }
  487|      1|    inline std::string to_string_impl(bool, unsigned char c) { return std::string(1,(char)c); }
  488|      0|    inline std::string to_string_impl(bool, char* str) { return std::string(str); }
  489|       |
  490|       |    // Operate on std::containers
  491|       |    /*_FORCE_COVER_START_*/template <typename T>
  492|       |    inline typename emp::sfinae_decoy<std::string, typename T::value_type>
  493|      2|    to_string_impl(bool, T container) {
  494|      2|      std::stringstream ss;
  495|      2|      ss << "[ ";
  496|      6|      for (const auto & el : container) {
  497|      6|        ss << to_string_impl(true, el);
  498|      6|        ss << " ";
  499|      6|      }
  500|      2|      ss << "]";
  501|      2|      return ss.str();
  502|      2|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implINS_6vectorImJEEEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbT_:
  |  493|      1|    to_string_impl(bool, T container) {
  |  494|      1|      std::stringstream ss;
  |  495|      1|      ss << "[ ";
  |  496|      3|      for (const auto & el : container) {
  |  497|      3|        ss << to_string_impl(true, el);
  |  498|      3|        ss << " ";
  |  499|      3|      }
  |  500|      1|      ss << "]";
  |  501|      1|      return ss.str();
  |  502|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp8internal14to_string_implISt5arrayIiLm3EEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEbT_:
  |  493|      1|    to_string_impl(bool, T container) {
  |  494|      1|      std::stringstream ss;
  |  495|      1|      ss << "[ ";
  |  496|      3|      for (const auto & el : container) {
  |  497|      3|        ss << to_string_impl(true, el);
  |  498|      3|        ss << " ";
  |  499|      3|      }
  |  500|      1|      ss << "]";
  |  501|      1|      return ss.str();
  |  502|      1|    }/*_FORCE_COVER_END_*/
  ------------------
  503|       |  }
  504|       |
  505|       |  /// @endcond
  506|       |
  507|       |  /// This function does its very best to convert everything it's to a string. Takes any number
  508|       |  /// of arguments and returns a single string containing all of them concatenated. Objects can be
  509|       |  /// any normal (POD) data type, container, or anything that can be passed into a stringstream.
  510|       |  /*_FORCE_COVER_START_*/template <typename... ALL_TYPES>
  511|     23|  inline std::string to_string(ALL_TYPES &&... all_values) {
  512|     23|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  513|     23|  }/*_FORCE_COVER_END_*/
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA10_KcRcRA13_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA10_KcRcRA14_S1_RmRA9_S1_S4_RA2_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA25_KcRccS4_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA38_KcRcRA3_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA43_KcRcRA3_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA34_KcRcRA3_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRA33_KcRcRA15_S1_RmRA2_S1_EEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRPKcRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES3_RmEEES9_DpOT_
  ------------------
  | Unexecuted instantiation: _ZN3emp9to_stringIJRPKcRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEES9_DpOT_
  ------------------
  | _ZN3emp9to_stringIJRA2_KcEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEEEES6_DpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJcEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      2|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      2|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJsEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJlEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      2|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      2|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      2|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJtEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJjEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJmEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      3|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      3|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJfEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJNS_6vectorImJEEEEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJhEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJRNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERbRcRiEEES6_DpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJRSt5arrayIiLm3EEEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      1|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      1|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      1|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJiEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      3|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      3|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  | _ZN3emp9to_stringIJdEEENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEDpOT_:
  |  511|      3|  inline std::string to_string(ALL_TYPES &&... all_values) {
  |  512|      3|    return internal::to_string_impl(true, std::forward<ALL_TYPES>(all_values)...);
  |  513|      3|  }/*_FORCE_COVER_END_*/
  ------------------
  514|       |
  515|       |  /// This function tries to convert a string into any type you're looking for...  You just
  516|       |  /// need to specify the out type as the template argument.
  517|       |  /*_FORCE_COVER_START_*/template <typename T>
  518|       |  inline T from_string(const std::string & str) {
  519|       |    std::stringstream ss;
  520|       |    ss << str;
  521|       |    T out_val;
  522|       |    ss >> out_val;
  523|       |    return out_val;
  524|       |  }/*_FORCE_COVER_END_*/
  525|       |
  526|       |  namespace internal {
  527|      0|    static inline void _from_string(std::stringstream &) { ; }
  528|       |
  529|       |    /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
  530|       |    void _from_string(std::stringstream & ss, T & arg1, Ts... extra_args) {
  531|       |      ss >> arg1;
  532|       |      _from_string(ss, extra_args...);
  533|       |    }/*_FORCE_COVER_END_*/
  534|       |  }
  535|       |
  536|       |  /// The from_string() function can also take multiple args instead of a return.
  537|       |  /*_FORCE_COVER_START_*/template <typename... Ts>
  538|       |  inline void from_string(const std::string & str, Ts &... args) {
  539|       |    std::stringstream ss;
  540|       |    ss << str;
  541|       |    internal::_from_string(ss, args...);
  542|       |  }/*_FORCE_COVER_END_*/
  543|       |
  544|       |  /// The from_strings() function takes a vector of strings and convets them into a vector
  545|       |  /// of the appropriate type.
  546|       |  /*_FORCE_COVER_START_*/template <typename T>
  547|       |  inline emp::vector<T> from_strings(const emp::vector<std::string> & string_v) {
  548|       |    emp::vector<T> vals(string_v.size());
  549|       |    for (size_t i = 0; i < string_v.size(); i++) {
  550|       |      vals[i] = from_string<T>(string_v[i]);
  551|       |    }
  552|       |    return vals;
  553|       |  }/*_FORCE_COVER_END_*/
  554|       |
  555|       |}
  556|       |
  557|       |#endif
  558|       |

/home/emily/repos/Empirical_Tests/source/tools/vector_utils.h:
    1|       |/**
    2|       | *  @note This file is part of Empirical, https://github.com/devosoft/Empirical
    3|       | *  @copyright Copyright (C) Michigan State University, MIT Software license; see doc/LICENSE.md
    4|       | *  @date 2017-2018
    5|       | *
    6|       | *  @file vector_utils.h
    7|       | *  @brief A set of simple functions to manipulate emp::vector
    8|       | *  @note Status: BETA
    9|       | */
   10|       |
   11|       |#ifndef EMP_VECTOR_UTILS_H
   12|       |#define EMP_VECTOR_UTILS_H
   13|       |
   14|       |#include <algorithm>
   15|       |#include <functional>
   16|       |
   17|       |#include "../base/vector.h"
   18|       |
   19|       |namespace emp {
   20|       |
   21|       |  /// Return the first position of a value in a vector (or -1 if none exists)
   22|       |  /*_FORCE_COVER_START_*/template <typename T>
   23|      3|  int FindValue(const emp::vector<T> vec, const T & val, size_t start_pos=0) {
   24|     12|    for (size_t i = start_pos; i < vec.size(); i++) {
   25|     11|      if (vec[i] == val) return (int) i;
   26|     11|    }
   27|      3|    return -1;
   28|      3|  }/*_FORCE_COVER_END_*/
   29|       |
   30|       |  /// Return whether a value exists in a vector.s
   31|       |  /*_FORCE_COVER_START_*/template <typename T>
   32|      2|  bool Has(const emp::vector<T> vec, const T & val) {
   33|      2|    return FindValue(vec, val) >= 0;
   34|      2|  }/*_FORCE_COVER_END_*/
   35|       |
   36|       |  /// Print the contects of a vector.
   37|       |  /*_FORCE_COVER_START_*/template <typename T>
   38|       |  void Print(const emp::vector<T> & v, std::ostream & os=std::cout, const std::string & spacer=" ") {
   39|       |    for (size_t id = 0; id < v.size(); id++) {
   40|       |      if (id) os << spacer; // Put a space before second element and beyond.
   41|       |      os << v[id];
   42|       |    }
   43|       |  }/*_FORCE_COVER_END_*/
   44|       |
   45|       |  /// Find the index with the "optimal" value (picks first in cases of a tie).
   46|       |  /// @param v Any object allowing indexing (e.g. vector, array, etc.)
   47|       |  /// @param fun Comparison function; returns true if the first value os more optimal than second.
   48|       |  /*_FORCE_COVER_START_*/template <typename T>
   49|       |  size_t FindIndex(const T & v,
   50|       |                   const std::function<bool(typename T::value_type, typename T::value_type)> & fun) {
   51|       |    emp_assert(v.size() > 0);
   52|       |    using v_type = typename T::value_type;
   53|       |    v_type best_val = v[0];
   54|       |    size_t best_index = 0;
   55|       |    for (size_t i = 1; i < v.size(); i++) {
   56|       |      if (fun(v[i], best_val)) {
   57|       |        best_val = v[i];
   58|       |        best_index = i;
   59|       |      }
   60|       |    }
   61|       |    return best_index;
   62|       |  }/*_FORCE_COVER_END_*/
   63|       |
   64|       |  /// Find the index with the minimal value (picks first in cases of a tie).
   65|       |  /*_FORCE_COVER_START_*/template <typename T>
   66|       |  size_t FindMinIndex(const T & v) {
   67|       |    using v_type = typename T::value_type;
   68|       |    return FindIndex(v, [](v_type a, v_type b){ return a < b; });
   69|       |  }/*_FORCE_COVER_END_*/
   70|       |
   71|       |  /// Find the index with the maximal value (picks first in cases of a tie).
   72|       |  /*_FORCE_COVER_START_*/template <typename T>
   73|       |  size_t FindMaxIndex(const T & v) {
   74|       |    using v_type = typename T::value_type;
   75|       |    return FindIndex(v, [](v_type a, v_type b){ return a > b; });
   76|       |  }/*_FORCE_COVER_END_*/
   77|       |
   78|       |
   79|       |  /// Sum up the contents of a vector.
   80|       |  /*_FORCE_COVER_START_*/template <typename T>
   81|       |  T Sum(const emp::vector<T> & v) {
   82|       |    T sum = 0;
   83|       |    for (auto x : v) sum += x;
   84|       |    return sum;
   85|       |  }/*_FORCE_COVER_END_*/
   86|       |
   87|       |  /// Multiply all of the contents of a vector.
   88|       |  /*_FORCE_COVER_START_*/template <typename T>
   89|      1|  T Product(const emp::vector<T> & v) {
   90|      1|    T product = 1;
   91|      5|    for (auto x : v) product *= x;
   92|      1|    return product;
   93|      1|  }/*_FORCE_COVER_END_*/
   94|       |
   95|       |  /// A quick shortcut for sorting a vector.
   96|       |  /*_FORCE_COVER_START_*/template <typename T, typename... Ts>
   97|      1|  void Sort(emp::vector<T> & v, Ts... args) {
   98|      1|    std::sort(v.begin(), v.end(), std::forward<Ts>(args)...);
   99|      1|  }/*_FORCE_COVER_END_*/
  100|       |
  101|       |  /// Returns a vector containing a chunk of elements from @param vec
  102|       |  /// starting at @param start and going up to but not including @param stop.
  103|       |  /*_FORCE_COVER_START_*/template <typename T>
  104|      1|  emp::vector<T> Slice(emp::vector<T> vec, int start, int stop) {
  105|      1|    emp_assert(start < stop, start, stop);
  106|      1|    emp_assert(start < (int)vec.size(), start, vec.size());
  107|      1|    emp_assert(stop <= (int)vec.size(), stop, vec.size());
  108|      1|
  109|      1|    emp::vector<T> new_vec;
  110|      3|    for (int i = start; i < stop; i++){
  111|      2|      new_vec.push_back(vec[i]);
  112|      2|    }
  113|      1|    return new_vec;
  114|      1|  }/*_FORCE_COVER_END_*/
  115|       |
  116|       |  /// Tree manipulation in vectors.
  117|      0|  constexpr size_t tree_left(size_t id) { return id*2+1; }
  118|      0|  constexpr size_t tree_right(size_t id) { return id*2+2; }
  119|      0|  constexpr size_t tree_parent(size_t id) { return (id-1)/2; }
  120|       |
  121|       |  // == Heap manipulation ==
  122|       |
  123|       |  /// Heapify an individual node in a vector.
  124|       |  /*_FORCE_COVER_START_*/template <typename T>
  125|       |  bool Heapify(emp::vector<T> & v, size_t id) {
  126|       |    const size_t id_left = tree_left(id);
  127|       |    if (id_left >= v.size()) return false;  // Nothing left to heapify.
  128|       |
  129|       |    const T val = v[id];
  130|       |    const T val_left = v[id_left];
  131|       |
  132|       |    const size_t id_right = tree_right(id);
  133|       |    if (id_right < v.size()) {
  134|       |      const T val_right = v[id_right];
  135|       |      if (val_right > val_left && val_right > val) {
  136|       |        v[id] = val_right;
  137|       |        v[id_right] = val;
  138|       |        Heapify(v, id_right);
  139|       |        return true;
  140|       |      }
  141|       |    }
  142|       |
  143|       |    if (val_left > val) {
  144|       |      v[id] = val_left;
  145|       |      v[id_left] = val;
  146|       |      Heapify(v, id_left);
  147|       |      return true;
  148|       |    }
  149|       |
  150|       |    return false;  // No changes need to be made.
  151|       |  }/*_FORCE_COVER_END_*/
  152|       |
  153|       |  /// Heapify all elements in a vector.
  154|       |  /*_FORCE_COVER_START_*/template <typename T>
  155|       |  void Heapify(emp::vector<T> & v) {
  156|       |    size_t id = v.size();
  157|       |    while (id-- > 0) emp::Heapify(v, id);
  158|       |  }/*_FORCE_COVER_END_*/
  159|       |
  160|       |  /// Extraxt maximum element from a heap.
  161|       |  /*_FORCE_COVER_START_*/template <typename T>
  162|       |  T HeapExtract(emp::vector<T> & v) {
  163|       |    emp_assert(v.size(), "Cannot extract from an empty heap!");
  164|       |    T out = v[0];
  165|       |    if (v.size() > 1) {
  166|       |      const size_t last_pos = v.size() - 1;
  167|       |      v[0] = v[last_pos];
  168|       |      v.resize(last_pos);
  169|       |      Heapify(v,0);
  170|       |    }
  171|       |    else v.resize(0);
  172|       |    return out;
  173|       |  }/*_FORCE_COVER_END_*/
  174|       |
  175|       |  /// Insert a new element into a heap.
  176|       |  /*_FORCE_COVER_START_*/template <typename T>
  177|       |  void HeapInsert(emp::vector<T> & v, T val) {
  178|       |    size_t pos = v.size();
  179|       |    v.push_back(val);
  180|       |    while (pos > 0) {
  181|       |      pos = tree_parent(pos);
  182|       |      if (!Heapify(v,pos)) break;
  183|       |    }
  184|       |  }/*_FORCE_COVER_END_*/
  185|       |
  186|       |}
  187|       |
  188|       |#endif
  189|       |

/home/emily/repos/Empirical_Tests/tests/test_tools.cc:
    1|       |//  This file is part of Empirical, https://github.com/devosoft/Empirical
    2|       |//  Copyright (C) Michigan State University, 2016-2018.
    3|       |//  Released under the MIT Software license; see doc/LICENSE
    4|       |//
    5|       |//  Tests for files in the tools/ folder.
    6|       |
    7|       |
    8|       |#define EMP_DECORATE(X) [X]
    9|       |#define EMP_DECORATE_PAIR(X,Y) [X-Y]
   10|       |#define CATCH_CONFIG_MAIN
   11|       |
   12|       |#include "third-party/Catch/single_include/catch.hpp"
   13|       |
   14|       |#include <sstream>
   15|       |#include <string>
   16|       |#include <deque>
   17|       |
   18|       |#include "tools/BitMatrix.h"
   19|       |#include "tools/BitSet.h"
   20|       |#include "tools/BitVector.h"
   21|       |#include "tools/DFA.h"
   22|       |#include "tools/DynamicString.h"
   23|       |#include "tools/FunctionSet.h"
   24|       |#include "tools/Graph.h"
   25|       |#include "tools/Lexer.h"
   26|       |#include "tools/NFA.h"
   27|       |#include "tools/RegEx.h"
   28|       |#include "tools/Random.h"
   29|       |#include "tools/TypeTracker.h"
   30|       |#include "tools/attrs.h"
   31|       |
   32|       |#include "tools/flex_function.h"
   33|       |#include "tools/functions.h"
   34|       |#include "tools/graph_utils.h"
   35|       |//#include "tools/grid.h"
   36|       |#include "tools/info_theory.h"
   37|       |#include "tools/lexer_utils.h"
   38|       |#include "tools/map_utils.h"
   39|       |#include "tools/math.h"
   40|       |#include "tools/mem_track.h"
   41|       |#include "tools/memo_function.h"
   42|       |#include "tools/sequence_utils.h"
   43|       |// #include "tools/serialize.h"
   44|       |#include "tools/set_utils.h"
   45|       |#include "tools/stats.h"
   46|       |#include "tools/string_utils.h"
   47|       |#include "tools/tuple_struct.h"
   48|       |#include "tools/unit_tests.h"
   49|       |#include "tools/vector_utils.h"
   50|       |
   51|       |// currently these have no coveage; we include them so we get metrics on them
   52|       |// this doesn't actually work--TODO: figure out why this doesn't work
   53|       |#include "tools/alert.h"
   54|       |#include "tools/const.h"
   55|       |#include "tools/SolveState.h"
   56|       |#include "tools/serialize_macros.h"
   57|       |
   58|       |/// Ensures that
   59|       |/// 1) A == B
   60|       |/// 2) A and B can be constexprs or non-contexprs.
   61|       |/// 3) A and B have the same values regardless of constexpr-ness.
   62|       |#define CONSTEXPR_REQUIRE_EQ(A, B)       \
   63|       |  {                                      \
   64|       |    static_assert(A == B, #A " == " #B); \
   65|       |    REQUIRE(A == B);                     \
   66|       |  }
   67|       |
   68|       |// this templating is necessary to force full coverage of templated classes.
   69|       |// Since c++ doesn't generate code for templated methods if those methods aren't
   70|       |// explicitly called (and thus our profiling doesn't see them), we have to
   71|       |// force them all to be included in the comilation.
   72|       |template class emp::BitMatrix<4, 5>;
   73|       |TEST_CASE("Test BitMatrix", "[tools]")
   74|      1|{
   75|      1|
   76|      1|  emp::BitMatrix<4,5> bm45;
   77|      1|
   78|      1|  REQUIRE(bm45.NumCols() == 4);
   79|      1|  REQUIRE(bm45.NumRows() == 5);
   80|      1|  REQUIRE(bm45.GetSize() == 20);
   81|      1|
   82|      1|  REQUIRE(bm45.Any() == false);
   83|      1|  REQUIRE(bm45.None() == true);
   84|      1|  REQUIRE(bm45.All() == false);
   85|      1|  REQUIRE(bm45.Get(1,1) == 0);
   86|      1|  REQUIRE(bm45.Get(1,2) == 0);
   87|      1|  REQUIRE(bm45.CountOnes() == 0);
   88|      1|
   89|      1|  bm45.Set(1,2);  // Try setting a single bit!
   90|      1|
   91|      1|  REQUIRE(bm45.Any() == true);
   92|      1|  REQUIRE(bm45.None() == false);
   93|      1|  REQUIRE(bm45.All() == false);
   94|      1|  REQUIRE(bm45.Get(1,1) == 0);
   95|      1|  REQUIRE(bm45.Get(1,2) == 1);
   96|      1|  REQUIRE(bm45.CountOnes() == 1);
   97|      1|  REQUIRE(bm45.FindBit() == bm45.ToID(1,2));
   98|      1|
   99|      1|  bm45.SetAll();
  100|      1|  REQUIRE(bm45.All() == true);
  101|      1|  REQUIRE(bm45.None() == false);
  102|      1|  bm45.ClearRow(2);
  103|      1|  REQUIRE(bm45.Get(2,2) == 0);
  104|      1|  REQUIRE(bm45.Get(2,1) == 1);
  105|      1|  bm45.ClearCol(1);
  106|      1|  REQUIRE(bm45.Get(1,1) == 0);
  107|      1|  bm45.Clear();
  108|      1|  REQUIRE(bm45.Get(0,2) == 0);
  109|      1|  bm45.SetRow(2);
  110|      1|  REQUIRE(bm45.Get(0,2) == 1);
  111|      1|  REQUIRE(bm45.Get(0,0) == 0);
  112|      1|  bm45.SetCol(0);
  113|      1|  REQUIRE(bm45.Get(0,0) == 1);
  114|      1|  bm45.Clear();
  115|      1|  bm45.SetRow(2);
  116|      1|  REQUIRE(bm45.Get(0,2) == 1);
  117|      1|  REQUIRE(bm45.Get(0,1) == 0);
  118|      1|  bm45.UpShift();
  119|      1|  // TODO: figure out how upshift actually works and write a real test for it
  120|      1|
  121|      1|
  122|      1|
  123|      1|/* This block needs asserts
  124|      1|  bm45 = bm45.GetReach().GetReach();
  125|      1|
  126|      1|  bm45 = bm45.DownShift();
  127|      1|
  128|      1|  bm45 = bm45.RightShift();
  129|      1|
  130|      1|  bm45 = bm45.URShift();
  131|      1|
  132|      1|  bm45 = bm45.UpShift();
  133|      1|
  134|      1|  bm45 = bm45.ULShift();
  135|      1|
  136|      1|  bm45 = bm45.LeftShift();
  137|      1|
  138|      1|  bm45 = bm45.DLShift();
  139|      1|
  140|      1|  bm45 = bm45.DRShift();
  141|      1|
  142|      1|  emp::BitMatrix<10,10> bm100;
  143|      1|  bm100.Set(9,9);
  144|      1|*/
  145|      1|}
  146|       |
  147|       |
  148|       |template class emp::BitSet<5>;
  149|       |TEST_CASE("Test BitSet", "[tools]")
  150|      1|{
  151|      1|  emp::BitSet<10> bs10;
  152|      1|  emp::BitSet<32> bs32;
  153|      1|  emp::BitSet<50> bs50;
  154|      1|  emp::BitSet<64> bs64;
  155|      1|  emp::BitSet<80> bs80;
  156|      1|
  157|      1|  bs80[70] = 1;
  158|      1|  emp::BitSet<80> bs80c(bs80);
  159|      1|  bs80 <<= 1;
  160|      1|
  161|     76|  for (size_t i = 0; i < 75; i++) {
  162|     75|    emp::BitSet<80> shift_set = bs80 >> i;
  163|     75|    REQUIRE((shift_set.CountOnes() == 1) == (i <= 71));
  164|     75|  }
  165|      1|
  166|      1|  REQUIRE(bs10[2] == false);
  167|      1|  bs10.flip(2);
  168|      1|  REQUIRE(bs10[2] == true);
  169|      1|
  170|      6|  for (size_t i = 3; i < 8; i++) {REQUIRE(bs10[i] == false);}
  171|      1|  bs10.flip(3, 8);
  172|      6|  for (size_t i = 3; i < 8; i++) {REQUIRE(bs10[i] == true);}
  173|      1|
  174|      1|  // Test importing....
  175|      1|  bs10.Import(bs80 >> 70);
  176|      1|
  177|      1|  REQUIRE(bs10.GetUInt(0) == 2);
  178|      1|
  179|      1|  // Test arbitrary bit retrieval of UInts
  180|      1|  bs80[65] = 1;
  181|      1|  REQUIRE(bs80.GetUIntAtBit(64) == 130);
  182|      1|  REQUIRE(bs80.GetValueAtBit<5>(64) == 2);
  183|      1|}
  184|       |
  185|       |
  186|       |TEST_CASE("Test BitSet timing", "[tools]")
  187|      1|{
  188|      1|  const size_t set_size = 100000;
  189|      1|  typedef emp::BitSet<set_size> TEST_TYPE;
  190|      1|
  191|      1|  TEST_TYPE set1;
  192|      1|  TEST_TYPE set2;
  193|      1|
  194|   100k|  for (size_t i = 0; i < set_size; i++) {
  195|   100k|    if (!(i%2) && (i%5)) set1[i] = 1;
  196|   100k|    if (!(i%3) && (i%7)) set2.Set(i, true);
  197|   100k|  }
  198|      1|
  199|      1|  // TIMING!!!!!
  200|      1|  std::clock_t emp_start_time = std::clock();
  201|      1|
  202|      1|  TEST_TYPE set3(set1 & set2);
  203|      1|  TEST_TYPE set4 = (set1 | set2);
  204|      1|  size_t total = 0;
  205|      1|
  206|      1|  // should probably assert that this does what we want it to do...
  207|   100k|  for (size_t i = 0; i < 100000; i++) {
  208|   100k|    set3 |= (set4 << 3);
  209|   100k|    set4 &= (set3 >> 3);
  210|   100k|    auto set5 = set3 & set4;
  211|   100k|    total += set5.CountOnes();
  212|   100k|  }
  213|      1|
  214|      1|  std::clock_t emp_tot_time = std::clock() - emp_start_time;
  215|      1|  double time = 1000.0 * ((double) emp_tot_time) / (double) CLOCKS_PER_SEC;
  216|      1|  //REQUIRE(time < 13000); // WARNING: WILL VARY ON DIFFERENT SYSTEMS
  217|      1|
  218|      1|  // END TIMING!!!
  219|      1|}
  220|       |
  221|       |
  222|       |// TEST_CASE("Test BitVector", "[tools]")
  223|       |// {
  224|       |//   emp::BitVector bv10(10);
  225|       |//   emp::BitVector bv32(32);
  226|       |//   emp::BitVector bv50(50);
  227|       |//   emp::BitVector bv64(64);
  228|       |//   emp::BitVector bv80(80);
  229|       |
  230|       |//   bv80[70] = 1;
  231|       |//   emp::BitVector bv80c(bv80);
  232|       |
  233|       |//   bv80 <<= 1;
  234|       |
  235|       |//   for (size_t i = 0; i < 75; i += 2) {
  236|       |//     emp::BitVector shift_vector = bv80 >> i;
  237|       |//     REQUIRE((shift_vector.CountOnes() == 1) == (i <= 71));
  238|       |//   }
  239|       |
  240|       |//   bv10 = (bv80 >> 70);
  241|       |
  242|       |//   // Test arbitrary bit retrieval of UInts
  243|       |//   bv80[65] = 1;
  244|       |//   REQUIRE(bv80.GetUIntAtBit(64) == 130);
  245|       |//   REQUIRE(bv80.GetValueAtBit<5>(64) == 2);
  246|       |// }
  247|       |
  248|       |
  249|       |TEST_CASE("Test DFA", "[tools]")
  250|      1|{
  251|      1|  emp::DFA dfa(10);
  252|      1|  dfa.SetTransition(0, 1, 'a');
  253|      1|  dfa.SetTransition(1, 2, 'a');
  254|      1|  dfa.SetTransition(2, 0, 'a');
  255|      1|  dfa.SetTransition(0, 3, 'b');
  256|      1|
  257|      1|  int state = 0;
  258|      1|  REQUIRE( (state = dfa.Next(state, 'a')) == 1 );
  259|      1|  REQUIRE( (state = dfa.Next(state, 'a')) == 2 );
  260|      1|  REQUIRE( (state = dfa.Next(state, 'a')) == 0 );
  261|      1|  REQUIRE( (state = dfa.Next(state, 'b')) == 3 );
  262|      1|  REQUIRE( (state = dfa.Next(state, 'b')) == -1 );
  263|      1|  REQUIRE( (state = dfa.Next(state, 'b')) == -1 );
  264|      1|  REQUIRE( (state = dfa.Next(state, 'b')) == -1 );
  265|      1|
  266|      1|  REQUIRE(dfa.Next(0, "aaaaaab") == 3);
  267|      1|  REQUIRE(dfa.Next(0, "aaaaab") == -1);
  268|      1|  REQUIRE(dfa.Next(0, "aaaaaabb") == -1);
  269|      1|  REQUIRE(dfa.Next(0, "a") == 1);
  270|      1|  REQUIRE(dfa.Next(0, "aa") == 2);
  271|      1|  REQUIRE(dfa.Next(0, "aaa") == 0);
  272|      1|  REQUIRE(dfa.Next(0, "b")  == 3);
  273|      1|}
  274|       |
  275|       |TEST_CASE("Test DynamicString", "[tools]")
  276|      1|{
  277|      1|  emp::DynamicString test_set;
  278|      1|
  279|      1|  test_set.Append("Line Zero");  // Test regular append
  280|      1|  test_set << "Line One";        // Test stream append
  281|      1|
  282|      1|  // Test append-to-stream
  283|      1|  std::stringstream ss;
  284|      1|  ss << test_set;
  285|      1|  REQUIRE(ss.str() == "Line ZeroLine One");
  286|      1|
  287|      1|  // Test direct conversion to string.
  288|      1|  REQUIRE(test_set.str() == "Line ZeroLine One");
  289|      1|
  290|      1|  // Test appending functions.
  291|      1|  test_set.Append( [](){ return std::string("Line Two"); } );
  292|      1|  test_set.Append( [](){ return "Line Three"; } );
  293|      1|
  294|      1|  // Test appending functions with variable output
  295|      1|  int line_no = 20;
  296|      3|  test_set.Append( [&line_no](){ return std::string("Line ") + std::to_string(line_no); } );
  297|      1|
  298|      1|  REQUIRE(test_set[4] == "Line 20");
  299|      1|  line_no = 4;
  300|      1|  REQUIRE(test_set[4] == "Line 4");
  301|      1|
  302|      1|  // Make sure we can change an existing line.
  303|      1|  test_set.Set(0, "Line 0");
  304|      1|  REQUIRE(test_set[0] == "Line 0");
  305|      1|
  306|      1|  // Make sure all lines are what we expect.
  307|      1|  REQUIRE(test_set[0] == "Line 0");
  308|      1|  REQUIRE(test_set[1] == "Line One");
  309|      1|  REQUIRE(test_set[2] == "Line Two");
  310|      1|  REQUIRE(test_set[3] == "Line Three");
  311|      1|  REQUIRE(test_set[4] == "Line 4");
  312|      1|}
  313|       |
  314|      5|int Sum4(int a1, int a2, int a3, int a4) {
  315|      5|  return a1 + a2 + a3 + a4;
  316|      5|}
  317|       |
  318|       |TEST_CASE("Test flex_function", "[tools]")
  319|      1|{
  320|      1|  emp::flex_function<int(int,int,int,int)> ff = Sum4;
  321|      1|  ff.SetDefaults(10, 100,1000,10000);
  322|      1|
  323|      1|  REQUIRE( ff(1,2,3,4) == 10 );
  324|      1|  REQUIRE( ff(1,2,3) == 10006 );
  325|      1|  REQUIRE( ff(1,2) == 11003 );
  326|      1|  REQUIRE( ff(1) == 11101 );
  327|      1|  REQUIRE( ff() == 11110 );
  328|      1|}
  329|       |
  330|       |TEST_CASE("Test functions", "[tools]")
  331|      1|{
  332|      1|
  333|      1|  bool test_bool = true;
  334|      1|  emp::Toggle(test_bool);
  335|      1|  REQUIRE(test_bool == false);
  336|      1|
  337|      1|  REQUIRE(emp::ToRange(-10000, 10, 20) == 10);
  338|      1|  REQUIRE(emp::ToRange(9, 10, 20) == 10);
  339|      1|  REQUIRE(emp::ToRange(10, 10, 20) == 10);
  340|      1|  REQUIRE(emp::ToRange(11, 10, 20) == 11);
  341|      1|  REQUIRE(emp::ToRange(17, 10, 20) == 17);
  342|      1|  REQUIRE(emp::ToRange(20, 10, 20) == 20);
  343|      1|  REQUIRE(emp::ToRange(21, 10, 20) == 20);
  344|      1|  REQUIRE(emp::ToRange(12345678, 10, 20) == 20);
  345|      1|  REQUIRE(emp::ToRange<double>(12345678, 10, 20.1) == 20.1);
  346|      1|  REQUIRE(emp::ToRange(12345678.0, 10.7, 20.1) == 20.1);
  347|      1|}
  348|       |
  349|       |// should migrate these inside the test case, probably
  350|       |
  351|       |// utility funcs for FunctionSet test case
  352|       |int global_var1;
  353|       |int global_var2;
  354|       |int global_var3;
  355|       |int global_var4;
  356|       |
  357|      2|void fun1(int in1, int in2) { global_var1 = in1 + in2; }
  358|      2|void fun2(int in1, int in2) { global_var2 = in1 - in2; }
  359|      1|void fun3(int in1, int in2) { global_var3 = in1 * in2; }
  360|      2|void fun4(int in1, int in2) { global_var4 = in1 / in2; }
  361|       |
  362|     24|double fun5(double input) { return input; }
  363|     24|double fun6(double input) { return input * input; }
  364|     24|double fun7(double input) { return input * input * input; }
  365|       |
  366|       |TEST_CASE("Test FunctionSet", "[tools]")
  367|      1|{
  368|      1|  // TEST 1: Functions with VOID returns.
  369|      1|  emp::FunctionSet<void(int,int)> fun_set;
  370|      1|  fun_set.Add(&fun1);
  371|      1|  fun_set.Add(&fun2);
  372|      1|  fun_set.Add(&fun3);
  373|      1|  fun_set.Add(&fun4);
  374|      1|
  375|      1|  fun_set.Run(10, 2);
  376|      1|
  377|      1|  REQUIRE(global_var1 == 12);
  378|      1|  REQUIRE(global_var2 == 8);
  379|      1|  REQUIRE(global_var3 == 20);
  380|      1|  REQUIRE(global_var4 == 5);
  381|      1|
  382|      1|  fun_set.Remove(2);           // What if we remove a function
  383|      1|
  384|      1|  fun_set.Run(20, 5);
  385|      1|
  386|      1|  REQUIRE(global_var1 == 25);
  387|      1|  REQUIRE(global_var2 == 15);
  388|      1|  REQUIRE(global_var3 == 20);  // Same as last time!!
  389|      1|  REQUIRE(global_var4 == 4);
  390|      1|
  391|      1|  // Test 2: Functions with non-void returns.
  392|      1|  emp::FunctionSet<double(double)> fun_set2;
  393|      1|  fun_set2.Add(&fun5);
  394|      1|  fun_set2.Add(&fun6);
  395|      1|  fun_set2.Add(&fun7);
  396|      1|
  397|      1|  emp::vector<double> out_vals;
  398|      1|
  399|      1|  out_vals = fun_set2.Run(10.0);
  400|      1|
  401|      1|  REQUIRE(out_vals[0] == 10.0);
  402|      1|  REQUIRE(out_vals[1] == 100.0);
  403|      1|  REQUIRE(out_vals[2] == 1000.0);
  404|      1|
  405|      1|  out_vals = fun_set2.Run(-10.0);
  406|      1|
  407|      1|  REQUIRE(out_vals[0] == -10.0);
  408|      1|  REQUIRE(out_vals[1] == 100.0);
  409|      1|  REQUIRE(out_vals[2] == -1000.0);
  410|      1|
  411|      1|  out_vals = fun_set2.Run(0.1);
  412|      1|
  413|      1|  REQUIRE(out_vals[0] == 0.1);
  414|      1|  REQUIRE(out_vals[1] < 0.01000001);
  415|      1|  REQUIRE(out_vals[1] > 0.00999999);
  416|      1|  REQUIRE(out_vals[2] < 0.00100001);
  417|      1|  REQUIRE(out_vals[2] > 0.00099999);
  418|      1|
  419|      1|  out_vals = fun_set2.Run(-0.1);
  420|      1|
  421|      1|  REQUIRE(out_vals[0] == -0.1);
  422|      1|  REQUIRE(out_vals[1] < 0.01000001);
  423|      1|  REQUIRE(out_vals[1] > 0.00999999);
  424|      1|  REQUIRE(out_vals[2] > -0.00100001);
  425|      1|  REQUIRE(out_vals[2] < -0.00099999);
  426|      1|
  427|      1|
  428|      1|  // TEST 3: Running functions and auto-processing return values.
  429|      1|  REQUIRE(fun_set2.FindMax(10.0) == 1000.0);
  430|      1|  REQUIRE(fun_set2.FindMax(-10.0) == 100.0);
  431|      1|  REQUIRE(fun_set2.FindMax(0.1) == 0.1);
  432|      1|  REQUIRE(fun_set2.FindMax(-0.1) < 0.0100000001);
  433|      1|  REQUIRE(fun_set2.FindMax(-0.1) > 0.0099999999);
  434|      1|
  435|      1|  REQUIRE(fun_set2.FindMin(10.0) == 10.0);
  436|      1|  REQUIRE(fun_set2.FindMin(-10.0) == -1000.0);
  437|      1|  REQUIRE(fun_set2.FindMin(0.1) < 0.0010000001);
  438|      1|  REQUIRE(fun_set2.FindMin(0.1) > 0.0009999999);
  439|      1|  REQUIRE(fun_set2.FindMin(-0.1) == -0.1);
  440|      1|
  441|      1|  REQUIRE(fun_set2.FindSum(10.0) == 1110.0);
  442|      1|  REQUIRE(fun_set2.FindSum(-10.0) == -910.0);
  443|      1|  REQUIRE(fun_set2.FindSum(0.1) < 0.1110000001);
  444|      1|  REQUIRE(fun_set2.FindSum(0.1) > 0.1109999999);
  445|      1|  REQUIRE(fun_set2.FindSum(-0.1) == -0.091);
  446|      1|
  447|      1|
  448|      1|  // TEST 4: Manually-entered aggregation function.
  449|      1|  std::function<double(double,double)> test_fun =
  450|     10|    [](double i1, double i2){ return std::max(i1,i2); };
  451|      1|
  452|      1|  REQUIRE(fun_set2.Run(10.0, test_fun) == 1000.0);
  453|      1|  REQUIRE(fun_set2.Run(-10.0, test_fun) == 100.0);
  454|      1|  REQUIRE(fun_set2.Run(0.1, test_fun) == 0.1);
  455|      1|  REQUIRE(fun_set2.Run(-0.1, test_fun) < 0.01000000001);
  456|      1|  REQUIRE(fun_set2.Run(-0.1, test_fun) > 0.00999999999);
  457|      1|}
  458|       |
  459|       |// TODO: add moar asserts
  460|       |TEST_CASE("Test graph", "[tools]")
  461|      1|{
  462|      1|
  463|      1|  emp::Graph graph(20);
  464|      1|
  465|      1|  REQUIRE(graph.GetSize() == 20);
  466|      1|
  467|      1|  graph.AddEdgePair(0, 1);
  468|      1|  graph.AddEdgePair(0, 2);
  469|      1|  graph.AddEdgePair(0, 3);
  470|      1|
  471|      1|}
  472|       |
  473|       |// // TODO: add asserts
  474|       |// emp::Random grand;
  475|       |TEST_CASE("Test Graph utils", "[tools]")
  476|      1|{
  477|      1|  emp::Random random;
  478|      1|  // emp::Graph graph( emp::build_graph_tree(20, random) );
  479|      1|  // emp::Graph graph( emp::build_graph_random(20, 40, random) );
  480|      1|  emp::Graph graph( emp::build_graph_grid(5, 4, random) );
  481|      1|
  482|      1|  // graph.PrintSym();
  483|      1|}
  484|       |
  485|       |
  486|       |/*TEST_CASE("Test grid", "[tools]")
  487|       |{
  488|       |  emp::Grid::Layout layout(10,10);
  489|       |
  490|       |  REQUIRE(layout.GetNumRegions() == 0);
  491|       |  layout.AddRegion({0,1,2,3,4,5,6,7,8});
  492|       |
  493|       |  REQUIRE(layout.GetNumRegions() == 1);
  494|       |
  495|       |  emp::Grid::Board<void, void, void> board1(layout);
  496|       |  emp::Grid::Board<bool, bool, bool> board2(layout);
  497|       |  emp::Grid::Board<int, int, int> board3(layout);
  498|       |  emp::Grid::Board<int, void, void> board4(layout);
  499|       |  emp::Grid::Board<void, int, void> board5(layout);
  500|       |  emp::Grid::Board<void, void, int> board6(layout);
  501|       |  //TODO: moar asserts
  502|       |}*/
  503|       |
  504|       |
  505|       |TEST_CASE("Test info_theory", "[tools]")
  506|      1|{
  507|      1|  emp::vector<int> weights = { 100, 100, 200 };
  508|      1|  REQUIRE( emp::Entropy(weights) == 1.5 );
  509|      1|
  510|      1|  emp::vector<double> dweights = { 10.5, 10.5, 10.5, 10.5, 21.0, 21.0 };
  511|      1|  REQUIRE( emp::Entropy(dweights) == 2.5 );
  512|      1|
  513|      1|  REQUIRE( emp::Entropy2(0.5) == 1.0 );
  514|      1|}
  515|       |
  516|       |TEST_CASE("Test lexer_utils", "[tools]")
  517|      1|{
  518|      1|  emp::NFA nfa2c(3);  // Must have zero or two c's with any number of a's or b's.
  519|      1|  nfa2c.AddTransition(0,0,"ab");
  520|      1|  nfa2c.AddTransition(0,1,"c");
  521|      1|  nfa2c.AddTransition(1,1,"ab");
  522|      1|  nfa2c.AddTransition(1,2,"c");
  523|      1|  nfa2c.AddTransition(2,2,"ab");
  524|      1|  nfa2c.AddFreeTransition(0,2);
  525|      1|  nfa2c.SetStop(2);
  526|      1|
  527|      1|  emp::RegEx re2f("[de]*f[de]*f[de]*");
  528|      1|  // emp::RegEx re2f("([de]*)f([de]*)f([de]*)");
  529|      1|emp::NFA nfa2f = to_NFA(re2f);
  530|      1|emp::DFA dfa2f = to_DFA(nfa2f);
  531|      1|REQUIRE( nfa2f.GetSize() == 12 );
  532|      1|REQUIRE( dfa2f.GetSize() == 3 );
  533|      1|
  534|      1|  int state;
  535|      1|  state = dfa2f.Next(0, "a");        REQUIRE(state == -1); REQUIRE(dfa2f.IsStop(state) == false);
  536|      1|  state = dfa2f.Next(0, "d");        REQUIRE(state == 0); REQUIRE(dfa2f.IsStop(state) == false);
  537|      1|  state = dfa2f.Next(0, "defdef");   REQUIRE(state == 2); REQUIRE(dfa2f.IsStop(state) == true);
  538|      1|  state = dfa2f.Next(0, "fedfed");   REQUIRE(state == 2); REQUIRE(dfa2f.IsStop(state) == true);
  539|      1|  state = dfa2f.Next(0, "ffed");     REQUIRE(state == 2); REQUIRE(dfa2f.IsStop(state) == true);
  540|      1|  state = dfa2f.Next(0, "edffed");   REQUIRE(state == 2); REQUIRE(dfa2f.IsStop(state) == true);
  541|      1|  state = dfa2f.Next(0, "edffedf");  REQUIRE(state == -1); REQUIRE(dfa2f.IsStop(state) == false);
  542|      1|  state = dfa2f.Next(0, "defed");    REQUIRE(state == 1); REQUIRE(dfa2f.IsStop(state) == false);
  543|      1|  state = dfa2f.Next(0, "ff");       REQUIRE(state == 2); REQUIRE(dfa2f.IsStop(state) == true);
  544|      1|
  545|      1|  emp::RegEx re_lower("[a-z]+");
  546|      1|  emp::RegEx re_upper("[A-Z]+");
  547|      1|  emp::RegEx re_inc("[a-z]+[A-Z]+");
  548|      1|  emp::NFA nfa_lower = to_NFA(re_lower);
  549|      1|  emp::NFA nfa_upper = to_NFA(re_upper);
  550|      1|  emp::NFA nfa_inc = to_NFA(re_inc);
  551|      1|  emp::NFA nfa_all = MergeNFA(nfa_lower, nfa_upper, nfa_inc);
  552|      1|  emp::DFA dfa_lower = to_DFA(nfa_lower);
  553|      1|  emp::DFA dfa_upper = to_DFA(nfa_upper);
  554|      1|  emp::DFA dfa_inc = to_DFA(nfa_inc);
  555|      1|  emp::DFA dfa_all = to_DFA(nfa_all);
  556|      1|
  557|      1|  emp::NFA_State lstate(nfa_lower);
  558|      1|  lstate.Reset(); lstate.Next("abc");      REQUIRE(lstate.IsActive() == true);
  559|      1|  lstate.Reset(); lstate.Next("DEF");      REQUIRE(lstate.IsActive() == false);
  560|      1|  lstate.Reset(); lstate.Next("abcDEF");   REQUIRE(lstate.IsActive() == false);
  561|      1|  lstate.Reset(); lstate.Next("ABDdef");   REQUIRE(lstate.IsActive() == false);
  562|      1|  lstate.Reset(); lstate.Next("ABCDEF");   REQUIRE(lstate.IsActive() == false);
  563|      1|  lstate.Reset(); lstate.Next("abcdefghijklmnopqrstuvwxyz");  REQUIRE(lstate.IsActive() == true);
  564|      1|  lstate.Reset(); lstate.Next("ABC-DEF");  REQUIRE(lstate.IsActive() == false);
  565|      1|
  566|      1|  REQUIRE( dfa_all.Next(0, "abc") == 2 );
  567|      1|  REQUIRE( dfa_all.Next(0, "DEF") == 1 );
  568|      1|  REQUIRE( dfa_all.Next(0, "abcDEF") == 3 );
  569|      1|  REQUIRE( dfa_all.Next(0, "ABDdef") == -1 );
  570|      1|  REQUIRE( dfa_all.Next(0, "ABCDEF") == 1 );
  571|      1|  REQUIRE( dfa_all.Next(0, "abcdefghijklmnopqrstuvwxyz") == 2 );
  572|      1|  REQUIRE( dfa_all.Next(0, "ABC-DEF") == -1 );
  573|      1|}
  574|       |
  575|       |
  576|       |TEST_CASE("Test Lexer", "[tools]")
  577|      1|{
  578|      1|  emp::Lexer lexer;
  579|      1|  lexer.AddToken("Integer", "[0-9]+");
  580|      1|  lexer.AddToken("Float", "[0-9]*\\.[0-9]+");
  581|      1|  lexer.AddToken("Lower", "[a-z]+");
  582|      1|  lexer.AddToken("Upper", "[A-Z]+");
  583|      1|  lexer.AddToken("Mixed", "[a-zA-Z]+");
  584|      1|  lexer.AddToken("Whitespace", "[ \t\n\r]");
  585|      1|  lexer.AddToken("Other", ".");
  586|      1|
  587|      1|  std::stringstream ss;
  588|      1|  ss << "This is a 123 TEST.  It should also have 1. .2 123.456 789 FLOATING point NUMbers!";
  589|      1|
  590|      1|  REQUIRE(lexer.Process(ss).lexeme == "This");
  591|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  592|      1|  REQUIRE(lexer.Process(ss).lexeme == "is");
  593|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  594|      1|  REQUIRE(lexer.Process(ss).lexeme == "a");
  595|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  596|      1|  REQUIRE(lexer.Process(ss).lexeme == "123");
  597|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  598|      1|  REQUIRE(lexer.Process(ss).lexeme == "TEST");
  599|      1|  REQUIRE(lexer.Process(ss).lexeme == ".");
  600|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  601|      1|  REQUIRE(lexer.Process(ss).lexeme == " ");
  602|      1|
  603|      1|  REQUIRE(lexer.GetTokenName(lexer.Process(ss)) == "Mixed");
  604|      1|  REQUIRE(lexer.GetTokenName(lexer.Process(ss)) == "Whitespace");
  605|      1|  REQUIRE(lexer.GetTokenName(lexer.Process(ss)) == "Lower");
  606|      1|}
  607|       |
  608|       |
  609|       |TEST_CASE("Test map_utils", "[tools]")
  610|      1|{
  611|      1|  std::map<int, char> test_map;
  612|      1|  test_map[0] = 'a';
  613|      1|  test_map[4] = 'e';
  614|      1|  test_map[8] = 'i';
  615|      1|  test_map[14] = 'o';
  616|      1|  test_map[20] = 'u';
  617|      1|
  618|      1|  REQUIRE( emp::Has(test_map, 8) == true );
  619|      1|  REQUIRE( emp::Has(test_map, 18) == false );
  620|      1|  REQUIRE( emp::Find(test_map, 14, 'x') == 'o'); // 14 should be there as 'o'
  621|      1|  REQUIRE( emp::Find(test_map, 15, 'x') == 'x'); // 15 shouldn't be there, so return default.
  622|      1|  REQUIRE( emp::Has(test_map, 15) == false );    // Make sure 15 hasn't been added to the map.
  623|      1|
  624|      1|  auto flipped = emp::flip_map(test_map);        // Make sure we can reverse the map.
  625|      1|  REQUIRE( emp::Has(flipped, 'u') == true);      // And the reversed map should have proper info.
  626|      1|  REQUIRE( emp::Has(flipped, 'x') == false);
  627|      1|
  628|      1|  // Testing for bug #123
  629|      1|  std::map<std::string, std::string> test_123;
  630|      1|  test_123["1"] = "1";
  631|      1|  test_123["12"] = "12";
  632|      1|
  633|      1|  REQUIRE( emp::Find(test_123, "0", "nothing") == "nothing" );
  634|      1|  REQUIRE( emp::Find(test_123, "1", "nothing") == "1" );
  635|      1|  REQUIRE( emp::FindRef(test_123, "1", "nothing") == "1" );
  636|      1|}
  637|       |
  638|       |TEST_CASE("Test math", "[tools]")
  639|      1|{
  640|      1|  constexpr auto a1 = emp::Log2(3.14);           REQUIRE( a1 > 1.650);   REQUIRE( a1 < 1.651);
  641|      1|  constexpr auto a2 = emp::Log2(0.125);          REQUIRE( a2 == -3.0 );
  642|      1|  constexpr auto a3 = emp::Log(1000, 10);        REQUIRE( a3 == 3.0 );
  643|      1|  constexpr auto a4 = emp::Log(10, 1000);        REQUIRE( a4 > 0.333 );  REQUIRE( a4 < 0.334 );
  644|      1|  constexpr auto a5 = emp::Log10(100);           REQUIRE( a5 == 2.0 );
  645|      1|  constexpr auto a6 = emp::Ln(3.33);             REQUIRE( a6 > 1.202 );  REQUIRE( a6 < 1.204 );
  646|      1|  constexpr auto a7 = emp::Pow2(2.345);          REQUIRE( a7 > 5.080 );  REQUIRE( a7 < 5.081 );
  647|      1|  constexpr auto a8 = emp::Pow(emp::PI, emp::E); REQUIRE( a8 > 22.440 ); REQUIRE( a8 < 22.441 );
  648|      1|  constexpr auto a9 = emp::Pow(7, 10);           REQUIRE( a9 == 282475249 );
  649|      1|
  650|      1|  REQUIRE(emp::Mod(10, 7) == 3);
  651|      1|  REQUIRE(emp::Mod(3, 7) == 3);
  652|      1|  REQUIRE(emp::Mod(-4, 7) == 3);
  653|      1|  REQUIRE(emp::Mod(-11, 7) == 3);
  654|      1|
  655|      1|  REQUIRE(emp::Mod(-11, 11) == 0);
  656|      1|  REQUIRE(emp::Mod(0, 11) == 0);
  657|      1|  REQUIRE(emp::Mod(11, 11) == 0);
  658|      1|
  659|      1|  REQUIRE(emp::Pow(2,3) == 8);
  660|      1|  REQUIRE(emp::Pow(-2,2) == 4);
  661|      1|  REQUIRE(emp::IntPow(3,4) == 81);
  662|      1|
  663|      1|  REQUIRE(emp::Min(5) == 5);
  664|      1|  REQUIRE(emp::Min(5,10) == 5);
  665|      1|  REQUIRE(emp::Min(10,5) == 5);
  666|      1|  REQUIRE(emp::Min(40,30,20,10,5,15,25,35) == 5);
  667|      1|
  668|      1|  REQUIRE(emp::Max(5) == 5);
  669|      1|  REQUIRE(emp::Max(5,10) == 10);
  670|      1|  REQUIRE(emp::Max(10,5) == 10);
  671|      1|  REQUIRE(emp::Max(40,30,20,10,45,15,25,35) == 45);
  672|      1|}
  673|       |
  674|       |
  675|       |struct TestClass1 {
  676|  1.00k|  TestClass1() {
  677|  1.00k|    EMP_TRACK_CONSTRUCT(TestClass1);
  678|  1.00k|  }
  679|    500|  ~TestClass1() {
  680|    500|    EMP_TRACK_DESTRUCT(TestClass1);
  681|    500|  }
  682|       |};
  683|       |
  684|       |struct TestClass2 {
  685|      1|  TestClass2() {
  686|      1|    EMP_TRACK_CONSTRUCT(TestClass2);
  687|      1|  }
  688|      1|  ~TestClass2() {
  689|      1|    EMP_TRACK_DESTRUCT(TestClass2);
  690|      1|  }
  691|       |};
  692|       |
  693|       |TEST_CASE("Test mem_track", "[tools]")
  694|      1|{
  695|      1|  emp::vector<TestClass1 *> test_v;
  696|      1|  TestClass2 class2_mem;
  697|      1|
  698|       |  #ifdef EMP_TRACK_MEM
  699|       |  REQUIRE(EMP_TRACK_COUNT(TestClass1) == 0);
  700|       |  #endif
  701|       |
  702|  1.00k|  for (int i = 0; i < 1000; i++) {
  703|  1.00k|    test_v.push_back( new TestClass1 );
  704|  1.00k|  }
  705|      1|
  706|       |  #ifdef EMP_TRACK_MEM
  707|       |  REQUIRE(EMP_TRACK_COUNT(TestClass1) == 1000);
  708|       |  #endif
  709|       |
  710|    501|  for (size_t i = 500; i < 1000; i++) {
  711|    500|    delete test_v[i];
  712|    500|  }
  713|      1|
  714|       |  #ifdef EMP_TRACK_MEM
  715|       |  REQUIRE(EMP_TRACK_COUNT(TestClass1) == 500);
  716|       |  //REQUIRE(EMP_TRACK_STATUS == 0);
  717|       |  #endif
  718|       |
  719|      1|}
  720|       |
  721|       |
  722|       |TEST_CASE("Test emp::memo_function", "[tools]")
  723|      1|{
  724|      1|  emp::memo_function<uint64_t(int)> test_fun;
  725|      1|
  726|      1|  // Build a Fibonacchi function...
  727|     81|  test_fun = [&test_fun](int N) {
  728|     81|    if (N<=1) return (uint64_t) N;
  729|     79|    return test_fun(N-1) + test_fun(N-2);
  730|     79|  };
  731|      1|
  732|      1|  REQUIRE( test_fun(80) == 0x533163ef0321e5 );
  733|      1|}
  734|       |
  735|       |
  736|       |TEST_CASE("Test NFA", "[tools]")
  737|      1|{
  738|      1|  emp::NFA nfa(10);
  739|      1|  nfa.AddTransition(0, 1, 'a');
  740|      1|  nfa.AddTransition(0, 2, 'a');
  741|      1|  nfa.AddTransition(0, 3, 'a');
  742|      1|  nfa.AddTransition(0, 4, 'a');
  743|      1|
  744|      1|  nfa.AddTransition(1, 2, 'b');
  745|      1|  nfa.AddTransition(2, 3, 'c');
  746|      1|  nfa.AddTransition(3, 4, 'd');
  747|      1|
  748|      1|  nfa.AddTransition(0, 1, 'e');
  749|      1|  nfa.AddTransition(0, 1, 'f');
  750|      1|  nfa.AddTransition(0, 1, 'g');
  751|      1|
  752|      1|  nfa.AddTransition(2, 3, 'a');
  753|      1|  nfa.AddTransition(3, 4, 'a');
  754|      1|  nfa.AddTransition(2, 4, 'a');
  755|      1|
  756|      1|  nfa.AddTransition(2, 2, 'e');
  757|      1|  nfa.AddTransition(3, 3, 'e');
  758|      1|  nfa.AddTransition(4, 4, 'e');
  759|      1|
  760|      1|  nfa.AddFreeTransition(1,5);
  761|      1|
  762|      1|  nfa.AddTransition(5, 6, 'a');
  763|      1|
  764|      1|  nfa.AddFreeTransition(6,7);
  765|      1|  nfa.AddFreeTransition(6,8);
  766|      1|  nfa.AddFreeTransition(6,9);
  767|      1|  nfa.AddFreeTransition(9,0);
  768|      1|
  769|      1|  emp::NFA_State state(nfa);
  770|      1|  REQUIRE(state.GetSize() == 1);
  771|      1|  state.Next('a');
  772|      1|  REQUIRE(state.GetSize() == 5);
  773|      1|  state.Next('a');
  774|      1|  REQUIRE(state.GetSize() == 7);
  775|      1|
  776|      1|  emp::NFA_State state2(nfa);
  777|      1|  REQUIRE(state2.GetSize() == 1);
  778|      1|  state2.Next("aaaa");
  779|      1|  REQUIRE(state2.GetSize() == 7);
  780|      1|}
  781|       |
  782|       |
  783|       |
  784|       |TEST_CASE("Test random", "[tools]")
  785|      1|{
  786|      1|  emp::Random rng;
  787|      1|
  788|      1|  // Test GetDouble with the law of large numbers.
  789|      1|  emp::vector<int> val_counts(10);
  790|     11|  for (size_t i = 0; i < val_counts.size(); i++) val_counts[i] = 0;
  791|      1|
  792|      1|  const size_t num_tests = 100000;
  793|      1|  const double min_value = 2.5;
  794|      1|  const double max_value = 8.7;
  795|      1|  double total = 0.0;
  796|   100k|  for (size_t i = 0; i < num_tests; i++) {
  797|   100k|    const double cur_value = rng.GetDouble(min_value, max_value);
  798|   100k|    total += cur_value;
  799|   100k|    val_counts[(size_t) cur_value]++;
  800|   100k|  }
  801|      1|
  802|      1|  {
  803|      1|    const double expected_mean = (min_value + max_value) / 2.0;
  804|      1|    const double min_threshold = (expected_mean*0.995);
  805|      1|    const double max_threshold = (expected_mean*1.005);
  806|      1|    double mean_value = total/(double) num_tests;
  807|      1|
  808|      1|    REQUIRE(mean_value > min_threshold);
  809|      1|    REQUIRE(mean_value < max_threshold);
  810|      1|  }
  811|      1|
  812|      1|  // Test GetInt
  813|     11|  for (size_t i = 0; i < val_counts.size(); i++) val_counts[i] = 0;
  814|      1|  total = 0.0;
  815|      1|
  816|   100k|  for (size_t i = 0; i < num_tests; i++) {
  817|   100k|    const size_t cur_value = rng.GetUInt(min_value, max_value);
  818|   100k|    total += cur_value;
  819|   100k|    val_counts[cur_value]++;
  820|   100k|  }
  821|      1|
  822|      1|  {
  823|      1|    const double expected_mean = (double) (((int) min_value) + ((int) max_value) - 1) / 2.0;
  824|      1|    const double min_threshold = (expected_mean*0.995);
  825|      1|    const double max_threshold = (expected_mean*1.005);
  826|      1|    double mean_value = total/(double) num_tests;
  827|      1|
  828|      1|    REQUIRE(mean_value > min_threshold);
  829|      1|    REQUIRE(mean_value < max_threshold);
  830|      1|  }
  831|      1|
  832|      1|  // Test P
  833|      1|  double flip_prob = 0.56789;
  834|      1|  int hit_count = 0;
  835|   100k|  for (size_t i = 0; i < num_tests; i++) {
  836|   100k|    if (rng.P(flip_prob)) hit_count++;
  837|   100k|  }
  838|      1|
  839|      1|  double actual_prob = ((double) hit_count) / (double) num_tests;
  840|      1|
  841|      1|  REQUIRE(actual_prob < flip_prob + 0.01);
  842|      1|  REQUIRE(actual_prob > flip_prob - 0.01);
  843|      1|
  844|      1|
  845|      1|  // Mimimal test of Choose()
  846|      1|  emp::vector<size_t> choices = Choose(rng,100,10);
  847|      1|
  848|      1|  REQUIRE(choices.size() == 10);
  849|      1|}
  850|       |
  851|       |
  852|       |TEST_CASE("Test regular expressions (RegEx)", "[tools]")
  853|      1|{
  854|      1|  emp::RegEx re1("a|bcdef");
  855|      1|  REQUIRE(re1.Test("a") == true);
  856|      1|  REQUIRE(re1.Test("bc") == false);
  857|      1|  REQUIRE(re1.Test("bcdef") == true);
  858|      1|  REQUIRE(re1.Test("bcdefg") == false);
  859|      1|
  860|      1|  emp::RegEx re2("#[abcdefghijklm]*abc");
  861|      1|  REQUIRE(re2.Test("") == false);
  862|      1|  REQUIRE(re2.Test("#a") == false);
  863|      1|  REQUIRE(re2.Test("#aaaabc") == true);
  864|      1|  REQUIRE(re2.Test("#abcabc") == true);
  865|      1|  REQUIRE(re2.Test("#abcabcd") == false);
  866|      1|
  867|      1|  emp::RegEx re3("xx(y|(z*)?)+xx");
  868|      1|  REQUIRE(re3.Test("xxxx") == true);
  869|      1|  REQUIRE(re3.Test("xxxxx") == false);
  870|      1|  REQUIRE(re3.Test("xxyxx") == true);
  871|      1|  REQUIRE(re3.Test("xxyyxx") == true);
  872|      1|  REQUIRE(re3.Test("xxzzzxx") == true);
  873|      1|
  874|      1|  emp::RegEx re_WHITESPACE("[ \t\r]");
  875|      1|  emp::RegEx re_COMMENT("#.*");
  876|      1|  emp::RegEx re_INT_LIT("[0-9]+");
  877|      1|  emp::RegEx re_FLOAT_LIT("[0-9]+[.][0-9]+");
  878|      1|  emp::RegEx re_CHAR_LIT("'(.|(\\\\[\\\\'nt]))'");
  879|      1|  emp::RegEx re_STRING_LIT("[\"]((\\\\[nt\"\\\\])|[^\"])*\\\"");
  880|      1|  emp::RegEx re_ID("[a-zA-Z0-9_]+");
  881|      1|
  882|      1|  REQUIRE(re_INT_LIT.Test("1234") == true);
  883|      1|  REQUIRE(re_FLOAT_LIT.Test("1234") == false);
  884|      1|  REQUIRE(re_ID.Test("1234") == true);
  885|      1|  REQUIRE(re_INT_LIT.Test("1234.56") == false);
  886|      1|  REQUIRE(re_FLOAT_LIT.Test("1234.56") == true);
  887|      1|  REQUIRE(re_ID.Test("1234.56") == false);
  888|      1|
  889|      1|  std::string test_str = "\"1234\"";
  890|      1|  REQUIRE(re_STRING_LIT.Test(test_str) == true);
  891|      1|  REQUIRE(re_INT_LIT.Test(test_str) == false);
  892|      1|
  893|      1|  std::string test_str2 = "\"1234\", \"5678\"";
  894|      1|  REQUIRE(re_STRING_LIT.Test(test_str2) == false);
  895|      1|}
  896|       |
  897|       |TEST_CASE("Test sequence utils", "[tools]")
  898|      1|{
  899|      1|  std::string s1 = "This is the first test string.";
  900|      1|  std::string s2 = "This is the second test string.";
  901|      1|
  902|      1|  REQUIRE(emp::calc_hamming_distance(s1,s2) == 19);
  903|      1|  REQUIRE(emp::calc_edit_distance(s1,s2) == 6);
  904|      1|
  905|      1|  // std::string s3 = "abcdefghijklmnopqrstuvwWxyz";
  906|      1|  // std::string s4 = "abBcdefghijXXmnopqrstuvwxyz";
  907|      1|
  908|      1|  // std::string s3 = "lmnopqrstuv";
  909|      1|  // std::string s4 = "abcdefghijklmnopqrstuvwxyz";
  910|      1|
  911|      1|  std::string s3 = "adhlmnopqrstuvxy";
  912|      1|  std::string s4 = "abcdefghijklmnopqrstuvwxyz";
  913|      1|
  914|      1|  emp::align(s3, s4, '_');
  915|      1|
  916|      1|  REQUIRE(s3 == "a__d___h___lmnopqrstuv_xy_");
  917|      1|
  918|      1|  emp::vector<int> v1 = { 1,2,3,4,5,6,7,8,9 };
  919|      1|  emp::vector<int> v2 = { 1,4,5,6,8 };
  920|      1|
  921|      1|  emp::align(v1,v2,0);
  922|      1|
  923|      1|  REQUIRE((v2 == emp::vector<int>({1,0,0,4,5,6,0,8,0})));
  924|      1|}
  925|       |
  926|       |
  927|       |
  928|       |// struct SerializeTest {
  929|       |//   int a;
  930|       |//   float b;        // unimportant data!
  931|       |//   std::string c;
  932|       |
  933|       |//   SerializeTest(int _a, float _b, std::string _c) : a(_a), b(_b), c(_c) { ; }
  934|       |//   EMP_SETUP_DATAPOD(SerializeTest, a, c);
  935|       |// };
  936|       |
  937|       |// struct SerializeTest_D : public SerializeTest {
  938|       |//   char d = '$';
  939|       |
  940|       |//   SerializeTest_D(int _a, float _b, std::string _c, char _d)
  941|       |//     : SerializeTest(_a, _b, _c), d(_d) { ; }
  942|       |//   EMP_SETUP_DATAPOD_D(SerializeTest_D, SerializeTest, d);
  943|       |// };
  944|       |
  945|       |// struct ExtraBase {
  946|       |//   double e;
  947|       |
  948|       |//   ExtraBase(double _e) : e(_e) { ; }
  949|       |//   EMP_SETUP_DATAPOD(ExtraBase, e);
  950|       |// };
  951|       |
  952|       |// struct MultiTest : public SerializeTest, public ExtraBase {
  953|       |//   bool f;
  954|       |
  955|       |//   MultiTest(int _a, float _b, std::string _c, double _e, bool _f)
  956|       |//     : SerializeTest(_a, _b, _c), ExtraBase(_e), f(_f) { ; }
  957|       |//   EMP_SETUP_DATAPOD_D2(MultiTest, SerializeTest, ExtraBase, f);
  958|       |// };
  959|       |
  960|       |// struct NestedTest {
  961|       |//   SerializeTest st;
  962|       |//   std::string name;
  963|       |//   SerializeTest_D std;
  964|       |//   MultiTest mt;
  965|       |
  966|       |//   NestedTest(int a1, float b1, std::string c1,
  967|       |//              int a2, float b2, std::string c2, char d2,
  968|       |//              int a3, float b3, std::string c3, double e3, bool f3)
  969|       |//     : st(a1, b1, c1), name("my_class"), std(a2, b2, c2, d2), mt(a3, b3, c3, e3, f3) { ; }
  970|       |
  971|       |//   EMP_SETUP_DATAPOD(NestedTest, st, name, std, mt);
  972|       |// };
  973|       |
  974|       |// struct BuiltInTypesTest {
  975|       |//   const int a;
  976|       |//   emp::vector<int> int_v;
  977|       |
  978|       |//   BuiltInTypesTest(int _a, size_t v_size) : a(_a), int_v(v_size) {
  979|       |//     for (size_t i = 0; i < v_size; i++) int_v[i] = (int)(i*i);
  980|       |//   }
  981|       |
  982|       |//   EMP_SETUP_DATAPOD(BuiltInTypesTest, a, int_v);
  983|       |// };
  984|       |
  985|       |// TEST_CASE("Test serialize", "[tools]")
  986|       |// {
  987|       |//   std::stringstream ss;
  988|       |//   emp::serialize::DataPod pod(ss);
  989|       |
  990|       |
  991|       |//   // Basic test...
  992|       |
  993|       |//   SerializeTest st(7, 2.34, "my_test_string");
  994|       |//   st.EMP_Store(pod);
  995|       |
  996|       |//   SerializeTest st2(pod);
  997|       |
  998|       |//   REQUIRE(st2.a == 7);                 // Make sure a was reloaded correctly.
  999|       |//   REQUIRE(st2.c == "my_test_string");  // Make sure c was reloaded correctly.
 1000|       |
 1001|       |
 1002|       |//   // Derived class Test
 1003|       |
 1004|       |//   SerializeTest_D stD(10,0.2,"three",'D');
 1005|       |//   stD.EMP_Store(pod);
 1006|       |
 1007|       |//   SerializeTest_D stD2(pod);
 1008|       |
 1009|       |//   REQUIRE(stD2.a == 10);
 1010|       |//   REQUIRE(stD2.c == "three");
 1011|       |//   REQUIRE(stD2.d == 'D');
 1012|       |
 1013|       |//   // Multiply-derived class Test
 1014|       |
 1015|       |//   MultiTest stM(111,2.22,"ttt",4.5,true);
 1016|       |//   stM.EMP_Store(pod);
 1017|       |
 1018|       |//   MultiTest stM2(pod);
 1019|       |
 1020|       |
 1021|       |//   REQUIRE(stM2.a == 111);
 1022|       |//   REQUIRE(stM2.c == "ttt");
 1023|       |//   REQUIRE(stM2.e == 4.5);
 1024|       |//   REQUIRE(stM2.f == true);
 1025|       |
 1026|       |
 1027|       |//   // Nested objects test...
 1028|       |
 1029|       |//   NestedTest nt(91, 3.14, "magic numbers",
 1030|       |//                 100, 0.01, "powers of 10", '1',
 1031|       |//                 1001, 1.001, "ones and zeros", 0.125, true);
 1032|       |//   nt.EMP_Store(pod);
 1033|       |
 1034|       |//   NestedTest nt2(pod);
 1035|       |
 1036|       |//   REQUIRE(nt2.st.a == 91);
 1037|       |//   REQUIRE(nt2.st.c == "magic numbers");
 1038|       |//   REQUIRE(nt2.name == "my_class");
 1039|       |//   REQUIRE(nt2.std.a == 100);
 1040|       |//   REQUIRE(nt2.std.c == "powers of 10");
 1041|       |//   REQUIRE(nt2.std.d == '1');
 1042|       |//   REQUIRE(nt2.mt.a == 1001);
 1043|       |//   REQUIRE(nt2.mt.c == "ones and zeros");
 1044|       |//   REQUIRE(nt2.mt.e == 0.125);
 1045|       |//   REQUIRE(nt2.mt.f == true);
 1046|       |
 1047|       |
 1048|       |//   // If we made it this far, everything must have worked!;
 1049|       |
 1050|       |//   const int v_size = 43;
 1051|       |//   BuiltInTypesTest bitt(91, v_size);
 1052|       |//   bitt.EMP_Store(pod);
 1053|       |
 1054|       |
 1055|       |//   BuiltInTypesTest bitt2(pod);
 1056|       |// }
 1057|       |
 1058|       |
 1059|       |
 1060|       |TEST_CASE("Test string utils", "[tools]")
 1061|      1|{
 1062|      1|
 1063|      1|  // TEST1: lets test our conversion to an escaped string.
 1064|      1|  const std::string special_string = "This\t5tr1ng\nis\non THREE (3) \"lines\".";
 1065|      1|  std::string escaped_string = emp::to_escaped_string(special_string);
 1066|      1|
 1067|      1|  // note: we had to double-escape the test to make sure this worked.
 1068|      1|  REQUIRE(escaped_string == "This\\t5tr1ng\\nis\\non THREE (3) \\\"lines\\\".");
 1069|      1|
 1070|      1|  // TEST2: Test more general conversion to literals.
 1071|      1|  REQUIRE(emp::to_literal(42) == "42");
 1072|      1|  REQUIRE(emp::to_literal('a') == "'a'");
 1073|      1|  REQUIRE(emp::to_literal('\t') == "'\\t'");
 1074|      1|  REQUIRE(emp::to_literal(1.234) == "1.234000");
 1075|      1|
 1076|      1|  // TEST3: Make sure that we can properly identify different types of characters.
 1077|      1|  int num_ws = 0;
 1078|      1|  int num_cap = 0;
 1079|      1|  int num_lower = 0;
 1080|      1|  int num_let = 0;
 1081|      1|  int num_num = 0;
 1082|      1|  int num_alphanum = 0;
 1083|      1|  int num_i = 0;
 1084|      1|  int num_vowel = 0;
 1085|     36|  for (char cur_char : special_string) {
 1086|     36|    if (emp::is_whitespace(cur_char)) num_ws++;
 1087|     36|    if (emp::is_upper_letter(cur_char)) num_cap++;
 1088|     36|    if (emp::is_lower_letter(cur_char)) num_lower++;
 1089|     36|    if (emp::is_letter(cur_char)) num_let++;
 1090|     36|    if (emp::is_digit(cur_char)) num_num++;
 1091|     36|    if (emp::is_alphanumeric(cur_char)) num_alphanum++;
 1092|     36|    if (emp::is_valid(cur_char, [](char c){ return c=='i'; })) num_i++;
 1093|     36|    if (emp::is_valid(cur_char, [](char c){return c=='a' || c=='A';},
 1094|     36|                      [](char c){return c=='e' || c=='E';},
 1095|     36|                      [](char c){return c=='i' || c=='I';},
 1096|     36|                      [](char c){return c=='o' || c=='O';},
 1097|     36|                      [](char c){return c=='u' || c=='U';},
 1098|     36|                      [](char c){return c=='y';}
 1099|     36|                      )) num_vowel++;
 1100|     36|  }
 1101|      1|  int num_other = ((int) special_string.size()) - num_alphanum - num_ws;
 1102|      1|
 1103|      1|
 1104|      1|  REQUIRE(num_ws == 6);
 1105|      1|  REQUIRE(num_cap == 6);
 1106|      1|  REQUIRE(num_lower == 16);
 1107|      1|  REQUIRE(num_let == 22);
 1108|      1|  REQUIRE(num_num == 3);
 1109|      1|  REQUIRE(num_alphanum == 25);
 1110|      1|  REQUIRE(num_other == 5);
 1111|      1|  REQUIRE(num_i == 3);
 1112|      1|  REQUIRE(num_vowel == 7);
 1113|      1|
 1114|      1|  std::string base_string = "This is an okay string.\n  \tThis\nis   -MY-    very best string!!!!   ";
 1115|      1|
 1116|      1|  std::string first_line = emp::string_pop_line(base_string);
 1117|      1|
 1118|      1|  REQUIRE(first_line == "This is an okay string.");
 1119|      1|  REQUIRE(emp::string_get_word(first_line) == "This");
 1120|      1|
 1121|      1|  emp::string_pop_word(first_line);
 1122|      1|
 1123|      1|  REQUIRE(first_line == "is an okay string.");
 1124|      1|
 1125|      1|  emp::remove_whitespace(first_line);
 1126|      1|
 1127|      1|  REQUIRE(first_line == "isanokaystring.");
 1128|      1|
 1129|      1|  std::string popped_str = emp::string_pop(first_line, "ns");
 1130|      1|
 1131|      1|  REQUIRE(popped_str == "i");
 1132|      1|  REQUIRE(first_line == "anokaystring.");
 1133|      1|
 1134|      1|
 1135|      1|
 1136|      1|  popped_str = emp::string_pop(first_line, "ns");
 1137|      1|
 1138|      1|
 1139|      1|  REQUIRE(popped_str == "a");
 1140|      1|  REQUIRE(first_line == "okaystring.");
 1141|      1|
 1142|      1|
 1143|      1|
 1144|      1|  popped_str = emp::string_pop(first_line, 'y');
 1145|      1|
 1146|      1|  REQUIRE(popped_str == "oka");
 1147|      1|  REQUIRE(first_line == "string.");
 1148|      1|
 1149|      1|  emp::left_justify(base_string);
 1150|      1|  REQUIRE(base_string == "This\nis   -MY-    very best string!!!!   ");
 1151|      1|
 1152|      1|  emp::right_justify(base_string);
 1153|      1|  REQUIRE(base_string == "This\nis   -MY-    very best string!!!!");
 1154|      1|
 1155|      1|  emp::compress_whitespace(base_string);
 1156|      1|  REQUIRE(base_string == "This is -MY- very best string!!!!");
 1157|      1|
 1158|      1|  auto slices = emp::slice("This is a test of a different version of slice.", ' ');
 1159|      1|
 1160|      1|  REQUIRE(slices.size() == 10);
 1161|      1|  REQUIRE(slices[8] == "of");
 1162|      1|
 1163|      1|  // Try other ways of using slice().
 1164|      1|  emp::slice(base_string, slices, 's');
 1165|      1|
 1166|      1|  REQUIRE(slices.size() == 5);
 1167|      1|  REQUIRE(slices[1] == " i");
 1168|      1|  REQUIRE(slices[3] == "t ");
 1169|      1|
 1170|      1|
 1171|      1|  // Some tests of to_string() function.
 1172|      1|  REQUIRE(emp::to_string((int) 1) == "1");
 1173|      1|  REQUIRE(emp::to_string("2") == "2");
 1174|      1|  REQUIRE(emp::to_string(std::string("3")) == "3");
 1175|      1|  REQUIRE(emp::to_string('4') == "4");
 1176|      1|  REQUIRE(emp::to_string((int16_t) 5) == "5");
 1177|      1|  REQUIRE(emp::to_string((int32_t) 6) == "6");
 1178|      1|  REQUIRE(emp::to_string((int64_t) 7) == "7");
 1179|      1|  REQUIRE(emp::to_string((uint16_t) 8) == "8");
 1180|      1|  REQUIRE(emp::to_string((uint32_t) 9) == "9");
 1181|      1|  REQUIRE(emp::to_string((uint64_t) 10) == "10");
 1182|      1|  REQUIRE(emp::to_string((size_t) 11) == "11");
 1183|      1|  REQUIRE(emp::to_string((long) 12) == "12");
 1184|      1|  REQUIRE(emp::to_string((unsigned long) 13) == "13");
 1185|      1|  REQUIRE(emp::to_string((float) 14.0) == "14.000000");
 1186|      1|  REQUIRE(emp::to_string((double) 15.0) == "15.000000");
 1187|      1|  REQUIRE(emp::to_string(16.0) == "16.000000");
 1188|      1|  REQUIRE(emp::to_string(emp::vector<size_t>({17,18,19})) == "[ 17 18 19 ]");
 1189|      1|  REQUIRE(emp::to_string((char) 32) == " ");
 1190|      1|  REQUIRE(emp::to_string((unsigned char) 33) == "!");
 1191|      1|
 1192|      1|  std::string cat_a = "ABC";
 1193|      1|  bool cat_b = true;
 1194|      1|  char cat_c = '2';
 1195|      1|  int cat_d = 3;
 1196|      1|
 1197|      1|  std::string cat_full = emp::to_string(cat_a, cat_b, cat_c, cat_d);
 1198|      1|
 1199|      1|  REQUIRE(cat_full == "ABC123");
 1200|      1|  std::array<int, 3> test_arr({{ 4, 2, 5 }});
 1201|      1|  REQUIRE(emp::to_string(test_arr) == "[ 4 2 5 ]");
 1202|      1|}
 1203|       |
 1204|       |
 1205|       |
 1206|       |// Build some sample functions that we want called by type.
 1207|       |std::string tt_result;
 1208|      1|void fun_int_int(int x, int y) { tt_result = emp::to_string(x+y); }
 1209|      1|void fun_int_double(int x, double y) { tt_result = emp::to_string(y * (double) x); }
 1210|      1|void fun_string_int(std::string x, int y) {
 1211|      1|  tt_result = "";
 1212|      4|  for (int i=0; i < y; i++) tt_result += x;
 1213|      1|}
 1214|       |
 1215|       |TEST_CASE("Test type tracker (TypeTracker)", "[tools]")
 1216|      1|{
 1217|      1|  using tt_t = emp::TypeTracker<int, std::string, double>;   // Setup the tracker type.
 1218|      1|  tt_t tt;                                                   // Build the tracker.
 1219|      1|
 1220|      1|  // Add some functions.
 1221|      1|  tt.AddFunction(fun_int_int);
 1222|      1|  tt.AddFunction(fun_int_double);
 1223|      1|  tt.AddFunction(fun_string_int);
 1224|      1|
 1225|      1|  emp::TrackedType * tt_int1 = tt.New<int>(1);
 1226|      1|  emp::TrackedType * tt_int2 = tt.New<int>(2);
 1227|      1|  emp::TrackedType * tt_int3 = tt.New<int>(3);
 1228|      1|
 1229|      1|  emp::TrackedType * tt_str  = tt.New<std::string>("FOUR");
 1230|      1|  emp::TrackedType * tt_doub = tt.New<double>(5.5);
 1231|      1|
 1232|      1|  tt.RunFunction(tt_int1, tt_int2);  // An int and another int should add.
 1233|      1|  REQUIRE( tt_result == "3" );
 1234|      1|
 1235|      1|  tt.RunFunction(tt_int3, tt_doub);  // An int and a double should multiply.
 1236|      1|  REQUIRE( tt_result == "16.500000" );
 1237|      1|
 1238|      1|  tt.RunFunction(tt_doub, tt_int2); // A double and an int is unknown; should leave old result.
 1239|      1|  REQUIRE( tt_result == "16.500000" );
 1240|      1|
 1241|      1|  tt.RunFunction(tt_str, tt_int3);    // A string an an int should duplicate the string.
 1242|      1|  REQUIRE( tt_result == "FOURFOURFOUR" );
 1243|      1|
 1244|      1|
 1245|      1|  REQUIRE( (tt_t::GetID<int,std::string,double>()) == (tt_t::GetTrackedID(tt_int1, tt_str, tt_doub)) );
 1246|      1|  REQUIRE( (tt_t::GetComboID<int,std::string,double>()) == (tt_t::GetTrackedComboID(tt_int1, tt_str, tt_doub)) );
 1247|      1|}
 1248|       |
 1249|      1|TEST_CASE("Test stats", "[tools]") {
 1250|      1|  emp::vector<int> vec1({1,2,1,1,2,3});
 1251|      1|  double i1 = 1;
 1252|      1|  double i2 = 1;
 1253|      1|  double i3 = 1;
 1254|      1|  double i4 = 2;
 1255|      1|
 1256|      1|  emp::vector<double*> vec2({&i1, &i2, &i3, &i4});
 1257|      1|
 1258|      1|  std::deque<double> deque1({5,4,3,5,4,6});
 1259|      1|
 1260|      1|  REQUIRE(emp::ShannonEntropy(vec1) == Approx(1.459324));
 1261|      1|  REQUIRE(emp::ShannonEntropy(vec2) == Approx(0.81128));
 1262|      1|  REQUIRE(emp::ShannonEntropy(deque1) == Approx(1.918648));
 1263|      1|
 1264|      1|  REQUIRE(emp::Variance(vec1) == Approx(0.55539));
 1265|      1|  REQUIRE(emp::Variance(vec2) == Approx(0.1875));
 1266|      1|  REQUIRE(emp::Variance(deque1) == Approx(0.9166666667));
 1267|      1|
 1268|      1|  REQUIRE(emp::StandardDeviation(vec1) == Approx(0.745245));
 1269|      1|  REQUIRE(emp::StandardDeviation(vec2) == Approx(0.433013));
 1270|      1|  REQUIRE(emp::StandardDeviation(deque1) == Approx(0.957427));
 1271|      1|
 1272|      1|  REQUIRE(emp::Sum(vec1) == 10);
 1273|      1|  REQUIRE(emp::Sum(vec2) == 5);
 1274|      1|  REQUIRE(emp::Sum(deque1) == 27);
 1275|      1|
 1276|      1|  REQUIRE(emp::UniqueCount(vec1) == 3);
 1277|      1|  REQUIRE(emp::UniqueCount(vec2) == 2);
 1278|      1|  REQUIRE(emp::UniqueCount(deque1) == 4);
 1279|      1|
 1280|      1|  REQUIRE(emp::Mean(vec1) == Approx(1.6666666666667));
 1281|      1|  REQUIRE(emp::Mean(vec2) == Approx(1.25));
 1282|      1|  REQUIRE(emp::Mean(deque1) == 4.5);
 1283|      1|
 1284|     26|  std::function<int(int)> invert = [](int i){return i*-1;};
 1285|      1|
 1286|      1|  REQUIRE(emp::MaxResult(invert, vec1) == -1);
 1287|      1|  REQUIRE(emp::MinResult(invert, vec1) == -3);
 1288|      1|  REQUIRE(emp::MeanResult(invert, vec1) == Approx(-1.666666667));
 1289|      1|  REQUIRE(emp::ApplyFunction(invert, vec1) == emp::vector<int>({-1,-2,-1,-1,-2,-3}));
 1290|      1|
 1291|      1|}
 1292|       |
 1293|      1|TEST_CASE("Test set utils", "[tools]") {
 1294|      1|  std::set<int> s1;
 1295|      1|  std::set<int> s2;
 1296|      1|  std::set<int> comp_set;
 1297|      1|  emp::vector<int> v1;
 1298|      1|  emp::vector<int> v2;
 1299|      1|
 1300|      1|  s1.insert(1);
 1301|      1|  s1.insert(2);
 1302|      1|  s2.insert(2);
 1303|      1|  s2.insert(3);
 1304|      1|  v1.push_back(1);
 1305|      1|  v1.push_back(3);
 1306|      1|  v2.push_back(4);
 1307|      1|  v2.push_back(1);
 1308|      1|
 1309|      1|  REQUIRE(emp::Has(s1, 1));
 1310|      1|  REQUIRE(!emp::Has(s1, 3));
 1311|      1|
 1312|      1|  comp_set.insert(1);
 1313|      1|  REQUIRE(emp::difference(s1, s2) == comp_set);
 1314|      1|  comp_set.clear();
 1315|      1|  comp_set.insert(3);
 1316|      1|  REQUIRE(emp::difference(s2, s1) == comp_set);
 1317|      1|  comp_set.clear();
 1318|      1|  comp_set.insert(2);
 1319|      1|  REQUIRE(emp::intersection(s1, s2) == comp_set);
 1320|      1|  REQUIRE(emp::intersection(s2, s1) == comp_set);
 1321|      1|  comp_set.clear();
 1322|      1|  comp_set.insert(2);
 1323|      1|  REQUIRE(emp::difference(s1, v1) == comp_set);
 1324|      1|  comp_set.clear();
 1325|      1|  comp_set.insert(1);
 1326|      1|  REQUIRE(emp::intersection(s1, v1) == comp_set);
 1327|      1|  REQUIRE(emp::intersection(v1, s1) == comp_set);
 1328|      1|  REQUIRE(emp::intersection(v2, v1) == comp_set);
 1329|      1|  REQUIRE(emp::intersection(v1, v2) == comp_set);
 1330|      1|  comp_set.clear();
 1331|      1|  comp_set.insert(4);
 1332|      1|  REQUIRE(emp::difference(v2, v1) == comp_set);
 1333|      1|  comp_set.clear();
 1334|      1|  comp_set.insert(1);
 1335|      1|  comp_set.insert(2);
 1336|      1|  comp_set.insert(3);
 1337|      1|  REQUIRE(emp::set_union(s1, s2) == comp_set);
 1338|      1|  REQUIRE(emp::set_union(s2, s1) == comp_set);
 1339|      1|  comp_set.clear();
 1340|      1|  comp_set.insert(1);
 1341|      1|  comp_set.insert(2);
 1342|      1|  comp_set.insert(3);
 1343|      1|  comp_set.insert(4);
 1344|      1|  REQUIRE(emp::set_union(v2, s2) == comp_set);
 1345|      1|  REQUIRE(emp::set_union(s2, v2) == comp_set);
 1346|      1|  comp_set.clear();
 1347|      1|  comp_set.insert(1);
 1348|      1|  comp_set.insert(3);
 1349|      1|  comp_set.insert(4);
 1350|      1|  REQUIRE(emp::set_union(v2, v1) == comp_set);
 1351|      1|  REQUIRE(emp::set_union(v1, v2) == comp_set);
 1352|      1|  comp_set.clear();
 1353|      1|  comp_set.insert(1);
 1354|      1|  comp_set.insert(3);
 1355|      1|  REQUIRE(emp::symmetric_difference(s1, s2) == comp_set);
 1356|      1|  REQUIRE(emp::symmetric_difference(s2, s1) == comp_set);
 1357|      1|  comp_set.clear();
 1358|      1|  comp_set.insert(4);
 1359|      1|  comp_set.insert(3);
 1360|      1|  REQUIRE(emp::symmetric_difference(v1, v2) == comp_set);
 1361|      1|  REQUIRE(emp::symmetric_difference(v2, v1) == comp_set);
 1362|      1|  comp_set.clear();
 1363|      1|  comp_set.insert(2);
 1364|      1|  comp_set.insert(3);
 1365|      1|  REQUIRE(emp::symmetric_difference(v1, s1) == comp_set);
 1366|      1|  REQUIRE(emp::symmetric_difference(s1, v1) == comp_set);
 1367|      1|
 1368|      1|}
 1369|       |
 1370|      1|TEST_CASE("Test vector utils", "[tools]") {
 1371|      1|  emp::vector<int> v1({6,2,5,1,3});
 1372|      1|  emp::Sort(v1);
 1373|      1|  REQUIRE(v1 == emp::vector<int>({1,2,3,5,6}));
 1374|      1|  REQUIRE(emp::FindValue(v1, 3) == 2);
 1375|      1|  REQUIRE(emp::Sum(v1) == 17);
 1376|      1|  REQUIRE(emp::Has(v1, 3));
 1377|      1|  REQUIRE(!emp::Has(v1, 4));
 1378|      1|  REQUIRE(emp::Product(v1) == 180);
 1379|      1|  REQUIRE(emp::Slice(v1,1,3) == emp::vector<int>({2,3}));
 1380|      1|}
 1381|       |
 1382|       |// DEFINE_ATTR(Foo);
 1383|       |// DEFINE_ATTR(Bar);
 1384|       |// DEFINE_ATTR(Bazz);
 1385|       |
 1386|       |struct ident_t {
 1387|       |  template <typename T>
 1388|       |  constexpr decltype(auto) operator()(T&& value) const {
 1389|       |    return std::forward<T>(value);
 1390|       |  }
 1391|       |};
 1392|       |
 1393|       |constexpr ident_t ident{};
 1394|       |
 1395|       |template <typename T>
 1396|       |struct Callable {
 1397|       |  T value;
 1398|       |
 1399|       |  constexpr decltype(auto) operator()() & { return value; }
 1400|       |  constexpr decltype(auto) operator()() const & { return value; }
 1401|       |  constexpr decltype(auto) operator()() && { return std::move(value); }
 1402|       |  constexpr decltype(auto) operator()() const && { return std::move(value); }
 1403|       |};
 1404|       |template <typename T>
 1405|       |constexpr Callable<std::decay_t<T>> callable(T&& value) {
 1406|       |  return {std::forward<T>(value)};
 1407|       |}
 1408|       |
 1409|       |struct NoCopy {
 1410|       |  int value;
 1411|      0|  constexpr NoCopy(int value) : value(value) {}
 1412|       |  constexpr NoCopy(const NoCopy&) = delete;
 1413|       |  constexpr NoCopy(NoCopy&&) = default;
 1414|       |
 1415|       |  constexpr NoCopy& operator=(const NoCopy&) = delete;
 1416|       |  constexpr NoCopy& operator=(NoCopy&&) = default;
 1417|       |};
 1418|      0|constexpr bool operator==(const NoCopy& a, const NoCopy& b) {
 1419|      0|  return a.value == b.value;
 1420|      0|}
 1421|      0|std::ostream& operator<<(std::ostream& out, const NoCopy& nc) {
 1422|      0|  return out << "NoCopy{" << nc.value << "}";
 1423|      0|}
 1424|       |
 1425|       |struct {
 1426|       |  template <typename I, typename T>
 1427|       |  constexpr auto operator()(I&& init, T&& value) const {
 1428|       |    return std::forward<I>(init) + std::forward<T>(value).Get();
 1429|       |  }
 1430|       |
 1431|       |  template <typename I, typename T>
 1432|       |  constexpr auto operator()(const char* name, I&& init, T&& value) const {
 1433|       |    return std::forward<I>(init) + std::forward<T>(value);
 1434|       |  }
 1435|       |} sum;
 1436|       |
 1437|       |struct {
 1438|       |  template <typename I, typename A, typename B>
 1439|       |  constexpr auto operator()(I&& init, A&& a, B&& b) const {
 1440|       |    return std::forward<I>(init) +
 1441|       |           (std::forward<A>(a).Get() * std::forward<B>(b).Get());
 1442|       |  }
 1443|       |} dot;
 1444|       |
 1445|       |struct {
 1446|       |  template <typename I, typename T>
 1447|       |  constexpr NoCopy operator()(I&& init, T&& value) const {
 1448|       |    return {std::forward<I>(init).value + std::forward<T>(value).Get().value};
 1449|       |  }
 1450|       |
 1451|       |  template <typename I, typename T>
 1452|       |  constexpr NoCopy operator()(const char* name, I&& init, T&& value) const {
 1453|       |    return {std::forward<I>(init).value + std::forward<T>(value).value};
 1454|       |  }
 1455|       |} sum_nocopy;
 1456|       |
 1457|       |// TEST_CASE("Test Attribute Packs", "[tools]") {
 1458|       |//   using namespace emp::tools;
 1459|       |//   // Test Construction & access
 1460|       |//   CONSTEXPR_REQUIRE_EQ(Foo::CallOrGetAttribute(Foo(6)).Get(), 6);
 1461|       |//   CONSTEXPR_REQUIRE_EQ(Foo::CallOrGetAttribute(Foo(callable(7))).Get(), 7);
 1462|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrElse(Foo(7), callable(0)), 7);
 1463|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrElse(Merge(Foo(7), Bar(6)), callable(0)), 7);
 1464|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrElse(Merge(Bazz(7), Bar(6)), callable(0)), 0);
 1465|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Bazz(1), Bar(2), Foo(3)), 3);
 1466|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Bazz(1), Foo(3), Foo(2)), 3);
 1467|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Foo(3), Bar(2), Bazz(1)), 3);
 1468|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Foo(3), Bar(2)), 3);
 1469|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Bar(2), Foo(3)), 3);
 1470|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Foo(3)), 3);
 1471|       |
 1472|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOr(Foo(7), 0), 7);
 1473|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOr(Merge(Foo(7), Bar(6)), 0), 7);
 1474|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOr(Merge(Bazz(7), Bar(6)), 0), 0);
 1475|       |
 1476|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Foo(5), Bar(6)), Merge(Foo(5), Bar(6)));
 1477|       |
 1478|       |//   // Test NoCopy
 1479|       |//   CONSTEXPR_REQUIRE_EQ(Foo::CallOrGetAttribute(Foo(NoCopy{7})).Get(),
 1480|       |//                        NoCopy{7});
 1481|       |//   CONSTEXPR_REQUIRE_EQ(Foo::CallOrGetAttribute(Foo(callable(NoCopy{7}))).Get(),
 1482|       |//                        NoCopy{7});
 1483|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrElse(Foo(NoCopy{7}), callable(NoCopy{0})),
 1484|       |//                        NoCopy{7});
 1485|       |//   CONSTEXPR_REQUIRE_EQ(
 1486|       |//     Foo::GetOrElse(Merge(Foo(NoCopy{7}), Bar(NoCopy{6})), callable(NoCopy{7})),
 1487|       |//     NoCopy{7});
 1488|       |//   CONSTEXPR_REQUIRE_EQ(
 1489|       |//     Foo::GetOrElse(Merge(Bazz(NoCopy{7}), Bar(NoCopy{6})), callable(NoCopy{0})),
 1490|       |//     NoCopy{0});
 1491|       |
 1492|       |//   CONSTEXPR_REQUIRE_EQ(
 1493|       |//     Foo::GetOrGetIn(Bazz(NoCopy{1}), Bar(NoCopy{2}), Foo(NoCopy{3})),
 1494|       |//     NoCopy{3});
 1495|       |//   CONSTEXPR_REQUIRE_EQ(
 1496|       |//     Foo::GetOrGetIn(Bazz(NoCopy{1}), Foo(NoCopy{3}), Foo(NoCopy{2})),
 1497|       |//     NoCopy{3});
 1498|       |//   CONSTEXPR_REQUIRE_EQ(
 1499|       |//     Foo::GetOrGetIn(Foo(NoCopy{3}), Bar(NoCopy{2}), Bazz(NoCopy{1})),
 1500|       |//     NoCopy{3});
 1501|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Foo(NoCopy{3}), Bar(NoCopy{2})),
 1502|       |//                        NoCopy{3});
 1503|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Bar(NoCopy{2}), Foo(NoCopy{3})),
 1504|       |//                        NoCopy{3});
 1505|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOrGetIn(Foo(NoCopy{3})), NoCopy{3});
 1506|       |
 1507|       |//   CONSTEXPR_REQUIRE_EQ(Foo::GetOr(Foo(NoCopy{7}), NoCopy{0}), NoCopy{7});
 1508|       |//   CONSTEXPR_REQUIRE_EQ(
 1509|       |//     Foo::GetOr(Merge(Foo(NoCopy{7}), Bar(NoCopy{6})), NoCopy{0}), NoCopy{7});
 1510|       |//   CONSTEXPR_REQUIRE_EQ(
 1511|       |//     Foo::GetOr(Merge(Bazz(NoCopy{7}), Bar(NoCopy{6})), NoCopy{0}), NoCopy{0});
 1512|       |
 1513|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Foo(NoCopy{5}), Bar(NoCopy{6})),
 1514|       |//                        Merge(Foo(NoCopy{5}), Bar(NoCopy{6})));
 1515|       |
 1516|       |//   // Test Mapping
 1517|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Foo(ident), Bar(6))(5), Merge(Foo(5), Bar(6)));
 1518|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Foo(ident), Bar(6))(5), Merge(Foo(5), Bar(6)));
 1519|       |
 1520|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Bar(6), Foo(ident))(NoCopy{5}),
 1521|       |//                        Merge(Foo(NoCopy{5}), Bar(6)));
 1522|       |
 1523|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Bar(NoCopy{6}), Foo(ident))(5),
 1524|       |//                        Merge(Foo(5), Bar(NoCopy{6})));
 1525|       |
 1526|       |//   CONSTEXPR_REQUIRE_EQ(Merge(Bar(5), Foo(6)).Reduce(0, sum), 11);
 1527|       |//   CONSTEXPR_REQUIRE_EQ(
 1528|       |//     Merge(Bar(NoCopy{5}), Foo(NoCopy{6})).Reduce(NoCopy{0}, sum_nocopy),
 1529|       |//     NoCopy{11});
 1530|       |//   CONSTEXPR_REQUIRE_EQ(MergeReduce(0, sum, Bar(6), Foo(7)), 6 + 7);
 1531|       |//   // CONSTEXPR_REQUIRE_EQ(MergeReduce(0, [](auto init, auto& a, auto& b) {return
 1532|       |//   // init + a.Get() * b.Get();}, Bar(6) + Foo(7), Bar(11) + Foo(12)),
 1533|       |//   //                      6 + 7);
 1534|       |// }

